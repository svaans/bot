[[["ChangeSet", ["Writing file <core/reporting.py>", [["ChangeContents", ["core/reporting.py", "import os\nimport json\nfrom datetime import datetime\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_pdf import PdfPages\nfrom core.utils.utils import configurar_logger\nfrom core.utils.utils import leer_csv_seguro\n\n\nclass ReporterDiario:\n    def __init__(self, carpeta=\"reportes_diarios\"):\n        self.carpeta = carpeta\n        os.makedirs(self.carpeta, exist_ok=True)\n        self.fecha_actual = datetime.utcnow().date()\n        self.log = configurar_logger(\"reporte\")\n        self.estadisticas_archivo = os.path.join(self.carpeta, \"estadisticas.csv\")\n        self._cargar_estadisticas()\n        self.ultimas_operaciones = {}\n\n    def _cargar_estadisticas(self):\n        columnas = [\n            \"symbol\",\n            \"operaciones\",\n            \"wins\",\n            \"retorno_acumulado\",\n            \"max_equity\",\n            \"drawdown\",\n            \"buy_hold_start\",\n            \"last_price\",\n        ]\n        if os.path.exists(self.estadisticas_archivo):\n            try:\n                self.estadisticas = leer_csv_seguro(\n                    self.estadisticas_archivo, expected_cols=len(columnas)\n                )\n            except Exception:\n                self.estadisticas = pd.DataFrame(columns=columnas)\n        else:\n            self.estadisticas = pd.DataFrame(columns=columnas)\n\n    def _guardar_estadisticas(self):\n        if self.estadisticas.empty:\n            return\n        df = self.estadisticas.copy()\n        df[\"winrate\"] = (df[\"wins\"] / df[\"operaciones\"]) * 100\n        df[\"buy_hold\"] = (df[\"last_price\"] - df[\"buy_hold_start\"]) / df[\"buy_hold_start\"]\n        df.to_csv(self.estadisticas_archivo, index=False)\n\n    def _actualizar_estadisticas(self, info: dict):\n        symbol = info.get(\"symbol\") or info.get(\"simbolo\")\n        if not symbol:\n            return\n        retorno = float(info.get(\"retorno_total\", 0.0))\n        entrada = float(info.get(\"precio_entrada\", 0.0))\n        cierre = float(info.get(\"precio_cierre\", entrada))\n\n        if symbol not in self.estadisticas[\"symbol\"].values:\n            nueva = {\n                \"symbol\": symbol,\n                \"operaciones\": 0,\n                \"wins\": 0,\n                \"retorno_acumulado\": 0.0,\n                \"max_equity\": 0.0,\n                \"drawdown\": 0.0,\n                \"buy_hold_start\": entrada if entrada else cierre,\n                \"last_price\": cierre,\n            }\n            frames = [df for df in [self.estadisticas, pd.DataFrame([nueva])] if not df.empty]\n            self.estadisticas = pd.concat(frames, ignore_index=True) if frames else pd.DataFrame([nueva])\n\n        if self.estadisticas.empty:\n            return\n        filas = self.estadisticas[self.estadisticas[\"symbol\"] == symbol]\n        if filas.empty:\n            return\n        idx = filas.index[0]\n        self.estadisticas.loc[idx, \"operaciones\"] += 1\n        self.estadisticas.loc[idx, \"retorno_acumulado\"] += retorno\n        if retorno > 0:\n            self.estadisticas.loc[idx, \"wins\"] += 1\n        acum = self.estadisticas.loc[idx, \"retorno_acumulado\"]\n        max_eq = self.estadisticas.loc[idx, \"max_equity\"]\n        max_eq = max(max_eq, acum)\n        self.estadisticas.loc[idx, \"max_equity\"] = max_eq\n        self.estadisticas.loc[idx, \"drawdown\"] = min(self.estadisticas.loc[idx, \"drawdown\"], acum - max_eq)\n        if self.estadisticas.loc[idx, \"buy_hold_start\"] == 0:\n            self.estadisticas.loc[idx, \"buy_hold_start\"] = entrada if entrada else cierre\n        self.estadisticas.loc[idx, \"last_price\"] = cierre\n        self._guardar_estadisticas()\n\n    def registrar_operacion(self, info: dict):\n        fecha = datetime.utcnow().date()\n        archivo = os.path.join(self.carpeta, f\"{fecha}.csv\")\n        df = pd.DataFrame([info])\n        if os.path.exists(archivo):\n            df.to_csv(archivo, mode=\"a\", header=False, index=False)\n        else:\n            df.to_csv(archivo, index=False)\n        symbol = info.get(\"symbol\") or info.get(\"simbolo\")\n        if symbol:\n            self.ultimas_operaciones.setdefault(symbol, [])\n            self.ultimas_operaciones[symbol].append(info)\n        self.log.info(f\"\ud83d\udcdd Operaci\u00f3n registrada para reporte {fecha}\")\n        self._actualizar_estadisticas(info)\n        if fecha != self.fecha_actual:\n            self.generar_informe(self.fecha_actual)\n            self.fecha_actual = fecha\n\n    def generar_informe(self, fecha):\n        archivo = os.path.join(self.carpeta, f\"{fecha}.csv\")\n        if not os.path.exists(archivo):\n            return\n        df = leer_csv_seguro(archivo, expected_cols=20)\n        if df.empty:\n            return\n        ganancia_total = df[\"retorno_total\"].sum()\n        winrate = (df[\"retorno_total\"] > 0).mean() * 100\n        curva = df[\"retorno_total\"].cumsum()\n        drawdown = (curva - curva.cummax()).min()\n\n        total_ops = len(df)\n        ganadas = (df[\"retorno_total\"] > 0).sum()\n        perdidas = total_ops - ganadas\n        beneficio_prom = df[df[\"retorno_total\"] > 0][\"retorno_total\"].mean()\n        perdida_prom = df[df[\"retorno_total\"] <= 0][\"retorno_total\"].mean()\n        mejor = df[\"retorno_total\"].max()\n        peor = df[\"retorno_total\"].min()\n        estrategias_usadas = {}\n        if \"estrategias\" in df.columns:\n            col = df[\"estrategias\"]\n        else:\n            col = df.get(\"estrategias_activas\")\n        if col is not None:\n            for val in col.dropna():\n                if isinstance(val, str):\n                    try:\n                        data = json.loads(val.replace(\"'\", '\"'))\n                        if isinstance(data, dict):\n                            val = list(data.keys())\n                    except Exception:\n                        val = [val]\n                if isinstance(val, dict):\n                    val = list(val.keys())\n                if isinstance(val, list):\n                    for e in val:\n                        estrategias_usadas[e] = estrategias_usadas.get(e, 0) + 1\n        mas_usadas = \",\".join(sorted(estrategias_usadas, key=estrategias_usadas.get, reverse=True)[:3])\n\n        puntaje_prom = df.get(\"puntaje_entrada\", pd.Series()).mean()\n        capital_inicial = 0.0\n        capital_final = 0.0\n        if \"capital_inicial\" in df.columns:\n            capital_inicial = df.groupby(\"symbol\")[\"capital_inicial\"].first().sum()\n        if \"capital_final\" in df.columns:\n            capital_final = df.groupby(\"symbol\")[\"capital_final\"].last().sum()\n\n        resumen = {\n            \"fecha\": fecha,\n            \"operaciones\": total_ops,\n            \"ganadas\": ganadas,\n            \"perdidas\": perdidas,\n            \"beneficio_promedio\": round(beneficio_prom or 0, 6),\n            \"perdida_promedio\": round(perdida_prom or 0, 6),\n            \"mejor\": round(mejor or 0, 6),\n            \"peor\": round(peor or 0, 6),\n            \"estrategias_top\": mas_usadas,\n            \"puntaje_promedio\": round(puntaje_prom or 0, 4),\n            \"capital_inicial\": round(capital_inicial, 2),\n            \"capital_final\": round(capital_final, 2),\n        }\n\n        self.log.info(\n            f\"\ud83d\udcca Informe {fecha}: Ganancia={ganancia_total:.2f}, Winrate={winrate:.2f}%, Drawdown={drawdown:.4f}\"\n        )\n        resumen_path_txt = os.path.join(self.carpeta, f\"{fecha}_resumen.txt\")\n        resumen_path_csv = os.path.join(self.carpeta, f\"{fecha}_resumen.csv\")\n        with open(resumen_path_txt, \"w\") as f:\n            for k, v in resumen.items():\n                f.write(f\"{k}: {v}\\n\")\n        pd.DataFrame([resumen]).to_csv(resumen_path_csv, index=False)\n        self._guardar_pdf(df, fecha, ganancia_total, winrate, drawdown)\n\n    def _guardar_pdf(self, df, fecha, ganancia, winrate, drawdown):\n        pdf_path = os.path.join(self.carpeta, f\"{fecha}.pdf\")\n        with PdfPages(pdf_path) as pdf:\n            fig, ax = plt.subplots()\n            df[\"retorno_total\"].cumsum().plot(ax=ax)\n            ax.set_title(\"Retorno acumulado\")\n            ax.set_xlabel(\"Operaciones\")\n            ax.set_ylabel(\"Beneficio\")\n            pdf.savefig(fig)\n            plt.close(fig)\n\n            fig, ax = plt.subplots(figsize=(8, 2))\n            ax.axis(\"off\")\n            texto = f\"Ganancia total: {ganancia:.2f}\\n\" f\"Winrate: {winrate:.2f}%\\n\" f\"Drawdown: {drawdown:.4f}\"\n            ax.text(0.01, 0.8, texto, fontsize=12)\n            pdf.savefig(fig)\n            plt.close(fig)\n        self.log.info(f\"\ud83d\uddd2\ufe0f Reporte PDF guardado en {pdf_path}\")\n\n\nreporter_diario = ReporterDiario()", "import os\nimport json\nfrom datetime import datetime\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_pdf import PdfPages\nfrom pegaso.core.utils.utils import configurar_logger\nfrom pegaso.core.utils.utils import leer_csv_seguro\n\n\nclass ReporterDiario:\n    def __init__(self, carpeta=\"reportes_diarios\"):\n        self.carpeta = carpeta\n        os.makedirs(self.carpeta, exist_ok=True)\n        self.fecha_actual = datetime.utcnow().date()\n        self.log = configurar_logger(\"reporte\")\n        self.estadisticas_archivo = os.path.join(self.carpeta, \"estadisticas.csv\")\n        self._cargar_estadisticas()\n        self.ultimas_operaciones = {}\n\n    def _cargar_estadisticas(self):\n        columnas = [\n            \"symbol\",\n            \"operaciones\",\n            \"wins\",\n            \"retorno_acumulado\",\n            \"max_equity\",\n            \"drawdown\",\n            \"buy_hold_start\",\n            \"last_price\",\n        ]\n        if os.path.exists(self.estadisticas_archivo):\n            try:\n                self.estadisticas = leer_csv_seguro(\n                    self.estadisticas_archivo, expected_cols=len(columnas)\n                )\n            except Exception:\n                self.estadisticas = pd.DataFrame(columns=columnas)\n        else:\n            self.estadisticas = pd.DataFrame(columns=columnas)\n\n    def _guardar_estadisticas(self):\n        if self.estadisticas.empty:\n            return\n        df = self.estadisticas.copy()\n        df[\"winrate\"] = (df[\"wins\"] / df[\"operaciones\"]) * 100\n        df[\"buy_hold\"] = (df[\"last_price\"] - df[\"buy_hold_start\"]) / df[\"buy_hold_start\"]\n        df.to_csv(self.estadisticas_archivo, index=False)\n\n    def _actualizar_estadisticas(self, info: dict):\n        symbol = info.get(\"symbol\") or info.get(\"simbolo\")\n        if not symbol:\n            return\n        retorno = float(info.get(\"retorno_total\", 0.0))\n        entrada = float(info.get(\"precio_entrada\", 0.0))\n        cierre = float(info.get(\"precio_cierre\", entrada))\n\n        if symbol not in self.estadisticas[\"symbol\"].values:\n            nueva = {\n                \"symbol\": symbol,\n                \"operaciones\": 0,\n                \"wins\": 0,\n                \"retorno_acumulado\": 0.0,\n                \"max_equity\": 0.0,\n                \"drawdown\": 0.0,\n                \"buy_hold_start\": entrada if entrada else cierre,\n                \"last_price\": cierre,\n            }\n            frames = [df for df in [self.estadisticas, pd.DataFrame([nueva])] if not df.empty]\n            self.estadisticas = pd.concat(frames, ignore_index=True) if frames else pd.DataFrame([nueva])\n\n        if self.estadisticas.empty:\n            return\n        filas = self.estadisticas[self.estadisticas[\"symbol\"] == symbol]\n        if filas.empty:\n            return\n        idx = filas.index[0]\n        self.estadisticas.loc[idx, \"operaciones\"] += 1\n        self.estadisticas.loc[idx, \"retorno_acumulado\"] += retorno\n        if retorno > 0:\n            self.estadisticas.loc[idx, \"wins\"] += 1\n        acum = self.estadisticas.loc[idx, \"retorno_acumulado\"]\n        max_eq = self.estadisticas.loc[idx, \"max_equity\"]\n        max_eq = max(max_eq, acum)\n        self.estadisticas.loc[idx, \"max_equity\"] = max_eq\n        self.estadisticas.loc[idx, \"drawdown\"] = min(self.estadisticas.loc[idx, \"drawdown\"], acum - max_eq)\n        if self.estadisticas.loc[idx, \"buy_hold_start\"] == 0:\n            self.estadisticas.loc[idx, \"buy_hold_start\"] = entrada if entrada else cierre\n        self.estadisticas.loc[idx, \"last_price\"] = cierre\n        self._guardar_estadisticas()\n\n    def registrar_operacion(self, info: dict):\n        fecha = datetime.utcnow().date()\n        archivo = os.path.join(self.carpeta, f\"{fecha}.csv\")\n        df = pd.DataFrame([info])\n        if os.path.exists(archivo):\n            df.to_csv(archivo, mode=\"a\", header=False, index=False)\n        else:\n            df.to_csv(archivo, index=False)\n        symbol = info.get(\"symbol\") or info.get(\"simbolo\")\n        if symbol:\n            self.ultimas_operaciones.setdefault(symbol, [])\n            self.ultimas_operaciones[symbol].append(info)\n        self.log.info(f\"\ud83d\udcdd Operaci\u00f3n registrada para reporte {fecha}\")\n        self._actualizar_estadisticas(info)\n        if fecha != self.fecha_actual:\n            self.generar_informe(self.fecha_actual)\n            self.fecha_actual = fecha\n\n    def generar_informe(self, fecha):\n        archivo = os.path.join(self.carpeta, f\"{fecha}.csv\")\n        if not os.path.exists(archivo):\n            return\n        df = leer_csv_seguro(archivo, expected_cols=20)\n        if df.empty:\n            return\n        ganancia_total = df[\"retorno_total\"].sum()\n        winrate = (df[\"retorno_total\"] > 0).mean() * 100\n        curva = df[\"retorno_total\"].cumsum()\n        drawdown = (curva - curva.cummax()).min()\n\n        total_ops = len(df)\n        ganadas = (df[\"retorno_total\"] > 0).sum()\n        perdidas = total_ops - ganadas\n        beneficio_prom = df[df[\"retorno_total\"] > 0][\"retorno_total\"].mean()\n        perdida_prom = df[df[\"retorno_total\"] <= 0][\"retorno_total\"].mean()\n        mejor = df[\"retorno_total\"].max()\n        peor = df[\"retorno_total\"].min()\n        estrategias_usadas = {}\n        if \"estrategias\" in df.columns:\n            col = df[\"estrategias\"]\n        else:\n            col = df.get(\"estrategias_activas\")\n        if col is not None:\n            for val in col.dropna():\n                if isinstance(val, str):\n                    try:\n                        data = json.loads(val.replace(\"'\", '\"'))\n                        if isinstance(data, dict):\n                            val = list(data.keys())\n                    except Exception:\n                        val = [val]\n                if isinstance(val, dict):\n                    val = list(val.keys())\n                if isinstance(val, list):\n                    for e in val:\n                        estrategias_usadas[e] = estrategias_usadas.get(e, 0) + 1\n        mas_usadas = \",\".join(sorted(estrategias_usadas, key=estrategias_usadas.get, reverse=True)[:3])\n\n        puntaje_prom = df.get(\"puntaje_entrada\", pd.Series()).mean()\n        capital_inicial = 0.0\n        capital_final = 0.0\n        if \"capital_inicial\" in df.columns:\n            capital_inicial = df.groupby(\"symbol\")[\"capital_inicial\"].first().sum()\n        if \"capital_final\" in df.columns:\n            capital_final = df.groupby(\"symbol\")[\"capital_final\"].last().sum()\n\n        resumen = {\n            \"fecha\": fecha,\n            \"operaciones\": total_ops,\n            \"ganadas\": ganadas,\n            \"perdidas\": perdidas,\n            \"beneficio_promedio\": round(beneficio_prom or 0, 6),\n            \"perdida_promedio\": round(perdida_prom or 0, 6),\n            \"mejor\": round(mejor or 0, 6),\n            \"peor\": round(peor or 0, 6),\n            \"estrategias_top\": mas_usadas,\n            \"puntaje_promedio\": round(puntaje_prom or 0, 4),\n            \"capital_inicial\": round(capital_inicial, 2),\n            \"capital_final\": round(capital_final, 2),\n        }\n\n        self.log.info(\n            f\"\ud83d\udcca Informe {fecha}: Ganancia={ganancia_total:.2f}, Winrate={winrate:.2f}%, Drawdown={drawdown:.4f}\"\n        )\n        resumen_path_txt = os.path.join(self.carpeta, f\"{fecha}_resumen.txt\")\n        resumen_path_csv = os.path.join(self.carpeta, f\"{fecha}_resumen.csv\")\n        with open(resumen_path_txt, \"w\") as f:\n            for k, v in resumen.items():\n                f.write(f\"{k}: {v}\\n\")\n        pd.DataFrame([resumen]).to_csv(resumen_path_csv, index=False)\n        self._guardar_pdf(df, fecha, ganancia_total, winrate, drawdown)\n\n    def _guardar_pdf(self, df, fecha, ganancia, winrate, drawdown):\n        pdf_path = os.path.join(self.carpeta, f\"{fecha}.pdf\")\n        with PdfPages(pdf_path) as pdf:\n            fig, ax = plt.subplots()\n            df[\"retorno_total\"].cumsum().plot(ax=ax)\n            ax.set_title(\"Retorno acumulado\")\n            ax.set_xlabel(\"Operaciones\")\n            ax.set_ylabel(\"Beneficio\")\n            pdf.savefig(fig)\n            plt.close(fig)\n\n            fig, ax = plt.subplots(figsize=(8, 2))\n            ax.axis(\"off\")\n            texto = f\"Ganancia total: {ganancia:.2f}\\n\" f\"Winrate: {winrate:.2f}%\\n\" f\"Drawdown: {drawdown:.4f}\"\n            ax.text(0.01, 0.8, texto, fontsize=12)\n            pdf.savefig(fig)\n            plt.close(fig)\n        self.log.info(f\"\ud83d\uddd2\ufe0f Reporte PDF guardado en {pdf_path}\")\n\n\nreporter_diario = ReporterDiario()"]]], 1750727260.3854022]], ["ChangeSet", ["Writing file <core/trader_modular.py>", [["ChangeContents", ["core/trader_modular.py", "\"\"\"Controlador principal del bot modular.\"\"\"\n\nfrom __future__ import annotations\nimport asyncio\nfrom dataclasses import dataclass\nfrom typing import Dict, List\nfrom datetime import datetime, timedelta, date\nimport json\nimport os\nimport numpy as np\n\nimport pandas as pd\n\nfrom config.config_manager import Config\nfrom core.data import DataFeed\nfrom core.strategies import StrategyEngine\nfrom core.risk import RiskManager\nfrom core.position_manager import PositionManager\nfrom core.notification_manager import NotificationManager\nfrom core.capital_manager import CapitalManager\nfrom binance_api.cliente import (\n    crear_cliente,\n    fetch_balance_async,\n    fetch_ohlcv_async,\n)\nfrom core.adaptador_dinamico import (\n    calcular_umbral_adaptativo,\n    calcular_tp_sl_adaptativos\n)\nfrom core.utils.utils import distancia_minima_valida, leer_reporte_seguro\nfrom core.strategies import cargar_pesos_estrategias\nfrom core.risk import calcular_fraccion_kelly\nfrom core.data import PersistenciaTecnica, coincidencia_parcial, calcular_persistencia_minima\nfrom core.metricas_semanales import metricas_tracker, metricas_semanales\nfrom learning.entrenador_estrategias import actualizar_pesos_estrategias_symbol\nfrom core.utils.utils import configurar_logger\nfrom core.monitor_estado_bot import monitorear_estado_periodicamente\nfrom core.contexto_externo import StreamContexto\nfrom core.orders import ordenes_reales\nfrom core.adaptador_dinamico import adaptar_configuracion as adaptar_configuracion_base\nfrom core.adaptador_configuracion_dinamica import adaptar_configuracion\nfrom ccxt.base.errors import BaseError\nfrom core.reporting import reporter_diario\nfrom core.registro_metrico import registro_metrico\nfrom learning.aprendizaje_en_linea import registrar_resultado_trade\nfrom learning.aprendizaje_continuo import ejecutar_ciclo as ciclo_aprendizaje\nfrom strategies.exit.salida_trailing_stop import verificar_trailing_stop\nfrom strategies.exit.salida_por_tendencia import verificar_reversion_tendencia\nfrom strategies.exit.gestor_salidas import evaluar_salidas, verificar_filtro_tecnico\nfrom strategies.exit.salida_stoploss import verificar_salida_stoploss\nfrom core.strategies.exit.filtro_salidas import validar_necesidad_de_salida\nfrom core.strategies.tendencia import detectar_tendencia\nfrom strategies.exit.analisis_salidas import patron_tecnico_fuerte\nfrom core.strategies.entry.validador_entradas import evaluar_validez_estrategica\nfrom core.estrategias import filtrar_por_direccion\nfrom indicators.rsi import calcular_rsi\nfrom indicators.momentum import calcular_momentum\nfrom indicators.slope import calcular_slope\nfrom core.strategies.evaluador_tecnico import (\n    evaluar_puntaje_tecnico,\n    calcular_umbral_adaptativo as calc_umbral_tecnico,\n    cargar_pesos_tecnicos,\n    actualizar_pesos_tecnicos,\n)\nfrom strategies.exit.analisis_previo_salida import (\n    permitir_cierre_tecnico,\n    evaluar_condiciones_de_cierre_anticipado,\n)\nfrom core.auditoria import registrar_auditoria\nfrom indicators.atr import calcular_atr\nfrom core.strategies.exit.verificar_salidas import verificar_salidas\nfrom core.strategies.entry.verificar_entradas import verificar_entrada\nfrom core.procesar_vela import procesar_vela\n   \n\nlog = configurar_logger(\"trader\")\n\nPESOS_SCORE_TECNICO = {\n    \"RSI\": 1.0,\n    \"Momentum\": 0.5,\n    \"Slope\": 1.0,\n    \"Tendencia\": 1.0,\n}\n\n\n@dataclass\nclass EstadoSimbolo:\n    buffer: List[dict]\n    ultimo_umbral: float = 0.0\n    ultimo_timestamp: int | None = None\n    tendencia_detectada: str | None = None\n\n\nclass Trader:\n    \"\"\"Orquesta el flujo de datos y las operaciones de trading.\"\"\"\n\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        self.data_feed = DataFeed(config.intervalo_velas)\n        self.engine = StrategyEngine()\n        self.risk = RiskManager(config.umbral_riesgo_diario)\n        self.notificador = NotificationManager(config.telegram_token, config.telegram_chat_id)\n        self.modo_real = getattr(config, \"modo_real\", False)\n        self.orders = PositionManager(self.modo_real, self.risk, self.notificador)\n        self.cliente = crear_cliente(config) if self.modo_real else None\n        if not self.modo_real:\n            log.info(\"\ud83e\uddea Modo simulado activado. No se inicializar\u00e1 cliente Binance\")\n        self._markets = None\n        self.modo_capital_bajo = config.modo_capital_bajo\n        self.persistencia = PersistenciaTecnica(\n            config.persistencia_minima,\n            config.peso_extra_persistencia,\n        )\n        os.makedirs(\"logs/rechazos\", exist_ok=True)\n        os.makedirs(os.path.dirname(config.registro_tecnico_csv), exist_ok=True)\n        self.umbral_score_tecnico = config.umbral_score_tecnico\n        self.usar_score_tecnico = getattr(config, \"usar_score_tecnico\", True)\n        self.contradicciones_bloquean_entrada = config.contradicciones_bloquean_entrada\n        self.registro_tecnico_csv = config.registro_tecnico_csv\n        self.historicos: Dict[str, pd.DataFrame] = {}\n        self.fraccion_kelly = calcular_fraccion_kelly()\n        factor_kelly = self.risk.multiplicador_kelly()\n        self.fraccion_kelly *= factor_kelly\n        factor_vol = 1.0\n        try:\n            factores = []\n            for sym in config.symbols:\n                df = self._obtener_historico(sym)\n                if df is None or \"close\" not in df:\n                    continue\n                cambios = df[\"close\"].pct_change().dropna()\n                if cambios.empty:\n                    continue\n                volatilidad_actual = cambios.tail(1440).std()\n                volatilidad_media = cambios.std()\n                factores.append(\n                    self.risk.factor_volatilidad(\n                        float(volatilidad_actual),\n                        float(volatilidad_media),\n                    )\n                )\n            if factores:\n                factor_vol = min(factores)\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo calcular factor de volatilidad: {e}\")\n\n        self.fraccion_kelly *= factor_vol\n        log.info(\n            f\"\u2696\ufe0f Fracci\u00f3n Kelly: {self.fraccion_kelly:.4f}\"\n            f\" (x{factor_kelly:.3f}, x{factor_vol:.3f})\"\n        )\n        self.piramide_fracciones = max(1, config.fracciones_piramide)\n        self.reserva_piramide = max(0.0, min(1.0, config.reserva_piramide))\n        self.umbral_piramide = max(0.0, config.umbral_piramide)\n        self.riesgo_maximo_diario = 1.0\n        self.capital_manager = CapitalManager(\n            config,\n            self.cliente,\n            self.risk,\n            self.fraccion_kelly,\n        )\n        self.capital_por_simbolo = self.capital_manager.capital_por_simbolo\n        self.capital_inicial_diario = self.capital_manager.capital_inicial_diario\n        self.reservas_piramide = self.capital_manager.reservas_piramide\n        self.fecha_actual = self.capital_manager.fecha_actual\n        self.estado: Dict[str, EstadoSimbolo] = {\n            s: EstadoSimbolo([]) for s in config.symbols\n        }\n        self.estado_tendencia: Dict[str, str] = {}\n        self.config_por_simbolo: Dict[str, dict] = {s: {} for s in config.symbols}\n        try:\n            self.pesos_por_simbolo: Dict[str, Dict[str, float]] = (\n                cargar_pesos_estrategias()\n            )\n        except ValueError as e:\n            log.error(f\"\u274c {e}\")\n            raise\n        self.historial_cierres: Dict[str, dict] = {}\n        self._task: asyncio.Task | None = None\n        self._task_estado: asyncio.Task | None = None\n        self._task_contexto: asyncio.Task | None = None\n        self._task_aprendizaje: asyncio.Task | None = None\n        self.context_stream = StreamContexto()\n\n        try:\n            self.orders.ordenes = ordenes_reales.obtener_todas_las_ordenes()\n            if self.modo_real and not self.orders.ordenes:\n                self.orders.ordenes = ordenes_reales.sincronizar_ordenes_binance(\n                    config.symbols\n                )\n        except Exception as e:\n            log.warning(f\"\u26a0\ufe0f Error cargando \u00f3rdenes previas desde la base de datos: {e}\")\n            raise\n\n        if self.orders.ordenes:\n            log.warning(\n                \"\u26a0\ufe0f \u00d3rdenes abiertas encontradas al iniciar. Ser\u00e1n monitoreadas.\"\n            )\n\n        if \"PYTEST_CURRENT_TEST\" not in os.environ:\n            self._cargar_estado_persistente()\n        else:\n            log.debug(\"\ud83d\udd0d Modo prueba: se omite carga de estado persistente\")\n\n    async def cerrar_operacion(self, symbol: str, precio: float, motivo: str) -> None:\n        \"\"\"Cierra una orden y actualiza los pesos si corresponden.\"\"\"\n        if not await self.orders.cerrar_async(symbol, precio, motivo):\n            log.debug(f\"\ud83d\udd01 Intento duplicado de cierre ignorado para {symbol}\")\n            return\n        actualizar_pesos_estrategias_symbol(symbol)\n        try:\n            self.pesos_por_simbolo = cargar_pesos_estrategias()\n        except ValueError as e:\n            log.error(f\"\u274c {e}\")\n            return\n        log.info(f\"\u2705 Orden cerrada: {symbol} a {precio:.2f}\u20ac por '{motivo}'\")\n\n    async def _cerrar_y_reportar(\n        self,\n        orden,\n        precio: float,\n        motivo: str,\n        tendencia: str | None = None,\n        df: pd.DataFrame | None = None,\n    ) -> None:\n        \"\"\"Cierra ``orden`` y registra la operaci\u00f3n para el reporte diario.\"\"\"\n        retorno_total = (\n            (precio - orden.precio_entrada) / orden.precio_entrada\n            if orden.precio_entrada\n            else 0.0\n        )\n        info = orden.to_dict()\n        info.update(\n            {\n                \"precio_cierre\": precio,\n                \"fecha_cierre\": datetime.utcnow().isoformat(),\n                \"motivo_cierre\": motivo,\n                \"retorno_total\": retorno_total,\n                \"capital_inicial\": self.capital_por_simbolo.get(orden.symbol, 0.0),\n            }\n        )\n        if not await self.orders.cerrar_async(orden.symbol, precio, motivo):\n            log.warning(\n                f\"\u274c No se pudo confirmar el cierre de {orden.symbol}. Se omitir\u00e1 el registro.\"\n            )\n            return False\n        \n        capital_inicial = self.capital_por_simbolo.get(orden.symbol, 0.0)\n        ganancia = capital_inicial * retorno_total\n        capital_final = capital_inicial + ganancia\n        self.capital_por_simbolo[orden.symbol] = capital_final\n        info[\"capital_final\"] = capital_final\n        if getattr(orden, \"sl_evitar_info\", None):\n            os.makedirs(\"logs\", exist_ok=True)\n            for ev in orden.sl_evitar_info:\n                sl_val = ev.get(\"sl\", 0.0)\n                peor = (\n                    precio < sl_val\n                    if orden.direccion in (\"long\", \"compra\")\n                    else precio > sl_val\n                )\n                mensaje = (\n                    f\"\u2757 Evitar SL en {orden.symbol} result\u00f3 en p\u00e9rdida mayor\"\n                    f\" ({precio:.2f} vs {sl_val:.2f})\"\n                    if peor\n                    else f\"\ud83d\udc4d Evitar SL en {orden.symbol} fue beneficioso\"\n                    f\" ({precio:.2f} vs {sl_val:.2f})\"\n                )\n                with open(\"logs/impacto_sl.log\", \"a\") as f:\n                    f.write(mensaje + \"\\n\")\n                log.info(mensaje)\n            orden.sl_evitar_info = []\n        reporter_diario.registrar_operacion(info)\n        registrar_resultado_trade(orden.symbol, info, retorno_total)\n        try:\n            if orden.detalles_tecnicos:\n                actualizar_pesos_tecnicos(orden.symbol, orden.detalles_tecnicos, retorno_total)\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo actualizar pesos tecnicos: {e}\")\n        actualizar_pesos_estrategias_symbol(orden.symbol)\n        try:\n            self.pesos_por_simbolo = cargar_pesos_estrategias()\n        except ValueError as e:\n            log.error(f\"\u274c {e}\")\n            return False\n        \n        duracion = 0.0\n        try:\n            apertura = datetime.fromisoformat(orden.timestamp)\n            duracion = (datetime.utcnow() - apertura).total_seconds() / 60\n        except Exception:\n            pass\n        prev = self.historial_cierres.get(orden.symbol, {})\n        self.historial_cierres[orden.symbol] = {\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"motivo\": motivo.lower().strip(),\n            \"velas\": 0,\n            \"precio\": precio,\n            \"tendencia\": tendencia,\n            \"duracion\": duracion,\n            \"retorno_total\": retorno_total,\n        }\n        if retorno_total < 0:\n            fecha_hoy = datetime.utcnow().date().isoformat()\n            if prev.get(\"fecha_perdidas\") != fecha_hoy:\n                perdidas = 0\n            else:\n                perdidas = prev.get(\"perdidas_consecutivas\", 0)\n            perdidas += 1\n            self.historial_cierres[orden.symbol][\"perdidas_consecutivas\"] = perdidas\n            self.historial_cierres[orden.symbol][\"fecha_perdidas\"] = fecha_hoy\n        else:\n            self.historial_cierres[orden.symbol][\"perdidas_consecutivas\"] = 0\n        log.info(\n            f\"\u2705 CIERRE {motivo.upper()}: {orden.symbol} | Beneficio: {ganancia:.2f} \u20ac\"\n        )\n        registro_metrico.registrar(\n            \"cierre\",\n            {\n                \"symbol\": orden.symbol,\n                \"motivo\": motivo,\n                \"retorno\": retorno_total,\n                \"beneficio\": ganancia,\n            },\n        )\n        self._registrar_salida_profesional(\n            orden.symbol,\n            {\n                \"tipo_salida\": motivo,\n                \"estrategias_activas\": orden.estrategias_activas,\n                \"score_tecnico_al_cierre\": (\n                    self._calcular_score_tecnico(\n                        df,\n                        calcular_rsi(df),\n                        calcular_momentum(df),\n                        tendencia or \"\",\n                        orden.direccion,\n                    )[0]\n                    if df is not None\n                    else 0.0\n                ),\n                \"capital_final\": capital_final,\n                \"configuracion_usada\": self.config_por_simbolo.get(orden.symbol, {}),\n                \"tiempo_operacion\": duracion,\n                \"beneficio_relativo\": retorno_total,\n            },\n        )\n        metricas = self._metricas_recientes()\n        self.risk.ajustar_umbral(metricas)\n        try:\n            rsi_val = calcular_rsi(df) if df is not None else None\n            score, _ = (\n                self._calcular_score_tecnico(\n                    df,\n                    rsi_val,\n                    calcular_momentum(df),\n                    tendencia or \"\",\n                    orden.direccion,\n                )\n                if df is not None\n                else (None, None)\n            )\n            registrar_auditoria(\n                symbol=orden.symbol,\n                evento=motivo,\n                resultado=\"ganancia\" if retorno_total > 0 else \"p\u00e9rdida\",\n                estrategias_activas=orden.estrategias_activas,\n                score=score,\n                rsi=rsi_val,\n                tendencia=tendencia,\n                capital_actual=capital_final,\n                config_usada=self.config_por_simbolo.get(orden.symbol, {}),\n            )\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo registrar auditor\u00eda de cierre: {e}\")\n        return True\n    \n    def _registrar_salida_profesional(self, symbol: str, info: dict) -> None:\n        archivo = \"reportes_diarios/registro_salidas.parquet\"\n        os.makedirs(os.path.dirname(archivo), exist_ok=True)\n        data = info.copy()\n        data[\"symbol\"] = symbol\n        data[\"timestamp\"] = datetime.utcnow().isoformat()\n        if isinstance(data.get(\"estrategias_activas\"), dict):\n            data[\"estrategias_activas\"] = json.dumps(data[\"estrategias_activas\"])\n        try:\n            if os.path.exists(archivo):\n                df = pd.read_parquet(archivo)\n                df = pd.concat([df, pd.DataFrame([data])], ignore_index=True)\n            else:\n                df = pd.DataFrame([data])\n            df.to_parquet(archivo, index=False)\n        except Exception as e:\n            log.warning(f\"\u26a0\ufe0f Error registrando salida en {archivo}: {e}\")\n    \n    async def _cerrar_parcial_y_reportar(\n        self,\n        orden,\n        cantidad: float,\n        precio: float,\n        motivo: str,\n        df: pd.DataFrame | None = None,\n    ) -> bool:\n        \"\"\"Cierre parcial de ``orden`` y registro en el reporte.\"\"\"\n        if not await self.orders.cerrar_parcial_async(\n            orden.symbol, cantidad, precio, motivo\n        ):\n            log.warning(\n                f\"\u274c No se pudo confirmar el cierre parcial de {orden.symbol}. Se omitir\u00e1 el registro.\"\n            )\n            return False\n\n        retorno_unitario = (\n            (precio - orden.precio_entrada) / orden.precio_entrada\n            if orden.precio_entrada\n            else 0.0\n        )\n        fraccion = cantidad / orden.cantidad if orden.cantidad else 0.0\n        retorno_total = retorno_unitario * fraccion\n        info = orden.to_dict()\n        info.update(\n            {\n                \"precio_cierre\": precio,\n                \"fecha_cierre\": datetime.utcnow().isoformat(),\n                \"motivo_cierre\": motivo,\n                \"retorno_total\": retorno_total,\n                \"cantidad_cerrada\": cantidad,\n                \"capital_inicial\": self.capital_por_simbolo.get(orden.symbol, 0.0),\n            }\n        )\n        reporter_diario.registrar_operacion(info)\n        registrar_resultado_trade(orden.symbol, info, retorno_total)\n        capital_inicial = self.capital_por_simbolo.get(orden.symbol, 0.0)\n        ganancia = capital_inicial * retorno_total\n        capital_final = capital_inicial + ganancia\n        self.capital_por_simbolo[orden.symbol] = capital_final\n        info[\"capital_final\"] = capital_final\n        log.info(f\"\u2705 CIERRE PARCIAL: {orden.symbol} | Beneficio: {ganancia:.2f} \u20ac\")\n        registro_metrico.registrar(\n            \"cierre_parcial\",\n            {\n                \"symbol\": orden.symbol,\n                \"retorno\": retorno_total,\n                \"beneficio\": ganancia,\n            },\n        )\n        self._registrar_salida_profesional(\n            orden.symbol,\n            {\n                \"tipo_salida\": \"parcial\",\n                \"estrategias_activas\": orden.estrategias_activas,\n                \"score_tecnico_al_cierre\": (\n                    self._calcular_score_tecnico(\n                        df,\n                        calcular_rsi(df),\n                        calcular_momentum(df),\n                        orden.tendencia,\n                        orden.direccion,\n                    )[0]\n                    if df is not None\n                    else 0.0\n                ),\n                \"configuracion_usada\": self.config_por_simbolo.get(orden.symbol, {}),\n                \"tiempo_operacion\": 0.0,\n                \"beneficio_relativo\": retorno_total,\n            },\n        )\n        try:\n            rsi_val = calcular_rsi(df) if df is not None else None\n            score, _ = (\n                self._calcular_score_tecnico(\n                    df,\n                    rsi_val,\n                    calcular_momentum(df),\n                    orden.tendencia,\n                    orden.direccion,\n                )\n                if df is not None\n                else (None, None)\n            )\n            registrar_auditoria(\n                symbol=orden.symbol,\n                evento=motivo,\n                resultado=\"ganancia\" if retorno_total > 0 else \"p\u00e9rdida\",\n                estrategias_activas=orden.estrategias_activas,\n                score=score,\n                rsi=rsi_val,\n                tendencia=orden.tendencia,\n                capital_actual=capital_final,\n                config_usada=self.config_por_simbolo.get(orden.symbol, {}),\n            )\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo registrar auditor\u00eda de cierre parcial: {e}\")\n        return True\n    \n    def es_salida_parcial_valida(\n        self,\n        orden,\n        precio_tp: float,\n        config: dict,\n        df: pd.DataFrame,\n    ) -> bool:\n        \"\"\"Determina si aplicar TP parcial tiene sentido econ\u00f3mico.\"\"\"\n\n        if not config.get(\"usar_cierre_parcial\", False):\n            return False\n        try:\n            inversion = (orden.precio_entrada or 0.0) * (orden.cantidad or 0.0)\n            retorno_potencial = (precio_tp - (orden.precio_entrada or 0.0)) * (\n                orden.cantidad or 0.0\n            )\n        except Exception:\n            return False\n\n        if inversion <= config.get(\"umbral_operacion_grande\", 30.0):\n            return False\n        if retorno_potencial <= config.get(\"beneficio_minimo_parcial\", 5.0):\n            return False\n\n        pesos_symbol = self.pesos_por_simbolo.get(orden.symbol, {})\n        if not verificar_filtro_tecnico(\n            orden.symbol, df, orden.estrategias_activas, pesos_symbol, config=config\n        ):\n            return False\n\n        return True\n    \n    async def _piramidar(self, symbol: str, orden, df: pd.DataFrame) -> None:\n        \"\"\"A\u00f1ade posiciones si el precio avanza a favor.\"\"\"\n        if orden.fracciones_restantes <= 0:\n            return\n        precio_actual = float(df[\"close\"].iloc[-1])\n        if precio_actual >= orden.precio_ultima_piramide * (1 + self.umbral_piramide):\n            cantidad = orden.cantidad / orden.fracciones_totales\n            if await self.orders.agregar_parcial_async(symbol, precio_actual, cantidad):\n                orden.fracciones_restantes -= 1\n                orden.precio_ultima_piramide = precio_actual\n                log.info(f\"\ud83d\udd3c Pir\u00e1mide ejecutada en {symbol} @ {precio_actual:.2f}\")\n\n    @property\n    def ordenes_abiertas(self):\n        \"\"\"Compatibilidad con ``monitorear_estado_periodicamente``.\"\"\"\n        return self.orders.ordenes\n        \n    \n    def ajustar_capital_diario(\n        self,\n        factor: float = 0.2,\n        limite: float = 0.3,\n        penalizacion_corr: float = 0.2,\n        umbral_corr: float = 0.8,\n        fecha: datetime.date | None = None,\n    ) -> None:\n        \"\"\"Redistribuye el capital seg\u00fan m\u00faltiples m\u00e9tricas adaptativas.\"\"\"\n        total = sum(self.capital_por_simbolo.values())\n        # M\u00e9tricas generales de rendimiento (ganancia y drawdown recientes)\n        metricas_globales = self._metricas_recientes()\n        semanales = metricas_semanales()\n\n        pesos: dict[str, float] = {}\n\n        # Conteo de se\u00f1ales v\u00e1lidas en las \u00faltimas 60 min por s\u00edmbolo\n        senales = {s: self._contar_senales(s) for s in self.capital_por_simbolo}\n        \n        max_senales = max(senales.values()) if senales else 0\n        correlaciones = self._calcular_correlaciones()\n        stats = getattr(reporter_diario, \"estadisticas\", pd.DataFrame())\n        for symbol in self.capital_por_simbolo:\n            inicio = self.capital_inicial_diario.get(\n                symbol, self.capital_por_simbolo[symbol]\n            )\n            final = self.capital_por_simbolo[symbol]\n            rendimiento = (final - inicio) / inicio if inicio else 0.0\n            peso = 1 + factor * rendimiento\n            if max_senales > 0:\n                peso += 0.2 * senales[symbol] / max_senales\n            \n            # Penaliza s\u00edmbolos altamente correlacionados\n            corr_media = None\n            if not correlaciones.empty and symbol in correlaciones.columns:\n                corr_series = correlaciones[symbol].drop(labels=[symbol], errors=\"ignore\").abs()\n                corr_media = corr_series.mean()\n            if corr_media >= umbral_corr:\n                    peso *= 1 - penalizacion_corr * corr_media\n\n            # Extrae m\u00e9tricas previas del reporte para el s\u00edmbolo actual\n            fila = (\n                stats[stats[\"symbol\"] == symbol]\n                if (isinstance(stats, pd.DataFrame) and \"symbol\" in stats.columns)\n                else pd.DataFrame()\n            )\n            drawdown = 0.0\n            winrate = 0.0\n            ganancia = 0.0\n            if not fila.empty:\n                drawdown = float(fila[\"drawdown\"].iloc[0])\n                operaciones = float(fila[\"operaciones\"].iloc[0])\n                wins = float(fila[\"wins\"].iloc[0])\n                ganancia = float(fila[\"retorno_acumulado\"].iloc[0])\n                winrate = wins / operaciones if operaciones else 0.0\n            if not semanales.empty:\n                sem = semanales[semanales[\"symbol\"] == symbol]\n                if not sem.empty:\n                    weekly = float(sem[\"ganancia_promedio\"].iloc[0]) * float(sem[\"operaciones\"].iloc[0])\n                    if weekly < -0.05:\n                        peso *= 0.5\n\n            # 4\ufe0f\u20e3 Penalizaci\u00f3n por drawdown acumulado negativo\n            if drawdown < 0:\n                peso *= 1 + drawdown\n\n            # 5\ufe0f\u20e3 Refuerzo por buen desempe\u00f1o (winrate alto y ganancias)\n            if winrate > 0.6 and ganancia > 0:\n                refuerzo = min((winrate - 0.6) * ganancia, 0.3)\n                peso *= 1 + refuerzo\n\n            # Ajuste global seg\u00fan las m\u00e9tricas recientes de todo el bot\n            if metricas_globales:\n                ganancia_global = metricas_globales.get(\"ganancia_semana\", 0.0)\n                drawdown_global = metricas_globales.get(\"drawdown\", 0.0)\n                ajuste_global = 1 + ganancia_global + drawdown_global\n                peso *= max(0.5, min(1.5, ajuste_global))\n\n            # Mantiene el peso final dentro del rango establecido\n\n            peso = max(1 - limite, min(1 + limite, peso))\n            pesos[symbol] = peso\n\n        suma = sum(pesos.values()) or 1\n        for symbol in self.capital_por_simbolo:\n            self.capital_por_simbolo[symbol] = round(total * pesos[symbol] / suma, 2)\n        for symbol in self.capital_por_simbolo:\n            orden = self.orders.obtener(symbol)\n            reserva = 0.0\n            if orden and orden.cantidad_abierta > 0 and self.estado[symbol].buffer:\n                precio_actual = float(self.estado[symbol].buffer[-1].get(\"close\", 0))\n                if precio_actual > orden.precio_entrada:\n                    reserva = self.capital_por_simbolo[symbol] * self.reserva_piramide\n            self.capital_por_simbolo[symbol] -= reserva\n            self.reservas_piramide[symbol] = round(reserva, 2)\n\n        self.capital_inicial_diario = self.capital_por_simbolo.copy()\n        self.fecha_actual = fecha or datetime.utcnow().date()\n        log.info(f\"\ud83d\udcb0 Capital redistribuido: {self.capital_por_simbolo}\")\n\n\n    async def _precargar_historico(self, velas: int = 12) -> None:\n        \"\"\"Carga datos recientes para todos los s\u00edmbolos antes de iniciar.\"\"\"\n        if not self.modo_real or not self.cliente:\n            log.info(\"\ud83d\udcc8 Modo simulado: se omite precarga de hist\u00f3rico desde Binance\")\n            return\n        for symbol in self.estado.keys():\n            try:\n                datos = await fetch_ohlcv_async(\n                    self.cliente,\n                    symbol,\n                    self.config.intervalo_velas,\n                    limit=velas,\n                )\n            except BaseError as e:\n                log.warning(f\"\u26a0\ufe0f Error cargando hist\u00f3rico para {symbol}: {e}\")\n                continue\n            except Exception as e:\n                log.warning(f\"\u26a0\ufe0f Error inesperado cargando hist\u00f3rico para {symbol}: {e}\")\n                continue\n\n            for ts, open_, high_, low_, close_, vol in datos:\n                self.estado[symbol].buffer.append(\n                    {\n                        \"symbol\": symbol,\n                        \"timestamp\": ts,\n                        \"open\": float(open_),\n                        \"high\": float(high_),\n                        \"low\": float(low_),\n                        \"close\": float(close_),\n                        \"volume\": float(vol),\n                    }\n                )\n\n            if datos:\n                self.estado[symbol].ultimo_timestamp = datos[-1][0]\n        log.info(\"\ud83d\udcc8 Hist\u00f3rico inicial cargado\")\n\n    async def _ciclo_aprendizaje(self, intervalo: int = 86400) -> None:\n        \"\"\"Ejecuta el proceso de aprendizaje continuo peri\u00f3dicamente.\"\"\"\n        await asyncio.sleep(1)\n        while True:\n            try:\n                loop = asyncio.get_running_loop()\n                await loop.run_in_executor(None, ciclo_aprendizaje)\n                log.info(\"\ud83e\udde0 Ciclo de aprendizaje completado\")\n            except Exception as e:  # noqa: BLE001\n                log.warning(f\"\u26a0\ufe0f Error en ciclo de aprendizaje: {e}\")\n            await asyncio.sleep(intervalo)\n    \n    async def _calcular_cantidad_async(self, symbol: str, precio: float) -> float:\n        \"\"\"Delegado a :class:`CapitalManager`.\"\"\"\n        return await self.capital_manager.calcular_cantidad_async(symbol, precio)\n    \n    def _calcular_cantidad(self, symbol: str, precio: float) -> float:\n        \"\"\"Versi\u00f3n s\u00edncrona de :meth:`_calcular_cantidad_async`.\"\"\"\n        return self.capital_manager.calcular_cantidad(symbol, precio)\n\n    def _metricas_recientes(self, dias: int = 7) -> dict:\n        \"\"\"Calcula ganancia acumulada y drawdown de los \u00faltimos ``dias``.\"\"\"\n        carpeta = reporter_diario.carpeta\n        if not os.path.isdir(carpeta):\n            return {\n                \"ganancia_semana\": 0.0,\n                \"drawdown\": 0.0,\n                \"winrate\": 0.0,\n                \"capital_actual\": sum(self.capital_por_simbolo.values()),\n                \"capital_inicial\": sum(self.capital_inicial_diario.values()),\n            }\n\n        fecha_limite = datetime.utcnow().date() - timedelta(days=dias)\n        retornos: list[float] = []\n\n        archivos = sorted(\n            [f for f in os.listdir(carpeta) if f.endswith(\".csv\")], reverse=True\n        )[\n            :20\n        ]  # solo los 20 archivos m\u00e1s recientes\n\n        for archivo in archivos:\n            try:\n                fecha = datetime.fromisoformat(archivo.replace(\".csv\", \"\")).date()\n            except ValueError:\n                continue\n            if fecha < fecha_limite:\n                continue\n            ruta_archivo = os.path.join(carpeta, archivo)\n            df = leer_reporte_seguro(ruta_archivo, columnas_esperadas=20)\n            if df.empty:\n                continue\n            if \"retorno_total\" in df.columns:\n                retornos.extend(df[\"retorno_total\"].dropna().tolist())\n\n        if not retornos:\n            return {\n                \"ganancia_semana\": 0.0,\n                \"drawdown\": 0.0,\n                \"winrate\": 0.0,\n                \"capital_actual\": sum(self.capital_por_simbolo.values()),\n                \"capital_inicial\": sum(self.capital_inicial_diario.values()),\n            }\n\n        serie = pd.Series(retornos).cumsum()\n        drawdown = float((serie - serie.cummax()).min())\n        ganancia = float(serie.iloc[-1])\n        return {\"ganancia_semana\": ganancia, \"drawdown\": drawdown}\n    \n    def _contar_senales(self, symbol: str, minutos: int = 60) -> int:\n        \"\"\"Cuenta se\u00f1ales v\u00e1lidas recientes para ``symbol``.\"\"\"\n        estado = self.estado.get(symbol)\n        if not estado:\n            return 0\n        limite = datetime.utcnow().timestamp() * 1000 - minutos * 60 * 1000\n        return sum(\n            1\n            for v in estado.buffer\n            if pd.to_datetime(v.get(\"timestamp\")).timestamp() * 1000 >= limite\n            and v.get(\"estrategias_activas\")\n        )\n\n    def _obtener_historico(self, symbol: str) -> pd.DataFrame | None:\n        \"\"\"Devuelve el DataFrame de hist\u00f3rico para ``symbol`` usando cach\u00e9.\"\"\"\n        df = self.historicos.get(symbol)\n        if df is None:\n            archivo = f\"datos/{symbol.replace('/', '_').lower()}_1m.parquet\"\n            try:\n                df = pd.read_parquet(archivo)\n                self.historicos[symbol] = df\n            except Exception as e:\n                log.debug(f\"No se pudo cargar hist\u00f3rico para {symbol}: {e}\")\n                self.historicos[symbol] = None\n                return None\n        return df\n        \n    def _calcular_correlaciones(self, periodos: int = 1440) -> pd.DataFrame:\n        \"\"\"Calcula correlaci\u00f3n hist\u00f3rica de cierres entre s\u00edmbolos.\"\"\"\n        precios = {}\n        for symbol in self.capital_por_simbolo:\n            df = self._obtener_historico(symbol)\n            if df is not None and \"close\" in df:\n                precios[symbol] = (\n                    df[\"close\"].astype(float).tail(periodos).reset_index(drop=True)\n                )\n        if len(precios) < 2:\n            return pd.DataFrame()\n        df_precios = pd.DataFrame(precios)\n        return df_precios.corr()\n    \n    # Helpers de soporte -------------------------------------------------\n\n    def _rechazo(\n        self,\n        symbol: str,\n        motivo: str,\n        puntaje: float | None = None,\n        peso_total: float | None = None,\n        estrategias: list[str] | dict | None = None,\n    ) -> None:\n        \"\"\"Centraliza los mensajes de descartes de entrada.\"\"\"\n        mensaje = f\"\ud83d\udd34 RECHAZO: {symbol} | Causa: {motivo}\"\n        if puntaje is not None:\n            mensaje += f\" | Puntaje: {puntaje:.2f}\"\n        if peso_total is not None:\n            mensaje += f\" | Peso: {peso_total:.2f}\"\n        if estrategias:\n            estr = estrategias\n            if isinstance(estr, dict):\n                estr = list(estr.keys())\n            mensaje += f\" | Estrategias: {estr}\"\n        log.info(mensaje)\n\n        registro = {\n            \"symbol\": symbol,\n            \"motivo\": motivo,\n            \"puntaje\": puntaje,\n            \"peso_total\": peso_total,\n            \"estrategias\": \",\".join(estrategias.keys() if isinstance(estrategias, dict) else estrategias) if estrategias else \"\",\n        }\n        fecha = datetime.utcnow().strftime(\"%Y%m%d\")\n        archivo = os.path.join(\n            \"logs/rechazos\", f\"{symbol.replace('/', '_')}_{fecha}.csv\"\n        )\n        df = pd.DataFrame([registro])\n        modo = \"a\" if os.path.exists(archivo) else \"w\"\n        df.to_csv(archivo, mode=modo, header=not os.path.exists(archivo), index=False)\n        registro_metrico.registrar(\"rechazo\", registro)\n\n        try:\n            registrar_auditoria(\n                symbol=symbol,\n                evento=\"Entrada rechazada\",\n                resultado=\"rechazo\",\n                estrategias_activas=estrategias,\n                score=puntaje,\n                razon=motivo,\n                capital_actual=self.capital_por_simbolo.get(symbol, 0.0),\n                config_usada=self.config_por_simbolo.get(symbol, {}),\n            )\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo registrar auditor\u00eda de rechazo: {e}\")\n\n    def _validar_puntaje(self, symbol: str, puntaje: float, umbral: float) -> bool:\n        \"\"\"Comprueba si ``puntaje`` supera ``umbral``.\"\"\"\n        diferencia = umbral - puntaje\n        metricas_tracker.registrar_diferencia_umbral(diferencia)\n        if puntaje < umbral:\n            log.debug(f\"\ud83d\udeab {symbol}: puntaje {puntaje:.2f} < umbral {umbral:.2f}\")\n            metricas_tracker.registrar_filtro(\"umbral\")\n            return False\n        return True\n\n    async def _validar_diversidad(\n        self,\n        symbol: str,\n        peso_total: float,\n        peso_min_total: float,\n        estrategias_activas: Dict[str, float],\n        diversidad_min: int,\n        estrategias_disponibles: dict,\n        df: pd.DataFrame,\n    ) -> bool:\n        \"\"\"Verifica que la diversidad y el peso total sean suficientes.\"\"\"\n        diversidad = len(estrategias_activas)\n        \n        if self.modo_capital_bajo:\n            euros = 0\n            if self.modo_real and self.cliente:\n                try:\n                    balance = await fetch_balance_async(self.cliente)\n                    euros = balance[\"total\"].get(\"EUR\", 0)\n                except BaseError:\n                    euros = 0\n            if euros < 500:\n                diversidad_min = min(diversidad_min, 2)\n                peso_min_total *= 0.7\n        \n        if diversidad < diversidad_min or peso_total < peso_min_total:\n            self._rechazo(\n                symbol,\n                f\"Diversidad {diversidad} < {diversidad_min} o peso {peso_total:.2f} < {peso_min_total:.2f}\",\n                peso_total=peso_total,\n            )\n            metricas_tracker.registrar_filtro(\"diversidad\")\n            return False\n        return True\n\n    def _validar_estrategia(\n        self, symbol: str, df: pd.DataFrame, estrategias: Dict\n    ) -> bool:\n        \"\"\"Aplica el filtro estrat\u00e9gico de entradas.\"\"\"\n        if not evaluar_validez_estrategica(symbol, df, estrategias):\n            log.debug(f\"\u274c Entrada rechazada por filtro estrat\u00e9gico en {symbol}.\")\n            return False\n        return True\n\n    def _evaluar_persistencia(\n        self,\n        symbol: str,\n        estado: EstadoSimbolo,\n        df: pd.DataFrame,\n        pesos_symbol: Dict[str, float],\n        tendencia_actual: str,\n        puntaje: float,\n        umbral: float,\n        estrategias: Dict[str, bool],\n    ) -> tuple[bool, float, float]:\n        \"\"\"Eval\u00faa si las se\u00f1ales persistentes son suficientes para entrar.\"\"\"\n        ventana_close = df[\"close\"].tail(10)\n        media_close = np.mean(ventana_close)\n        if np.isnan(media_close) or media_close == 0:\n            log.debug(f\"\u26a0\ufe0f {symbol}: Media de cierre inv\u00e1lida para persistencia\")\n            return False\n\n        repetidas = coincidencia_parcial(estado.buffer, pesos_symbol, ventanas=5)\n        minimo = calcular_persistencia_minima(\n            symbol,\n            df,\n            tendencia_actual,\n            base_minimo=self.persistencia.minimo,\n        )\n\n        log.info(\n            f\"Persistencia detectada {repetidas:.2f} | M\u00ednimo requerido {minimo:.2f}\"\n        )\n\n        \n        if repetidas < minimo:\n            self._rechazo(\n                symbol,\n                f\"Persistencia {repetidas:.2f} < {minimo}\",\n                puntaje=puntaje,\n                estrategias=list(estrategias.keys()),\n            )\n            metricas_tracker.registrar_filtro(\"persistencia\")\n            return False, repetidas, minimo\n\n        if repetidas < 1 and puntaje < 1.2 * umbral:\n            self._rechazo(\n                symbol,\n                f\"{repetidas:.2f} coincidencia y puntaje d\u00e9bil ({puntaje:.2f})\",\n                puntaje=puntaje,\n                estrategias=list(estrategias.keys()),\n            )\n            return False, repetidas, minimo\n        elif repetidas < 1:\n            log.info(\n                f\"\u26a0\ufe0f Entrada d\u00e9bil en {symbol}: Coincidencia {repetidas:.2f} insuficiente pero puntaje alto ({puntaje}) > Umbral {umbral} \u2014 Permitida.\"\n            )\n            metricas_tracker.registrar_filtro(\"persistencia\")\n        return True, repetidas, minimo\n    \n    def _tendencia_persistente(\n        self, symbol: str, df: pd.DataFrame, tendencia: str, velas: int = 3\n    ) -> bool:\n        if len(df) < 30 + velas:\n            return False\n        for i in range(velas):\n            sub_df = df.iloc[: -(velas - 1 - i)] if velas - 1 - i > 0 else df\n            t, _ = detectar_tendencia(symbol, sub_df)\n            if t != tendencia:\n                return False\n        return True\n\n    def _validar_reentrada_tendencia(\n        self, symbol: str, df: pd.DataFrame, cierre: dict, precio: float\n    ) -> bool:\n        if cierre.get(\"motivo\") != \"cambio de tendencia\":\n            return True\n\n        tendencia = cierre.get(\"tendencia\")\n        if not tendencia:\n            return False\n\n        cierre_dt = pd.to_datetime(cierre.get(\"timestamp\"), errors=\"coerce\")\n        if pd.isna(cierre_dt):\n            log.warning(f\"\u26a0\ufe0f {symbol}: Timestamp de cierre inv\u00e1lido\")\n            return False\n        duracion = cierre.get(\"duracion\", 0)\n        retorno = abs(cierre.get(\"retorno_total\", 0))\n        velas_requeridas = 3 + min(int(duracion // 30), 3)\n        if retorno > 0.05:\n            velas_requeridas += 1\n        df_post = df[pd.to_datetime(df[\"timestamp\"]) > cierre_dt]\n        if len(df_post) < velas_requeridas:\n            log.info(\n                f\"\u23f3 {symbol}: esperando confirmaci\u00f3n de tendencia {len(df_post)}/{velas_requeridas}\"\n            )\n            return False\n        if not self._tendencia_persistente(\n            symbol, df_post, tendencia, velas=velas_requeridas\n        ):\n            log.info(f\"\u23f3 {symbol}: tendencia {tendencia} no persistente tras cierre\")\n            return False\n\n        precio_salida = cierre.get(\"precio\")\n        if precio_salida is not None and abs(precio - precio_salida) <= precio * 0.001:\n            log.info(f\"\ud83d\udeab {symbol}: precio de entrada similar al de salida anterior\")\n            return False\n\n        return True\n    \n    def _calcular_score_tecnico(\n        self,\n        df: pd.DataFrame,\n        rsi: float | None,\n        momentum: float | None,\n        tendencia: str,\n        direccion: str,\n    ) -> tuple[float, dict]:\n        \"\"\"Calcula un puntaje t\u00e9cnico simple a partir de varios indicadores.\"\"\"\n\n        slope = calcular_slope(df)\n\n        resultados = {\n            \"RSI\": False,\n            \"Momentum\": False,\n            \"Slope\": False,\n            \"Tendencia\": False,\n        }\n\n        if rsi is not None:\n            if direccion == \"long\":\n                resultados[\"RSI\"] = rsi > 50\n            else:\n                resultados[\"RSI\"] = rsi < 50\n\n        if momentum is not None:\n            resultados[\"Momentum\"] = abs(momentum) > 0.001\n\n        resultados[\"Slope\"] = slope > 0.01\n\n        if direccion == \"long\":\n            resultados[\"Tendencia\"] = tendencia in {\"alcista\", \"lateral\"}\n        else:\n            resultados[\"Tendencia\"] = tendencia in {\"bajista\", \"lateral\"}\n\n        score_total = sum(\n            PESOS_SCORE_TECNICO.get(k, 1.0) for k, v in resultados.items() if v\n        )\n\n        log.info(\n            \"\ud83d\udcca Score t\u00e9cnico: %.2f | RSI: %s (%.2f), Momentum: %s (%.4f), Slope: %s (%.4f), Tendencia: %s\",\n            score_total,\n            \"\u2705\" if resultados[\"RSI\"] else \"\u274c\",\n            rsi if rsi is not None else 0.0,\n            \"\u2705\" if resultados[\"Momentum\"] else \"\u274c\",\n            momentum if momentum is not None else 0.0,\n            \"\u2705\" if resultados[\"Slope\"] else \"\u274c\",\n            slope,\n            \"\u2705\" if resultados[\"Tendencia\"] else \"\u274c\",\n        )\n\n        return float(score_total), resultados\n\n    def _hay_contradicciones(\n        self,\n        df: pd.DataFrame,\n        rsi: float | None,\n        momentum: float | None,\n        direccion: str,\n        score: float,\n    ) -> bool:\n        \"\"\"Detecta si existen contradicciones fuertes en las se\u00f1ales.\"\"\"\n\n        if direccion == \"long\":\n            if rsi is not None and rsi > 70:\n                return True\n            if df[\"close\"].iloc[-1] >= df[\"close\"].iloc[-10] * 1.05:\n                return True\n            if (\n                momentum is not None\n                and momentum < 0\n                and score >= self.umbral_score_tecnico\n            ):\n                return True\n        else:\n            if rsi is not None and rsi < 30:\n                return True\n            if df[\"close\"].iloc[-1] <= df[\"close\"].iloc[-10] * 0.95:\n                return True\n            if (\n                momentum is not None\n                and momentum > 0\n                and score >= self.umbral_score_tecnico\n            ):\n                return True\n        return False\n\n    def _validar_temporalidad(self, df: pd.DataFrame, direccion: str) -> bool:\n        \"\"\"Verifica que las se\u00f1ales no est\u00e9n perdiendo fuerza.\"\"\"\n\n        rsi_series = calcular_rsi(df, serie_completa=True)\n        if rsi_series is None or len(rsi_series) < 3:\n            return True\n        r = rsi_series.iloc[-3:]\n        if direccion == \"long\" and not (r.iloc[-1] > r.iloc[-2] > r.iloc[-3]):\n            return False\n        if direccion == \"short\" and not (r.iloc[-1] < r.iloc[-2] < r.iloc[-3]):\n            return False\n\n        slope3 = calcular_slope(df, periodo=3)\n        slope5 = calcular_slope(df, periodo=5)\n        if direccion == \"long\" and not (slope3 > slope5):\n            return False\n        if direccion == \"short\" and not (slope3 < slope5):\n            return False\n        return True\n\n    def _registrar_rechazo_tecnico(\n        self,\n        symbol: str,\n        score: float,\n        puntos: dict,\n        tendencia: str,\n        precio: float,\n        motivo: str,\n        estrategias: dict | None = None,\n    ) -> None:\n        \"\"\"Guarda detalles de rechazos t\u00e9cnicos en un CSV.\"\"\"\n\n        if not self.registro_tecnico_csv:\n            return\n        fila = {\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"symbol\": symbol,\n            \"puntaje_total\": score,\n            \"indicadores_fallidos\": \",\".join([k for k, v in puntos.items() if not v]),\n            \"estado_mercado\": tendencia,\n            \"precio\": precio,\n            \"motivo\": motivo,\n            \"estrategias\": \",\".join(estrategias.keys()) if estrategias else \"\",\n        }\n        df = pd.DataFrame([fila])\n        modo = \"a\" if os.path.exists(self.registro_tecnico_csv) else \"w\"\n        df.to_csv(\n            self.registro_tecnico_csv,\n            mode=modo,\n            header=not os.path.exists(self.registro_tecnico_csv),\n            index=False,\n        )\n\n    async def evaluar_condiciones_entrada(\n        self, symbol: str, df: pd.DataFrame\n    ) -> None:\n        \"\"\"Eval\u00faa y ejecuta una entrada si todas las condiciones se cumplen.\"\"\"\n\n        estado = self.estado[symbol]\n        config_actual = self.config_por_simbolo.get(symbol, {})\n        dinamica = adaptar_configuracion(symbol, df)\n        if dinamica:\n            config_actual.update(dinamica)\n        config_actual = adaptar_configuracion_base(symbol, df, config_actual)\n        self.config_por_simbolo[symbol] = config_actual\n\n        tendencia_actual = self.estado_tendencia.get(symbol)\n        if not tendencia_actual:\n            tendencia_actual, _ = detectar_tendencia(symbol, df)\n            self.estado_tendencia[symbol] = tendencia_actual\n\n        resultado = self.engine.evaluar_entrada(\n            symbol,\n            df,\n            tendencia=tendencia_actual,\n            config=config_actual,\n            pesos_symbol=self.pesos_por_simbolo.get(symbol, {}),\n        )\n        estrategias = resultado.get(\"estrategias_activas\", {})\n        estado.buffer[-1][\"estrategias_activas\"] = estrategias\n        self.persistencia.actualizar(symbol, estrategias)\n\n        precio_actual = float(df[\"close\"].iloc[-1])\n\n        if not resultado.get(\"permitido\"):\n            if self.usar_score_tecnico:\n                rsi = resultado.get(\"rsi\")\n                mom = resultado.get(\"momentum\")\n                score, puntos = self._calcular_score_tecnico(\n                    df, rsi, mom, tendencia_actual,\n                    \"short\" if tendencia_actual == \"bajista\" else \"long\",\n                )\n                self._registrar_rechazo_tecnico(\n                    symbol,\n                    score,\n                    puntos,\n                    tendencia_actual,\n                    precio_actual,\n                    resultado.get(\"motivo_rechazo\", \"desconocido\"),\n                    estrategias,\n                )\n            self._rechazo(\n                symbol,\n                resultado.get(\"motivo_rechazo\", \"desconocido\"),\n                puntaje=resultado.get(\"score_total\"),\n                estrategias=list(estrategias.keys()),\n            )\n            return\n\n        info = await self.evaluar_condiciones_de_entrada(symbol, df, estado)\n        if not info:\n            self._rechazo(\n                symbol,\n                \"filtros_post_engine\",\n                puntaje=resultado.get(\"score_total\"),\n                estrategias=list(estrategias.keys()),\n            )\n            return\n\n        await self._abrir_operacion_real(**info)\n\n    async def _abrir_operacion_real(\n        self,\n        symbol: str,\n        precio: float,\n        sl: float,\n        tp: float,\n        estrategias: Dict | List,\n        tendencia: str,\n        direccion: str,\n        puntaje: float = 0.0,\n        umbral: float = 0.0,\n        detalles_tecnicos: dict | None = None,\n        **kwargs,  # <- acepta par\u00e1metros adicionales sin fallar\n    ) -> None:\n        cantidad_total = await self.capital_manager.calcular_cantidad_async(symbol, precio)\n        if cantidad_total <= 0:\n            return\n        fracciones = self.piramide_fracciones\n        cantidad = cantidad_total / fracciones\n        if isinstance(estrategias, dict):\n            estrategias_dict = estrategias\n        else:\n            pesos_symbol = self.pesos_por_simbolo.get(symbol, {})\n            estrategias_dict = {e: pesos_symbol.get(e, 0.0) for e in estrategias}\n        await self.orders.abrir_async(\n            symbol,\n            precio,\n            sl,\n            tp,\n            estrategias_dict,\n            tendencia,\n            direccion,\n            cantidad,\n            puntaje,\n            umbral,\n            objetivo=cantidad_total,\n            fracciones=fracciones,\n            detalles_tecnicos=detalles_tecnicos or {}\n        )\n        estrategias_list = list(estrategias_dict.keys())\n        log.info(\n            f\"\ud83d\udfe2 ENTRADA: {symbol} | Puntaje: {puntaje:.2f} / Umbral: {umbral:.2f} | Estrategias: {estrategias_list}\"\n        )\n        registro_metrico.registrar(\n            \"entrada\",\n            {\n                \"symbol\": symbol,\n                \"puntaje\": puntaje,\n                \"umbral\": umbral,\n                \"estrategias\": \",\".join(estrategias_list),\n                \"precio\": precio,\n            },\n        )\n        try:\n            registrar_auditoria(\n                symbol=symbol,\n                evento=\"Entrada\",\n                resultado=\"ejecutada\",\n                estrategias_activas=estrategias_dict,\n                score=puntaje,\n                tendencia=tendencia,\n                capital_actual=self.capital_por_simbolo.get(symbol, 0.0),\n                config_usada=self.config_por_simbolo.get(symbol, {}),\n            )\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo registrar auditor\u00eda de entrada: {e}\")\n\n    async def _verificar_salidas(self, symbol: str, df: pd.DataFrame) -> None:\n        await verificar_salidas(self, symbol, df)\n\n    async def evaluar_condiciones_de_entrada(\n        self, symbol: str, df: pd.DataFrame, estado: EstadoSimbolo\n        ) -> dict | None:\n            if not self._validar_config(symbol):\n                return None\n            return await verificar_entrada(self, symbol, df, estado)\n\n\n\n    async def ejecutar(self) -> None:\n        \"\"\"Inicia el procesamiento de todos los s\u00edmbolos.\"\"\"\n        async def handle(candle: dict) -> None:\n            await self._procesar_vela(candle)\n\n        async def handle_context(symbol: str, score: float) -> None:\n            log.debug(f\"\ud83d\udd01 Contexto actualizado {symbol}: {score:.2f}\")\n\n        symbols = list(self.estado.keys())\n        await self._precargar_historico(velas=60)\n\n        def _log_fallo_task(task: asyncio.Task):\n            if task.cancelled():\n                log.warning(\"\u26a0\ufe0f Una tarea fue cancelada.\")\n            elif task.exception():\n                log.error(f\"\u274c Error en tarea asincr\u00f3nica: {task.exception()}\")\n\n        self._task = asyncio.create_task(self.data_feed.escuchar(symbols, handle))\n        self._task.add_done_callback(_log_fallo_task)\n\n        self._task_estado = asyncio.create_task(monitorear_estado_periodicamente(self))\n        self._task_estado.add_done_callback(_log_fallo_task)\n\n        self._task_contexto = asyncio.create_task(self.context_stream.escuchar(symbols, handle_context))\n        self._task_contexto.add_done_callback(_log_fallo_task)\n        self._task_flush = asyncio.create_task(ordenes_reales.flush_periodico())\n        self._task_flush.add_done_callback(_log_fallo_task)\n        if \"PYTEST_CURRENT_TEST\" not in os.environ:\n            self._task_aprendizaje = asyncio.create_task(self._ciclo_aprendizaje())\n            self._task_aprendizaje.add_done_callback(_log_fallo_task)\n\n        try:\n            tareas = [self._task, self._task_estado, self._task_contexto, self._task_flush]\n            if self._task_aprendizaje:\n                tareas.append(self._task_aprendizaje)\n            await asyncio.gather(*tareas)\n        except Exception as e:\n            log.error(f\"\u274c Error inesperado en ejecuci\u00f3n de tareas: {e}\")\n            \n        tareas = [self._task, self._task_estado, self._task_contexto, self._task_flush]\n        if self._task_aprendizaje:\n            tareas.append(self._task_aprendizaje)\n        await asyncio.gather(*tareas)\n\n    async def _procesar_vela(self, vela: dict) -> None:\n        symbol = vela.get(\"symbol\")\n        if not self._validar_config(symbol):\n            return\n        \n        await procesar_vela(self, vela)\n        return\n\n    async def cerrar(self) -> None:\n        if self._task:\n            await self.data_feed.detener()\n            self._task.cancel()\n            try:\n                await self._task\n            except asyncio.CancelledError:\n                pass\n        if self._task_estado:\n            self._task_estado.cancel()\n            try:\n                await self._task_estado\n            except asyncio.CancelledError:\n                pass\n\n        if self._task_contexto:\n            await self.context_stream.detener()\n            self._task_contexto.cancel()\n            try:\n                await self._task_contexto\n            except asyncio.CancelledError:\n                pass\n            \n        if self._task_aprendizaje:\n            self._task_aprendizaje.cancel()\n            try:\n                await self._task_aprendizaje\n            except asyncio.CancelledError:\n                pass\n\n        self._guardar_estado_persistente()\n\n\n    def _guardar_estado_persistente(self) -> None:\n        \"\"\"Guarda historial de cierres y capital en ``estado/``.\"\"\"\n        try:\n            os.makedirs(\"estado\", exist_ok=True)\n            with open(\"estado/historial_cierres.json\", \"w\") as f:\n                json.dump(self.historial_cierres, f, indent=2)\n            with open(\"estado/capital.json\", \"w\") as f:\n                json.dump(self.capital_por_simbolo, f, indent=2)\n        except Exception as e:  # noqa: BLE001\n            log.warning(f\"\u26a0\ufe0f Error guardando estado persistente: {e}\")\n\n\n    def _cargar_estado_persistente(self) -> None:\n        \"\"\"Carga el estado previo de ``estado/`` si existe.\"\"\"\n        try:\n            if os.path.exists(\"estado/historial_cierres.json\"):\n                with open(\"estado/historial_cierres.json\") as f:\n                    contenido = f.read()\n                if contenido.strip():\n                    try:\n                        data = json.loads(contenido)\n                    except json.JSONDecodeError as e:\n                        log.warning(f\"\u26a0\ufe0f Error leyendo historial_cierres.json: {e}\")\n                        data = {}\n                    if isinstance(data, dict):\n                        self.historial_cierres.update(data)\n            if os.path.exists(\"estado/capital.json\"):\n                with open(\"estado/capital.json\") as f:\n                    contenido = f.read()\n                if contenido.strip():\n                    try:\n                        data = json.loads(contenido)\n                    except json.JSONDecodeError as e:\n                        log.warning(f\"\u26a0\ufe0f Error leyendo capital.json: {e}\")\n                        data = {}\n                    if isinstance(data, dict):\n                        self.capital_por_simbolo.update({k: float(v) for k, v in data.items()})\n        except Exception as e:  # noqa: BLE001\n            log.warning(f\"\u26a0\ufe0f Error cargando estado persistente: {e}\")\n\n    def _validar_config(self, symbol: str) -> bool:\n        \"\"\"Valida que exista configuraci\u00f3n para ``symbol``.\"\"\"\n        cfg = self.config_por_simbolo.get(symbol)\n        if not isinstance(cfg, dict):\n            log.error(f\"\u26a0\ufe0f Configuraci\u00f3n no encontrada para {symbol}\")\n            return False\n        return True\n", "\"\"\"Controlador principal del bot modular.\"\"\"\n\nfrom __future__ import annotations\nimport asyncio\nfrom dataclasses import dataclass\nfrom typing import Dict, List\nfrom datetime import datetime, timedelta, date\nimport json\nimport os\nimport numpy as np\n\nimport pandas as pd\n\nfrom pegaso.config.config_manager import Config\nfrom core.data import DataFeed\nfrom core.strategies import StrategyEngine\nfrom core.risk import RiskManager\nfrom core.position_manager import PositionManager\nfrom core.notification_manager import NotificationManager\nfrom core.capital_manager import CapitalManager\nfrom binance_api.cliente import (\n    crear_cliente,\n    fetch_balance_async,\n    fetch_ohlcv_async,\n)\nfrom core.adaptador_dinamico import (\n    calcular_umbral_adaptativo,\n    calcular_tp_sl_adaptativos\n)\nfrom core.utils.utils import distancia_minima_valida, leer_reporte_seguro\nfrom core.strategies import cargar_pesos_estrategias\nfrom core.risk import calcular_fraccion_kelly\nfrom core.data import PersistenciaTecnica, coincidencia_parcial, calcular_persistencia_minima\nfrom core.metricas_semanales import metricas_tracker, metricas_semanales\nfrom learning.entrenador_estrategias import actualizar_pesos_estrategias_symbol\nfrom core.utils.utils import configurar_logger\nfrom core.monitor_estado_bot import monitorear_estado_periodicamente\nfrom core.contexto_externo import StreamContexto\nfrom core.orders import ordenes_reales\nfrom core.adaptador_dinamico import adaptar_configuracion as adaptar_configuracion_base\nfrom core.adaptador_configuracion_dinamica import adaptar_configuracion\nfrom ccxt.base.errors import BaseError\nfrom core.reporting import reporter_diario\nfrom core.registro_metrico import registro_metrico\nfrom learning.aprendizaje_en_linea import registrar_resultado_trade\nfrom learning.aprendizaje_continuo import ejecutar_ciclo as ciclo_aprendizaje\nfrom strategies.exit.salida_trailing_stop import verificar_trailing_stop\nfrom strategies.exit.salida_por_tendencia import verificar_reversion_tendencia\nfrom strategies.exit.gestor_salidas import evaluar_salidas, verificar_filtro_tecnico\nfrom strategies.exit.salida_stoploss import verificar_salida_stoploss\nfrom core.strategies.exit.filtro_salidas import validar_necesidad_de_salida\nfrom core.strategies.tendencia import detectar_tendencia\nfrom strategies.exit.analisis_salidas import patron_tecnico_fuerte\nfrom core.strategies.entry.validador_entradas import evaluar_validez_estrategica\nfrom core.estrategias import filtrar_por_direccion\nfrom indicators.rsi import calcular_rsi\nfrom indicators.momentum import calcular_momentum\nfrom indicators.slope import calcular_slope\nfrom core.strategies.evaluador_tecnico import (\n    evaluar_puntaje_tecnico,\n    calcular_umbral_adaptativo as calc_umbral_tecnico,\n    cargar_pesos_tecnicos,\n    actualizar_pesos_tecnicos,\n)\nfrom strategies.exit.analisis_previo_salida import (\n    permitir_cierre_tecnico,\n    evaluar_condiciones_de_cierre_anticipado,\n)\nfrom core.auditoria import registrar_auditoria\nfrom indicators.atr import calcular_atr\nfrom core.strategies.exit.verificar_salidas import verificar_salidas\nfrom core.strategies.entry.verificar_entradas import verificar_entrada\nfrom core.procesar_vela import procesar_vela\n   \n\nlog = configurar_logger(\"trader\")\n\nPESOS_SCORE_TECNICO = {\n    \"RSI\": 1.0,\n    \"Momentum\": 0.5,\n    \"Slope\": 1.0,\n    \"Tendencia\": 1.0,\n}\n\n\n@dataclass\nclass EstadoSimbolo:\n    buffer: List[dict]\n    ultimo_umbral: float = 0.0\n    ultimo_timestamp: int | None = None\n    tendencia_detectada: str | None = None\n\n\nclass Trader:\n    \"\"\"Orquesta el flujo de datos y las operaciones de trading.\"\"\"\n\n    def __init__(self, config: Config) -> None:\n        self.config = config\n        self.data_feed = DataFeed(config.intervalo_velas)\n        self.engine = StrategyEngine()\n        self.risk = RiskManager(config.umbral_riesgo_diario)\n        self.notificador = NotificationManager(config.telegram_token, config.telegram_chat_id)\n        self.modo_real = getattr(config, \"modo_real\", False)\n        self.orders = PositionManager(self.modo_real, self.risk, self.notificador)\n        self.cliente = crear_cliente(config) if self.modo_real else None\n        if not self.modo_real:\n            log.info(\"\ud83e\uddea Modo simulado activado. No se inicializar\u00e1 cliente Binance\")\n        self._markets = None\n        self.modo_capital_bajo = config.modo_capital_bajo\n        self.persistencia = PersistenciaTecnica(\n            config.persistencia_minima,\n            config.peso_extra_persistencia,\n        )\n        os.makedirs(\"logs/rechazos\", exist_ok=True)\n        os.makedirs(os.path.dirname(config.registro_tecnico_csv), exist_ok=True)\n        self.umbral_score_tecnico = config.umbral_score_tecnico\n        self.usar_score_tecnico = getattr(config, \"usar_score_tecnico\", True)\n        self.contradicciones_bloquean_entrada = config.contradicciones_bloquean_entrada\n        self.registro_tecnico_csv = config.registro_tecnico_csv\n        self.historicos: Dict[str, pd.DataFrame] = {}\n        self.fraccion_kelly = calcular_fraccion_kelly()\n        factor_kelly = self.risk.multiplicador_kelly()\n        self.fraccion_kelly *= factor_kelly\n        factor_vol = 1.0\n        try:\n            factores = []\n            for sym in config.symbols:\n                df = self._obtener_historico(sym)\n                if df is None or \"close\" not in df:\n                    continue\n                cambios = df[\"close\"].pct_change().dropna()\n                if cambios.empty:\n                    continue\n                volatilidad_actual = cambios.tail(1440).std()\n                volatilidad_media = cambios.std()\n                factores.append(\n                    self.risk.factor_volatilidad(\n                        float(volatilidad_actual),\n                        float(volatilidad_media),\n                    )\n                )\n            if factores:\n                factor_vol = min(factores)\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo calcular factor de volatilidad: {e}\")\n\n        self.fraccion_kelly *= factor_vol\n        log.info(\n            f\"\u2696\ufe0f Fracci\u00f3n Kelly: {self.fraccion_kelly:.4f}\"\n            f\" (x{factor_kelly:.3f}, x{factor_vol:.3f})\"\n        )\n        self.piramide_fracciones = max(1, config.fracciones_piramide)\n        self.reserva_piramide = max(0.0, min(1.0, config.reserva_piramide))\n        self.umbral_piramide = max(0.0, config.umbral_piramide)\n        self.riesgo_maximo_diario = 1.0\n        self.capital_manager = CapitalManager(\n            config,\n            self.cliente,\n            self.risk,\n            self.fraccion_kelly,\n        )\n        self.capital_por_simbolo = self.capital_manager.capital_por_simbolo\n        self.capital_inicial_diario = self.capital_manager.capital_inicial_diario\n        self.reservas_piramide = self.capital_manager.reservas_piramide\n        self.fecha_actual = self.capital_manager.fecha_actual\n        self.estado: Dict[str, EstadoSimbolo] = {\n            s: EstadoSimbolo([]) for s in config.symbols\n        }\n        self.estado_tendencia: Dict[str, str] = {}\n        self.config_por_simbolo: Dict[str, dict] = {s: {} for s in config.symbols}\n        try:\n            self.pesos_por_simbolo: Dict[str, Dict[str, float]] = (\n                cargar_pesos_estrategias()\n            )\n        except ValueError as e:\n            log.error(f\"\u274c {e}\")\n            raise\n        self.historial_cierres: Dict[str, dict] = {}\n        self._task: asyncio.Task | None = None\n        self._task_estado: asyncio.Task | None = None\n        self._task_contexto: asyncio.Task | None = None\n        self._task_aprendizaje: asyncio.Task | None = None\n        self.context_stream = StreamContexto()\n\n        try:\n            self.orders.ordenes = ordenes_reales.obtener_todas_las_ordenes()\n            if self.modo_real and not self.orders.ordenes:\n                self.orders.ordenes = ordenes_reales.sincronizar_ordenes_binance(\n                    config.symbols\n                )\n        except Exception as e:\n            log.warning(f\"\u26a0\ufe0f Error cargando \u00f3rdenes previas desde la base de datos: {e}\")\n            raise\n\n        if self.orders.ordenes:\n            log.warning(\n                \"\u26a0\ufe0f \u00d3rdenes abiertas encontradas al iniciar. Ser\u00e1n monitoreadas.\"\n            )\n\n        if \"PYTEST_CURRENT_TEST\" not in os.environ:\n            self._cargar_estado_persistente()\n        else:\n            log.debug(\"\ud83d\udd0d Modo prueba: se omite carga de estado persistente\")\n\n    async def cerrar_operacion(self, symbol: str, precio: float, motivo: str) -> None:\n        \"\"\"Cierra una orden y actualiza los pesos si corresponden.\"\"\"\n        if not await self.orders.cerrar_async(symbol, precio, motivo):\n            log.debug(f\"\ud83d\udd01 Intento duplicado de cierre ignorado para {symbol}\")\n            return\n        actualizar_pesos_estrategias_symbol(symbol)\n        try:\n            self.pesos_por_simbolo = cargar_pesos_estrategias()\n        except ValueError as e:\n            log.error(f\"\u274c {e}\")\n            return\n        log.info(f\"\u2705 Orden cerrada: {symbol} a {precio:.2f}\u20ac por '{motivo}'\")\n\n    async def _cerrar_y_reportar(\n        self,\n        orden,\n        precio: float,\n        motivo: str,\n        tendencia: str | None = None,\n        df: pd.DataFrame | None = None,\n    ) -> None:\n        \"\"\"Cierra ``orden`` y registra la operaci\u00f3n para el reporte diario.\"\"\"\n        retorno_total = (\n            (precio - orden.precio_entrada) / orden.precio_entrada\n            if orden.precio_entrada\n            else 0.0\n        )\n        info = orden.to_dict()\n        info.update(\n            {\n                \"precio_cierre\": precio,\n                \"fecha_cierre\": datetime.utcnow().isoformat(),\n                \"motivo_cierre\": motivo,\n                \"retorno_total\": retorno_total,\n                \"capital_inicial\": self.capital_por_simbolo.get(orden.symbol, 0.0),\n            }\n        )\n        if not await self.orders.cerrar_async(orden.symbol, precio, motivo):\n            log.warning(\n                f\"\u274c No se pudo confirmar el cierre de {orden.symbol}. Se omitir\u00e1 el registro.\"\n            )\n            return False\n        \n        capital_inicial = self.capital_por_simbolo.get(orden.symbol, 0.0)\n        ganancia = capital_inicial * retorno_total\n        capital_final = capital_inicial + ganancia\n        self.capital_por_simbolo[orden.symbol] = capital_final\n        info[\"capital_final\"] = capital_final\n        if getattr(orden, \"sl_evitar_info\", None):\n            os.makedirs(\"logs\", exist_ok=True)\n            for ev in orden.sl_evitar_info:\n                sl_val = ev.get(\"sl\", 0.0)\n                peor = (\n                    precio < sl_val\n                    if orden.direccion in (\"long\", \"compra\")\n                    else precio > sl_val\n                )\n                mensaje = (\n                    f\"\u2757 Evitar SL en {orden.symbol} result\u00f3 en p\u00e9rdida mayor\"\n                    f\" ({precio:.2f} vs {sl_val:.2f})\"\n                    if peor\n                    else f\"\ud83d\udc4d Evitar SL en {orden.symbol} fue beneficioso\"\n                    f\" ({precio:.2f} vs {sl_val:.2f})\"\n                )\n                with open(\"logs/impacto_sl.log\", \"a\") as f:\n                    f.write(mensaje + \"\\n\")\n                log.info(mensaje)\n            orden.sl_evitar_info = []\n        reporter_diario.registrar_operacion(info)\n        registrar_resultado_trade(orden.symbol, info, retorno_total)\n        try:\n            if orden.detalles_tecnicos:\n                actualizar_pesos_tecnicos(orden.symbol, orden.detalles_tecnicos, retorno_total)\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo actualizar pesos tecnicos: {e}\")\n        actualizar_pesos_estrategias_symbol(orden.symbol)\n        try:\n            self.pesos_por_simbolo = cargar_pesos_estrategias()\n        except ValueError as e:\n            log.error(f\"\u274c {e}\")\n            return False\n        \n        duracion = 0.0\n        try:\n            apertura = datetime.fromisoformat(orden.timestamp)\n            duracion = (datetime.utcnow() - apertura).total_seconds() / 60\n        except Exception:\n            pass\n        prev = self.historial_cierres.get(orden.symbol, {})\n        self.historial_cierres[orden.symbol] = {\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"motivo\": motivo.lower().strip(),\n            \"velas\": 0,\n            \"precio\": precio,\n            \"tendencia\": tendencia,\n            \"duracion\": duracion,\n            \"retorno_total\": retorno_total,\n        }\n        if retorno_total < 0:\n            fecha_hoy = datetime.utcnow().date().isoformat()\n            if prev.get(\"fecha_perdidas\") != fecha_hoy:\n                perdidas = 0\n            else:\n                perdidas = prev.get(\"perdidas_consecutivas\", 0)\n            perdidas += 1\n            self.historial_cierres[orden.symbol][\"perdidas_consecutivas\"] = perdidas\n            self.historial_cierres[orden.symbol][\"fecha_perdidas\"] = fecha_hoy\n        else:\n            self.historial_cierres[orden.symbol][\"perdidas_consecutivas\"] = 0\n        log.info(\n            f\"\u2705 CIERRE {motivo.upper()}: {orden.symbol} | Beneficio: {ganancia:.2f} \u20ac\"\n        )\n        registro_metrico.registrar(\n            \"cierre\",\n            {\n                \"symbol\": orden.symbol,\n                \"motivo\": motivo,\n                \"retorno\": retorno_total,\n                \"beneficio\": ganancia,\n            },\n        )\n        self._registrar_salida_profesional(\n            orden.symbol,\n            {\n                \"tipo_salida\": motivo,\n                \"estrategias_activas\": orden.estrategias_activas,\n                \"score_tecnico_al_cierre\": (\n                    self._calcular_score_tecnico(\n                        df,\n                        calcular_rsi(df),\n                        calcular_momentum(df),\n                        tendencia or \"\",\n                        orden.direccion,\n                    )[0]\n                    if df is not None\n                    else 0.0\n                ),\n                \"capital_final\": capital_final,\n                \"configuracion_usada\": self.config_por_simbolo.get(orden.symbol, {}),\n                \"tiempo_operacion\": duracion,\n                \"beneficio_relativo\": retorno_total,\n            },\n        )\n        metricas = self._metricas_recientes()\n        self.risk.ajustar_umbral(metricas)\n        try:\n            rsi_val = calcular_rsi(df) if df is not None else None\n            score, _ = (\n                self._calcular_score_tecnico(\n                    df,\n                    rsi_val,\n                    calcular_momentum(df),\n                    tendencia or \"\",\n                    orden.direccion,\n                )\n                if df is not None\n                else (None, None)\n            )\n            registrar_auditoria(\n                symbol=orden.symbol,\n                evento=motivo,\n                resultado=\"ganancia\" if retorno_total > 0 else \"p\u00e9rdida\",\n                estrategias_activas=orden.estrategias_activas,\n                score=score,\n                rsi=rsi_val,\n                tendencia=tendencia,\n                capital_actual=capital_final,\n                config_usada=self.config_por_simbolo.get(orden.symbol, {}),\n            )\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo registrar auditor\u00eda de cierre: {e}\")\n        return True\n    \n    def _registrar_salida_profesional(self, symbol: str, info: dict) -> None:\n        archivo = \"reportes_diarios/registro_salidas.parquet\"\n        os.makedirs(os.path.dirname(archivo), exist_ok=True)\n        data = info.copy()\n        data[\"symbol\"] = symbol\n        data[\"timestamp\"] = datetime.utcnow().isoformat()\n        if isinstance(data.get(\"estrategias_activas\"), dict):\n            data[\"estrategias_activas\"] = json.dumps(data[\"estrategias_activas\"])\n        try:\n            if os.path.exists(archivo):\n                df = pd.read_parquet(archivo)\n                df = pd.concat([df, pd.DataFrame([data])], ignore_index=True)\n            else:\n                df = pd.DataFrame([data])\n            df.to_parquet(archivo, index=False)\n        except Exception as e:\n            log.warning(f\"\u26a0\ufe0f Error registrando salida en {archivo}: {e}\")\n    \n    async def _cerrar_parcial_y_reportar(\n        self,\n        orden,\n        cantidad: float,\n        precio: float,\n        motivo: str,\n        df: pd.DataFrame | None = None,\n    ) -> bool:\n        \"\"\"Cierre parcial de ``orden`` y registro en el reporte.\"\"\"\n        if not await self.orders.cerrar_parcial_async(\n            orden.symbol, cantidad, precio, motivo\n        ):\n            log.warning(\n                f\"\u274c No se pudo confirmar el cierre parcial de {orden.symbol}. Se omitir\u00e1 el registro.\"\n            )\n            return False\n\n        retorno_unitario = (\n            (precio - orden.precio_entrada) / orden.precio_entrada\n            if orden.precio_entrada\n            else 0.0\n        )\n        fraccion = cantidad / orden.cantidad if orden.cantidad else 0.0\n        retorno_total = retorno_unitario * fraccion\n        info = orden.to_dict()\n        info.update(\n            {\n                \"precio_cierre\": precio,\n                \"fecha_cierre\": datetime.utcnow().isoformat(),\n                \"motivo_cierre\": motivo,\n                \"retorno_total\": retorno_total,\n                \"cantidad_cerrada\": cantidad,\n                \"capital_inicial\": self.capital_por_simbolo.get(orden.symbol, 0.0),\n            }\n        )\n        reporter_diario.registrar_operacion(info)\n        registrar_resultado_trade(orden.symbol, info, retorno_total)\n        capital_inicial = self.capital_por_simbolo.get(orden.symbol, 0.0)\n        ganancia = capital_inicial * retorno_total\n        capital_final = capital_inicial + ganancia\n        self.capital_por_simbolo[orden.symbol] = capital_final\n        info[\"capital_final\"] = capital_final\n        log.info(f\"\u2705 CIERRE PARCIAL: {orden.symbol} | Beneficio: {ganancia:.2f} \u20ac\")\n        registro_metrico.registrar(\n            \"cierre_parcial\",\n            {\n                \"symbol\": orden.symbol,\n                \"retorno\": retorno_total,\n                \"beneficio\": ganancia,\n            },\n        )\n        self._registrar_salida_profesional(\n            orden.symbol,\n            {\n                \"tipo_salida\": \"parcial\",\n                \"estrategias_activas\": orden.estrategias_activas,\n                \"score_tecnico_al_cierre\": (\n                    self._calcular_score_tecnico(\n                        df,\n                        calcular_rsi(df),\n                        calcular_momentum(df),\n                        orden.tendencia,\n                        orden.direccion,\n                    )[0]\n                    if df is not None\n                    else 0.0\n                ),\n                \"configuracion_usada\": self.config_por_simbolo.get(orden.symbol, {}),\n                \"tiempo_operacion\": 0.0,\n                \"beneficio_relativo\": retorno_total,\n            },\n        )\n        try:\n            rsi_val = calcular_rsi(df) if df is not None else None\n            score, _ = (\n                self._calcular_score_tecnico(\n                    df,\n                    rsi_val,\n                    calcular_momentum(df),\n                    orden.tendencia,\n                    orden.direccion,\n                )\n                if df is not None\n                else (None, None)\n            )\n            registrar_auditoria(\n                symbol=orden.symbol,\n                evento=motivo,\n                resultado=\"ganancia\" if retorno_total > 0 else \"p\u00e9rdida\",\n                estrategias_activas=orden.estrategias_activas,\n                score=score,\n                rsi=rsi_val,\n                tendencia=orden.tendencia,\n                capital_actual=capital_final,\n                config_usada=self.config_por_simbolo.get(orden.symbol, {}),\n            )\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo registrar auditor\u00eda de cierre parcial: {e}\")\n        return True\n    \n    def es_salida_parcial_valida(\n        self,\n        orden,\n        precio_tp: float,\n        config: dict,\n        df: pd.DataFrame,\n    ) -> bool:\n        \"\"\"Determina si aplicar TP parcial tiene sentido econ\u00f3mico.\"\"\"\n\n        if not config.get(\"usar_cierre_parcial\", False):\n            return False\n        try:\n            inversion = (orden.precio_entrada or 0.0) * (orden.cantidad or 0.0)\n            retorno_potencial = (precio_tp - (orden.precio_entrada or 0.0)) * (\n                orden.cantidad or 0.0\n            )\n        except Exception:\n            return False\n\n        if inversion <= config.get(\"umbral_operacion_grande\", 30.0):\n            return False\n        if retorno_potencial <= config.get(\"beneficio_minimo_parcial\", 5.0):\n            return False\n\n        pesos_symbol = self.pesos_por_simbolo.get(orden.symbol, {})\n        if not verificar_filtro_tecnico(\n            orden.symbol, df, orden.estrategias_activas, pesos_symbol, config=config\n        ):\n            return False\n\n        return True\n    \n    async def _piramidar(self, symbol: str, orden, df: pd.DataFrame) -> None:\n        \"\"\"A\u00f1ade posiciones si el precio avanza a favor.\"\"\"\n        if orden.fracciones_restantes <= 0:\n            return\n        precio_actual = float(df[\"close\"].iloc[-1])\n        if precio_actual >= orden.precio_ultima_piramide * (1 + self.umbral_piramide):\n            cantidad = orden.cantidad / orden.fracciones_totales\n            if await self.orders.agregar_parcial_async(symbol, precio_actual, cantidad):\n                orden.fracciones_restantes -= 1\n                orden.precio_ultima_piramide = precio_actual\n                log.info(f\"\ud83d\udd3c Pir\u00e1mide ejecutada en {symbol} @ {precio_actual:.2f}\")\n\n    @property\n    def ordenes_abiertas(self):\n        \"\"\"Compatibilidad con ``monitorear_estado_periodicamente``.\"\"\"\n        return self.orders.ordenes\n        \n    \n    def ajustar_capital_diario(\n        self,\n        factor: float = 0.2,\n        limite: float = 0.3,\n        penalizacion_corr: float = 0.2,\n        umbral_corr: float = 0.8,\n        fecha: datetime.date | None = None,\n    ) -> None:\n        \"\"\"Redistribuye el capital seg\u00fan m\u00faltiples m\u00e9tricas adaptativas.\"\"\"\n        total = sum(self.capital_por_simbolo.values())\n        # M\u00e9tricas generales de rendimiento (ganancia y drawdown recientes)\n        metricas_globales = self._metricas_recientes()\n        semanales = metricas_semanales()\n\n        pesos: dict[str, float] = {}\n\n        # Conteo de se\u00f1ales v\u00e1lidas en las \u00faltimas 60 min por s\u00edmbolo\n        senales = {s: self._contar_senales(s) for s in self.capital_por_simbolo}\n        \n        max_senales = max(senales.values()) if senales else 0\n        correlaciones = self._calcular_correlaciones()\n        stats = getattr(reporter_diario, \"estadisticas\", pd.DataFrame())\n        for symbol in self.capital_por_simbolo:\n            inicio = self.capital_inicial_diario.get(\n                symbol, self.capital_por_simbolo[symbol]\n            )\n            final = self.capital_por_simbolo[symbol]\n            rendimiento = (final - inicio) / inicio if inicio else 0.0\n            peso = 1 + factor * rendimiento\n            if max_senales > 0:\n                peso += 0.2 * senales[symbol] / max_senales\n            \n            # Penaliza s\u00edmbolos altamente correlacionados\n            corr_media = None\n            if not correlaciones.empty and symbol in correlaciones.columns:\n                corr_series = correlaciones[symbol].drop(labels=[symbol], errors=\"ignore\").abs()\n                corr_media = corr_series.mean()\n            if corr_media >= umbral_corr:\n                    peso *= 1 - penalizacion_corr * corr_media\n\n            # Extrae m\u00e9tricas previas del reporte para el s\u00edmbolo actual\n            fila = (\n                stats[stats[\"symbol\"] == symbol]\n                if (isinstance(stats, pd.DataFrame) and \"symbol\" in stats.columns)\n                else pd.DataFrame()\n            )\n            drawdown = 0.0\n            winrate = 0.0\n            ganancia = 0.0\n            if not fila.empty:\n                drawdown = float(fila[\"drawdown\"].iloc[0])\n                operaciones = float(fila[\"operaciones\"].iloc[0])\n                wins = float(fila[\"wins\"].iloc[0])\n                ganancia = float(fila[\"retorno_acumulado\"].iloc[0])\n                winrate = wins / operaciones if operaciones else 0.0\n            if not semanales.empty:\n                sem = semanales[semanales[\"symbol\"] == symbol]\n                if not sem.empty:\n                    weekly = float(sem[\"ganancia_promedio\"].iloc[0]) * float(sem[\"operaciones\"].iloc[0])\n                    if weekly < -0.05:\n                        peso *= 0.5\n\n            # 4\ufe0f\u20e3 Penalizaci\u00f3n por drawdown acumulado negativo\n            if drawdown < 0:\n                peso *= 1 + drawdown\n\n            # 5\ufe0f\u20e3 Refuerzo por buen desempe\u00f1o (winrate alto y ganancias)\n            if winrate > 0.6 and ganancia > 0:\n                refuerzo = min((winrate - 0.6) * ganancia, 0.3)\n                peso *= 1 + refuerzo\n\n            # Ajuste global seg\u00fan las m\u00e9tricas recientes de todo el bot\n            if metricas_globales:\n                ganancia_global = metricas_globales.get(\"ganancia_semana\", 0.0)\n                drawdown_global = metricas_globales.get(\"drawdown\", 0.0)\n                ajuste_global = 1 + ganancia_global + drawdown_global\n                peso *= max(0.5, min(1.5, ajuste_global))\n\n            # Mantiene el peso final dentro del rango establecido\n\n            peso = max(1 - limite, min(1 + limite, peso))\n            pesos[symbol] = peso\n\n        suma = sum(pesos.values()) or 1\n        for symbol in self.capital_por_simbolo:\n            self.capital_por_simbolo[symbol] = round(total * pesos[symbol] / suma, 2)\n        for symbol in self.capital_por_simbolo:\n            orden = self.orders.obtener(symbol)\n            reserva = 0.0\n            if orden and orden.cantidad_abierta > 0 and self.estado[symbol].buffer:\n                precio_actual = float(self.estado[symbol].buffer[-1].get(\"close\", 0))\n                if precio_actual > orden.precio_entrada:\n                    reserva = self.capital_por_simbolo[symbol] * self.reserva_piramide\n            self.capital_por_simbolo[symbol] -= reserva\n            self.reservas_piramide[symbol] = round(reserva, 2)\n\n        self.capital_inicial_diario = self.capital_por_simbolo.copy()\n        self.fecha_actual = fecha or datetime.utcnow().date()\n        log.info(f\"\ud83d\udcb0 Capital redistribuido: {self.capital_por_simbolo}\")\n\n\n    async def _precargar_historico(self, velas: int = 12) -> None:\n        \"\"\"Carga datos recientes para todos los s\u00edmbolos antes de iniciar.\"\"\"\n        if not self.modo_real or not self.cliente:\n            log.info(\"\ud83d\udcc8 Modo simulado: se omite precarga de hist\u00f3rico desde Binance\")\n            return\n        for symbol in self.estado.keys():\n            try:\n                datos = await fetch_ohlcv_async(\n                    self.cliente,\n                    symbol,\n                    self.config.intervalo_velas,\n                    limit=velas,\n                )\n            except BaseError as e:\n                log.warning(f\"\u26a0\ufe0f Error cargando hist\u00f3rico para {symbol}: {e}\")\n                continue\n            except Exception as e:\n                log.warning(f\"\u26a0\ufe0f Error inesperado cargando hist\u00f3rico para {symbol}: {e}\")\n                continue\n\n            for ts, open_, high_, low_, close_, vol in datos:\n                self.estado[symbol].buffer.append(\n                    {\n                        \"symbol\": symbol,\n                        \"timestamp\": ts,\n                        \"open\": float(open_),\n                        \"high\": float(high_),\n                        \"low\": float(low_),\n                        \"close\": float(close_),\n                        \"volume\": float(vol),\n                    }\n                )\n\n            if datos:\n                self.estado[symbol].ultimo_timestamp = datos[-1][0]\n        log.info(\"\ud83d\udcc8 Hist\u00f3rico inicial cargado\")\n\n    async def _ciclo_aprendizaje(self, intervalo: int = 86400) -> None:\n        \"\"\"Ejecuta el proceso de aprendizaje continuo peri\u00f3dicamente.\"\"\"\n        await asyncio.sleep(1)\n        while True:\n            try:\n                loop = asyncio.get_running_loop()\n                await loop.run_in_executor(None, ciclo_aprendizaje)\n                log.info(\"\ud83e\udde0 Ciclo de aprendizaje completado\")\n            except Exception as e:  # noqa: BLE001\n                log.warning(f\"\u26a0\ufe0f Error en ciclo de aprendizaje: {e}\")\n            await asyncio.sleep(intervalo)\n    \n    async def _calcular_cantidad_async(self, symbol: str, precio: float) -> float:\n        \"\"\"Delegado a :class:`CapitalManager`.\"\"\"\n        return await self.capital_manager.calcular_cantidad_async(symbol, precio)\n    \n    def _calcular_cantidad(self, symbol: str, precio: float) -> float:\n        \"\"\"Versi\u00f3n s\u00edncrona de :meth:`_calcular_cantidad_async`.\"\"\"\n        return self.capital_manager.calcular_cantidad(symbol, precio)\n\n    def _metricas_recientes(self, dias: int = 7) -> dict:\n        \"\"\"Calcula ganancia acumulada y drawdown de los \u00faltimos ``dias``.\"\"\"\n        carpeta = reporter_diario.carpeta\n        if not os.path.isdir(carpeta):\n            return {\n                \"ganancia_semana\": 0.0,\n                \"drawdown\": 0.0,\n                \"winrate\": 0.0,\n                \"capital_actual\": sum(self.capital_por_simbolo.values()),\n                \"capital_inicial\": sum(self.capital_inicial_diario.values()),\n            }\n\n        fecha_limite = datetime.utcnow().date() - timedelta(days=dias)\n        retornos: list[float] = []\n\n        archivos = sorted(\n            [f for f in os.listdir(carpeta) if f.endswith(\".csv\")], reverse=True\n        )[\n            :20\n        ]  # solo los 20 archivos m\u00e1s recientes\n\n        for archivo in archivos:\n            try:\n                fecha = datetime.fromisoformat(archivo.replace(\".csv\", \"\")).date()\n            except ValueError:\n                continue\n            if fecha < fecha_limite:\n                continue\n            ruta_archivo = os.path.join(carpeta, archivo)\n            df = leer_reporte_seguro(ruta_archivo, columnas_esperadas=20)\n            if df.empty:\n                continue\n            if \"retorno_total\" in df.columns:\n                retornos.extend(df[\"retorno_total\"].dropna().tolist())\n\n        if not retornos:\n            return {\n                \"ganancia_semana\": 0.0,\n                \"drawdown\": 0.0,\n                \"winrate\": 0.0,\n                \"capital_actual\": sum(self.capital_por_simbolo.values()),\n                \"capital_inicial\": sum(self.capital_inicial_diario.values()),\n            }\n\n        serie = pd.Series(retornos).cumsum()\n        drawdown = float((serie - serie.cummax()).min())\n        ganancia = float(serie.iloc[-1])\n        return {\"ganancia_semana\": ganancia, \"drawdown\": drawdown}\n    \n    def _contar_senales(self, symbol: str, minutos: int = 60) -> int:\n        \"\"\"Cuenta se\u00f1ales v\u00e1lidas recientes para ``symbol``.\"\"\"\n        estado = self.estado.get(symbol)\n        if not estado:\n            return 0\n        limite = datetime.utcnow().timestamp() * 1000 - minutos * 60 * 1000\n        return sum(\n            1\n            for v in estado.buffer\n            if pd.to_datetime(v.get(\"timestamp\")).timestamp() * 1000 >= limite\n            and v.get(\"estrategias_activas\")\n        )\n\n    def _obtener_historico(self, symbol: str) -> pd.DataFrame | None:\n        \"\"\"Devuelve el DataFrame de hist\u00f3rico para ``symbol`` usando cach\u00e9.\"\"\"\n        df = self.historicos.get(symbol)\n        if df is None:\n            archivo = f\"datos/{symbol.replace('/', '_').lower()}_1m.parquet\"\n            try:\n                df = pd.read_parquet(archivo)\n                self.historicos[symbol] = df\n            except Exception as e:\n                log.debug(f\"No se pudo cargar hist\u00f3rico para {symbol}: {e}\")\n                self.historicos[symbol] = None\n                return None\n        return df\n        \n    def _calcular_correlaciones(self, periodos: int = 1440) -> pd.DataFrame:\n        \"\"\"Calcula correlaci\u00f3n hist\u00f3rica de cierres entre s\u00edmbolos.\"\"\"\n        precios = {}\n        for symbol in self.capital_por_simbolo:\n            df = self._obtener_historico(symbol)\n            if df is not None and \"close\" in df:\n                precios[symbol] = (\n                    df[\"close\"].astype(float).tail(periodos).reset_index(drop=True)\n                )\n        if len(precios) < 2:\n            return pd.DataFrame()\n        df_precios = pd.DataFrame(precios)\n        return df_precios.corr()\n    \n    # Helpers de soporte -------------------------------------------------\n\n    def _rechazo(\n        self,\n        symbol: str,\n        motivo: str,\n        puntaje: float | None = None,\n        peso_total: float | None = None,\n        estrategias: list[str] | dict | None = None,\n    ) -> None:\n        \"\"\"Centraliza los mensajes de descartes de entrada.\"\"\"\n        mensaje = f\"\ud83d\udd34 RECHAZO: {symbol} | Causa: {motivo}\"\n        if puntaje is not None:\n            mensaje += f\" | Puntaje: {puntaje:.2f}\"\n        if peso_total is not None:\n            mensaje += f\" | Peso: {peso_total:.2f}\"\n        if estrategias:\n            estr = estrategias\n            if isinstance(estr, dict):\n                estr = list(estr.keys())\n            mensaje += f\" | Estrategias: {estr}\"\n        log.info(mensaje)\n\n        registro = {\n            \"symbol\": symbol,\n            \"motivo\": motivo,\n            \"puntaje\": puntaje,\n            \"peso_total\": peso_total,\n            \"estrategias\": \",\".join(estrategias.keys() if isinstance(estrategias, dict) else estrategias) if estrategias else \"\",\n        }\n        fecha = datetime.utcnow().strftime(\"%Y%m%d\")\n        archivo = os.path.join(\n            \"logs/rechazos\", f\"{symbol.replace('/', '_')}_{fecha}.csv\"\n        )\n        df = pd.DataFrame([registro])\n        modo = \"a\" if os.path.exists(archivo) else \"w\"\n        df.to_csv(archivo, mode=modo, header=not os.path.exists(archivo), index=False)\n        registro_metrico.registrar(\"rechazo\", registro)\n\n        try:\n            registrar_auditoria(\n                symbol=symbol,\n                evento=\"Entrada rechazada\",\n                resultado=\"rechazo\",\n                estrategias_activas=estrategias,\n                score=puntaje,\n                razon=motivo,\n                capital_actual=self.capital_por_simbolo.get(symbol, 0.0),\n                config_usada=self.config_por_simbolo.get(symbol, {}),\n            )\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo registrar auditor\u00eda de rechazo: {e}\")\n\n    def _validar_puntaje(self, symbol: str, puntaje: float, umbral: float) -> bool:\n        \"\"\"Comprueba si ``puntaje`` supera ``umbral``.\"\"\"\n        diferencia = umbral - puntaje\n        metricas_tracker.registrar_diferencia_umbral(diferencia)\n        if puntaje < umbral:\n            log.debug(f\"\ud83d\udeab {symbol}: puntaje {puntaje:.2f} < umbral {umbral:.2f}\")\n            metricas_tracker.registrar_filtro(\"umbral\")\n            return False\n        return True\n\n    async def _validar_diversidad(\n        self,\n        symbol: str,\n        peso_total: float,\n        peso_min_total: float,\n        estrategias_activas: Dict[str, float],\n        diversidad_min: int,\n        estrategias_disponibles: dict,\n        df: pd.DataFrame,\n    ) -> bool:\n        \"\"\"Verifica que la diversidad y el peso total sean suficientes.\"\"\"\n        diversidad = len(estrategias_activas)\n        \n        if self.modo_capital_bajo:\n            euros = 0\n            if self.modo_real and self.cliente:\n                try:\n                    balance = await fetch_balance_async(self.cliente)\n                    euros = balance[\"total\"].get(\"EUR\", 0)\n                except BaseError:\n                    euros = 0\n            if euros < 500:\n                diversidad_min = min(diversidad_min, 2)\n                peso_min_total *= 0.7\n        \n        if diversidad < diversidad_min or peso_total < peso_min_total:\n            self._rechazo(\n                symbol,\n                f\"Diversidad {diversidad} < {diversidad_min} o peso {peso_total:.2f} < {peso_min_total:.2f}\",\n                peso_total=peso_total,\n            )\n            metricas_tracker.registrar_filtro(\"diversidad\")\n            return False\n        return True\n\n    def _validar_estrategia(\n        self, symbol: str, df: pd.DataFrame, estrategias: Dict\n    ) -> bool:\n        \"\"\"Aplica el filtro estrat\u00e9gico de entradas.\"\"\"\n        if not evaluar_validez_estrategica(symbol, df, estrategias):\n            log.debug(f\"\u274c Entrada rechazada por filtro estrat\u00e9gico en {symbol}.\")\n            return False\n        return True\n\n    def _evaluar_persistencia(\n        self,\n        symbol: str,\n        estado: EstadoSimbolo,\n        df: pd.DataFrame,\n        pesos_symbol: Dict[str, float],\n        tendencia_actual: str,\n        puntaje: float,\n        umbral: float,\n        estrategias: Dict[str, bool],\n    ) -> tuple[bool, float, float]:\n        \"\"\"Eval\u00faa si las se\u00f1ales persistentes son suficientes para entrar.\"\"\"\n        ventana_close = df[\"close\"].tail(10)\n        media_close = np.mean(ventana_close)\n        if np.isnan(media_close) or media_close == 0:\n            log.debug(f\"\u26a0\ufe0f {symbol}: Media de cierre inv\u00e1lida para persistencia\")\n            return False\n\n        repetidas = coincidencia_parcial(estado.buffer, pesos_symbol, ventanas=5)\n        minimo = calcular_persistencia_minima(\n            symbol,\n            df,\n            tendencia_actual,\n            base_minimo=self.persistencia.minimo,\n        )\n\n        log.info(\n            f\"Persistencia detectada {repetidas:.2f} | M\u00ednimo requerido {minimo:.2f}\"\n        )\n\n        \n        if repetidas < minimo:\n            self._rechazo(\n                symbol,\n                f\"Persistencia {repetidas:.2f} < {minimo}\",\n                puntaje=puntaje,\n                estrategias=list(estrategias.keys()),\n            )\n            metricas_tracker.registrar_filtro(\"persistencia\")\n            return False, repetidas, minimo\n\n        if repetidas < 1 and puntaje < 1.2 * umbral:\n            self._rechazo(\n                symbol,\n                f\"{repetidas:.2f} coincidencia y puntaje d\u00e9bil ({puntaje:.2f})\",\n                puntaje=puntaje,\n                estrategias=list(estrategias.keys()),\n            )\n            return False, repetidas, minimo\n        elif repetidas < 1:\n            log.info(\n                f\"\u26a0\ufe0f Entrada d\u00e9bil en {symbol}: Coincidencia {repetidas:.2f} insuficiente pero puntaje alto ({puntaje}) > Umbral {umbral} \u2014 Permitida.\"\n            )\n            metricas_tracker.registrar_filtro(\"persistencia\")\n        return True, repetidas, minimo\n    \n    def _tendencia_persistente(\n        self, symbol: str, df: pd.DataFrame, tendencia: str, velas: int = 3\n    ) -> bool:\n        if len(df) < 30 + velas:\n            return False\n        for i in range(velas):\n            sub_df = df.iloc[: -(velas - 1 - i)] if velas - 1 - i > 0 else df\n            t, _ = detectar_tendencia(symbol, sub_df)\n            if t != tendencia:\n                return False\n        return True\n\n    def _validar_reentrada_tendencia(\n        self, symbol: str, df: pd.DataFrame, cierre: dict, precio: float\n    ) -> bool:\n        if cierre.get(\"motivo\") != \"cambio de tendencia\":\n            return True\n\n        tendencia = cierre.get(\"tendencia\")\n        if not tendencia:\n            return False\n\n        cierre_dt = pd.to_datetime(cierre.get(\"timestamp\"), errors=\"coerce\")\n        if pd.isna(cierre_dt):\n            log.warning(f\"\u26a0\ufe0f {symbol}: Timestamp de cierre inv\u00e1lido\")\n            return False\n        duracion = cierre.get(\"duracion\", 0)\n        retorno = abs(cierre.get(\"retorno_total\", 0))\n        velas_requeridas = 3 + min(int(duracion // 30), 3)\n        if retorno > 0.05:\n            velas_requeridas += 1\n        df_post = df[pd.to_datetime(df[\"timestamp\"]) > cierre_dt]\n        if len(df_post) < velas_requeridas:\n            log.info(\n                f\"\u23f3 {symbol}: esperando confirmaci\u00f3n de tendencia {len(df_post)}/{velas_requeridas}\"\n            )\n            return False\n        if not self._tendencia_persistente(\n            symbol, df_post, tendencia, velas=velas_requeridas\n        ):\n            log.info(f\"\u23f3 {symbol}: tendencia {tendencia} no persistente tras cierre\")\n            return False\n\n        precio_salida = cierre.get(\"precio\")\n        if precio_salida is not None and abs(precio - precio_salida) <= precio * 0.001:\n            log.info(f\"\ud83d\udeab {symbol}: precio de entrada similar al de salida anterior\")\n            return False\n\n        return True\n    \n    def _calcular_score_tecnico(\n        self,\n        df: pd.DataFrame,\n        rsi: float | None,\n        momentum: float | None,\n        tendencia: str,\n        direccion: str,\n    ) -> tuple[float, dict]:\n        \"\"\"Calcula un puntaje t\u00e9cnico simple a partir de varios indicadores.\"\"\"\n\n        slope = calcular_slope(df)\n\n        resultados = {\n            \"RSI\": False,\n            \"Momentum\": False,\n            \"Slope\": False,\n            \"Tendencia\": False,\n        }\n\n        if rsi is not None:\n            if direccion == \"long\":\n                resultados[\"RSI\"] = rsi > 50\n            else:\n                resultados[\"RSI\"] = rsi < 50\n\n        if momentum is not None:\n            resultados[\"Momentum\"] = abs(momentum) > 0.001\n\n        resultados[\"Slope\"] = slope > 0.01\n\n        if direccion == \"long\":\n            resultados[\"Tendencia\"] = tendencia in {\"alcista\", \"lateral\"}\n        else:\n            resultados[\"Tendencia\"] = tendencia in {\"bajista\", \"lateral\"}\n\n        score_total = sum(\n            PESOS_SCORE_TECNICO.get(k, 1.0) for k, v in resultados.items() if v\n        )\n\n        log.info(\n            \"\ud83d\udcca Score t\u00e9cnico: %.2f | RSI: %s (%.2f), Momentum: %s (%.4f), Slope: %s (%.4f), Tendencia: %s\",\n            score_total,\n            \"\u2705\" if resultados[\"RSI\"] else \"\u274c\",\n            rsi if rsi is not None else 0.0,\n            \"\u2705\" if resultados[\"Momentum\"] else \"\u274c\",\n            momentum if momentum is not None else 0.0,\n            \"\u2705\" if resultados[\"Slope\"] else \"\u274c\",\n            slope,\n            \"\u2705\" if resultados[\"Tendencia\"] else \"\u274c\",\n        )\n\n        return float(score_total), resultados\n\n    def _hay_contradicciones(\n        self,\n        df: pd.DataFrame,\n        rsi: float | None,\n        momentum: float | None,\n        direccion: str,\n        score: float,\n    ) -> bool:\n        \"\"\"Detecta si existen contradicciones fuertes en las se\u00f1ales.\"\"\"\n\n        if direccion == \"long\":\n            if rsi is not None and rsi > 70:\n                return True\n            if df[\"close\"].iloc[-1] >= df[\"close\"].iloc[-10] * 1.05:\n                return True\n            if (\n                momentum is not None\n                and momentum < 0\n                and score >= self.umbral_score_tecnico\n            ):\n                return True\n        else:\n            if rsi is not None and rsi < 30:\n                return True\n            if df[\"close\"].iloc[-1] <= df[\"close\"].iloc[-10] * 0.95:\n                return True\n            if (\n                momentum is not None\n                and momentum > 0\n                and score >= self.umbral_score_tecnico\n            ):\n                return True\n        return False\n\n    def _validar_temporalidad(self, df: pd.DataFrame, direccion: str) -> bool:\n        \"\"\"Verifica que las se\u00f1ales no est\u00e9n perdiendo fuerza.\"\"\"\n\n        rsi_series = calcular_rsi(df, serie_completa=True)\n        if rsi_series is None or len(rsi_series) < 3:\n            return True\n        r = rsi_series.iloc[-3:]\n        if direccion == \"long\" and not (r.iloc[-1] > r.iloc[-2] > r.iloc[-3]):\n            return False\n        if direccion == \"short\" and not (r.iloc[-1] < r.iloc[-2] < r.iloc[-3]):\n            return False\n\n        slope3 = calcular_slope(df, periodo=3)\n        slope5 = calcular_slope(df, periodo=5)\n        if direccion == \"long\" and not (slope3 > slope5):\n            return False\n        if direccion == \"short\" and not (slope3 < slope5):\n            return False\n        return True\n\n    def _registrar_rechazo_tecnico(\n        self,\n        symbol: str,\n        score: float,\n        puntos: dict,\n        tendencia: str,\n        precio: float,\n        motivo: str,\n        estrategias: dict | None = None,\n    ) -> None:\n        \"\"\"Guarda detalles de rechazos t\u00e9cnicos en un CSV.\"\"\"\n\n        if not self.registro_tecnico_csv:\n            return\n        fila = {\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"symbol\": symbol,\n            \"puntaje_total\": score,\n            \"indicadores_fallidos\": \",\".join([k for k, v in puntos.items() if not v]),\n            \"estado_mercado\": tendencia,\n            \"precio\": precio,\n            \"motivo\": motivo,\n            \"estrategias\": \",\".join(estrategias.keys()) if estrategias else \"\",\n        }\n        df = pd.DataFrame([fila])\n        modo = \"a\" if os.path.exists(self.registro_tecnico_csv) else \"w\"\n        df.to_csv(\n            self.registro_tecnico_csv,\n            mode=modo,\n            header=not os.path.exists(self.registro_tecnico_csv),\n            index=False,\n        )\n\n    async def evaluar_condiciones_entrada(\n        self, symbol: str, df: pd.DataFrame\n    ) -> None:\n        \"\"\"Eval\u00faa y ejecuta una entrada si todas las condiciones se cumplen.\"\"\"\n\n        estado = self.estado[symbol]\n        config_actual = self.config_por_simbolo.get(symbol, {})\n        dinamica = adaptar_configuracion(symbol, df)\n        if dinamica:\n            config_actual.update(dinamica)\n        config_actual = adaptar_configuracion_base(symbol, df, config_actual)\n        self.config_por_simbolo[symbol] = config_actual\n\n        tendencia_actual = self.estado_tendencia.get(symbol)\n        if not tendencia_actual:\n            tendencia_actual, _ = detectar_tendencia(symbol, df)\n            self.estado_tendencia[symbol] = tendencia_actual\n\n        resultado = self.engine.evaluar_entrada(\n            symbol,\n            df,\n            tendencia=tendencia_actual,\n            config=config_actual,\n            pesos_symbol=self.pesos_por_simbolo.get(symbol, {}),\n        )\n        estrategias = resultado.get(\"estrategias_activas\", {})\n        estado.buffer[-1][\"estrategias_activas\"] = estrategias\n        self.persistencia.actualizar(symbol, estrategias)\n\n        precio_actual = float(df[\"close\"].iloc[-1])\n\n        if not resultado.get(\"permitido\"):\n            if self.usar_score_tecnico:\n                rsi = resultado.get(\"rsi\")\n                mom = resultado.get(\"momentum\")\n                score, puntos = self._calcular_score_tecnico(\n                    df, rsi, mom, tendencia_actual,\n                    \"short\" if tendencia_actual == \"bajista\" else \"long\",\n                )\n                self._registrar_rechazo_tecnico(\n                    symbol,\n                    score,\n                    puntos,\n                    tendencia_actual,\n                    precio_actual,\n                    resultado.get(\"motivo_rechazo\", \"desconocido\"),\n                    estrategias,\n                )\n            self._rechazo(\n                symbol,\n                resultado.get(\"motivo_rechazo\", \"desconocido\"),\n                puntaje=resultado.get(\"score_total\"),\n                estrategias=list(estrategias.keys()),\n            )\n            return\n\n        info = await self.evaluar_condiciones_de_entrada(symbol, df, estado)\n        if not info:\n            self._rechazo(\n                symbol,\n                \"filtros_post_engine\",\n                puntaje=resultado.get(\"score_total\"),\n                estrategias=list(estrategias.keys()),\n            )\n            return\n\n        await self._abrir_operacion_real(**info)\n\n    async def _abrir_operacion_real(\n        self,\n        symbol: str,\n        precio: float,\n        sl: float,\n        tp: float,\n        estrategias: Dict | List,\n        tendencia: str,\n        direccion: str,\n        puntaje: float = 0.0,\n        umbral: float = 0.0,\n        detalles_tecnicos: dict | None = None,\n        **kwargs,  # <- acepta par\u00e1metros adicionales sin fallar\n    ) -> None:\n        cantidad_total = await self.capital_manager.calcular_cantidad_async(symbol, precio)\n        if cantidad_total <= 0:\n            return\n        fracciones = self.piramide_fracciones\n        cantidad = cantidad_total / fracciones\n        if isinstance(estrategias, dict):\n            estrategias_dict = estrategias\n        else:\n            pesos_symbol = self.pesos_por_simbolo.get(symbol, {})\n            estrategias_dict = {e: pesos_symbol.get(e, 0.0) for e in estrategias}\n        await self.orders.abrir_async(\n            symbol,\n            precio,\n            sl,\n            tp,\n            estrategias_dict,\n            tendencia,\n            direccion,\n            cantidad,\n            puntaje,\n            umbral,\n            objetivo=cantidad_total,\n            fracciones=fracciones,\n            detalles_tecnicos=detalles_tecnicos or {}\n        )\n        estrategias_list = list(estrategias_dict.keys())\n        log.info(\n            f\"\ud83d\udfe2 ENTRADA: {symbol} | Puntaje: {puntaje:.2f} / Umbral: {umbral:.2f} | Estrategias: {estrategias_list}\"\n        )\n        registro_metrico.registrar(\n            \"entrada\",\n            {\n                \"symbol\": symbol,\n                \"puntaje\": puntaje,\n                \"umbral\": umbral,\n                \"estrategias\": \",\".join(estrategias_list),\n                \"precio\": precio,\n            },\n        )\n        try:\n            registrar_auditoria(\n                symbol=symbol,\n                evento=\"Entrada\",\n                resultado=\"ejecutada\",\n                estrategias_activas=estrategias_dict,\n                score=puntaje,\n                tendencia=tendencia,\n                capital_actual=self.capital_por_simbolo.get(symbol, 0.0),\n                config_usada=self.config_por_simbolo.get(symbol, {}),\n            )\n        except Exception as e:  # noqa: BLE001\n            log.debug(f\"No se pudo registrar auditor\u00eda de entrada: {e}\")\n\n    async def _verificar_salidas(self, symbol: str, df: pd.DataFrame) -> None:\n        await verificar_salidas(self, symbol, df)\n\n    async def evaluar_condiciones_de_entrada(\n        self, symbol: str, df: pd.DataFrame, estado: EstadoSimbolo\n        ) -> dict | None:\n            if not self._validar_config(symbol):\n                return None\n            return await verificar_entrada(self, symbol, df, estado)\n\n\n\n    async def ejecutar(self) -> None:\n        \"\"\"Inicia el procesamiento de todos los s\u00edmbolos.\"\"\"\n        async def handle(candle: dict) -> None:\n            await self._procesar_vela(candle)\n\n        async def handle_context(symbol: str, score: float) -> None:\n            log.debug(f\"\ud83d\udd01 Contexto actualizado {symbol}: {score:.2f}\")\n\n        symbols = list(self.estado.keys())\n        await self._precargar_historico(velas=60)\n\n        def _log_fallo_task(task: asyncio.Task):\n            if task.cancelled():\n                log.warning(\"\u26a0\ufe0f Una tarea fue cancelada.\")\n            elif task.exception():\n                log.error(f\"\u274c Error en tarea asincr\u00f3nica: {task.exception()}\")\n\n        self._task = asyncio.create_task(self.data_feed.escuchar(symbols, handle))\n        self._task.add_done_callback(_log_fallo_task)\n\n        self._task_estado = asyncio.create_task(monitorear_estado_periodicamente(self))\n        self._task_estado.add_done_callback(_log_fallo_task)\n\n        self._task_contexto = asyncio.create_task(self.context_stream.escuchar(symbols, handle_context))\n        self._task_contexto.add_done_callback(_log_fallo_task)\n        self._task_flush = asyncio.create_task(ordenes_reales.flush_periodico())\n        self._task_flush.add_done_callback(_log_fallo_task)\n        if \"PYTEST_CURRENT_TEST\" not in os.environ:\n            self._task_aprendizaje = asyncio.create_task(self._ciclo_aprendizaje())\n            self._task_aprendizaje.add_done_callback(_log_fallo_task)\n\n        try:\n            tareas = [self._task, self._task_estado, self._task_contexto, self._task_flush]\n            if self._task_aprendizaje:\n                tareas.append(self._task_aprendizaje)\n            await asyncio.gather(*tareas)\n        except Exception as e:\n            log.error(f\"\u274c Error inesperado en ejecuci\u00f3n de tareas: {e}\")\n            \n        tareas = [self._task, self._task_estado, self._task_contexto, self._task_flush]\n        if self._task_aprendizaje:\n            tareas.append(self._task_aprendizaje)\n        await asyncio.gather(*tareas)\n\n    async def _procesar_vela(self, vela: dict) -> None:\n        symbol = vela.get(\"symbol\")\n        if not self._validar_config(symbol):\n            return\n        \n        await procesar_vela(self, vela)\n        return\n\n    async def cerrar(self) -> None:\n        if self._task:\n            await self.data_feed.detener()\n            self._task.cancel()\n            try:\n                await self._task\n            except asyncio.CancelledError:\n                pass\n        if self._task_estado:\n            self._task_estado.cancel()\n            try:\n                await self._task_estado\n            except asyncio.CancelledError:\n                pass\n\n        if self._task_contexto:\n            await self.context_stream.detener()\n            self._task_contexto.cancel()\n            try:\n                await self._task_contexto\n            except asyncio.CancelledError:\n                pass\n            \n        if self._task_aprendizaje:\n            self._task_aprendizaje.cancel()\n            try:\n                await self._task_aprendizaje\n            except asyncio.CancelledError:\n                pass\n\n        self._guardar_estado_persistente()\n\n\n    def _guardar_estado_persistente(self) -> None:\n        \"\"\"Guarda historial de cierres y capital en ``estado/``.\"\"\"\n        try:\n            os.makedirs(\"estado\", exist_ok=True)\n            with open(\"estado/historial_cierres.json\", \"w\") as f:\n                json.dump(self.historial_cierres, f, indent=2)\n            with open(\"estado/capital.json\", \"w\") as f:\n                json.dump(self.capital_por_simbolo, f, indent=2)\n        except Exception as e:  # noqa: BLE001\n            log.warning(f\"\u26a0\ufe0f Error guardando estado persistente: {e}\")\n\n\n    def _cargar_estado_persistente(self) -> None:\n        \"\"\"Carga el estado previo de ``estado/`` si existe.\"\"\"\n        try:\n            if os.path.exists(\"estado/historial_cierres.json\"):\n                with open(\"estado/historial_cierres.json\") as f:\n                    contenido = f.read()\n                if contenido.strip():\n                    try:\n                        data = json.loads(contenido)\n                    except json.JSONDecodeError as e:\n                        log.warning(f\"\u26a0\ufe0f Error leyendo historial_cierres.json: {e}\")\n                        data = {}\n                    if isinstance(data, dict):\n                        self.historial_cierres.update(data)\n            if os.path.exists(\"estado/capital.json\"):\n                with open(\"estado/capital.json\") as f:\n                    contenido = f.read()\n                if contenido.strip():\n                    try:\n                        data = json.loads(contenido)\n                    except json.JSONDecodeError as e:\n                        log.warning(f\"\u26a0\ufe0f Error leyendo capital.json: {e}\")\n                        data = {}\n                    if isinstance(data, dict):\n                        self.capital_por_simbolo.update({k: float(v) for k, v in data.items()})\n        except Exception as e:  # noqa: BLE001\n            log.warning(f\"\u26a0\ufe0f Error cargando estado persistente: {e}\")\n\n    def _validar_config(self, symbol: str) -> bool:\n        \"\"\"Valida que exista configuraci\u00f3n para ``symbol``.\"\"\"\n        cfg = self.config_por_simbolo.get(symbol)\n        if not isinstance(cfg, dict):\n            log.error(f\"\u26a0\ufe0f Configuraci\u00f3n no encontrada para {symbol}\")\n            return False\n        return True\n"]]], 1750727260.4174204]], ["ChangeSet", ["Writing file <core/strategies/ajustador_pesos.py>", [["ChangeContents", ["core/strategies/ajustador_pesos.py", "import json\nimport numpy as np\nfrom core.utils.utils import configurar_logger\n\nlog = configurar_logger(\"ajustador_pesos\")\n\n\ndef ajustar_pesos_por_desempeno(resultados_backtest: dict, ruta_salida: str) -> dict:\n    \"\"\"\n    Ajusta y normaliza los pesos de estrategias por s\u00edmbolo usando softmax estable.\n    Guarda un JSON con los pesos escalados en una escala de 0 a 10.\n    \"\"\"\n    pesos_ajustados = {}\n\n    for symbol, resultados in resultados_backtest.items():\n        # Filtrar estrategias v\u00e1lidas (n\u00fameros positivos)\n        valores_validos = {\n            estrategia: v for estrategia, v in resultados.items()\n            if isinstance(v, (int, float)) and v >= 0\n        }\n\n        if not valores_validos:\n            log.warning(f\"\u26a0\ufe0f Sin datos v\u00e1lidos para {symbol}. Saltando...\")\n            continue\n\n        estrategias = list(valores_validos.keys())\n        valores = np.array(list(valores_validos.values()), dtype=np.float64)\n\n        # Softmax estable (evita overflow exponencial)\n        valores_stable = valores - np.max(valores)\n        exp_vals = np.exp(valores_stable)\n        suma_exp = exp_vals.sum()\n\n        if suma_exp == 0:\n            log.warning(f\"\u26a0\ufe0f Softmax colaps\u00f3 para {symbol}. Asignando pesos iguales.\")\n            pesos_normalizados = {k: round(10.0 / len(valores_validos), 2) for k in estrategias}\n        else:\n            pesos_normalizados = {\n                estrategia: round((np.exp(v - np.max(valores)) / suma_exp) * 10, 2)\n                for estrategia, v in valores_validos.items()\n            }\n\n        pesos_ajustados[symbol] = pesos_normalizados\n        log.info(f\"\u2705 Pesos calculados para {symbol}: {pesos_normalizados}\")\n\n    # Guardar resultados\n    try:\n        with open(ruta_salida, \"w\") as f:\n            json.dump(pesos_ajustados, f, indent=4)\n        log.info(f\"\ud83d\udcc1 Pesos ajustados guardados en {ruta_salida}\")\n    except OSError as e:\n        log.error(f\"\u274c Error al guardar pesos en {ruta_salida}: {e}\")\n        raise\n\n    return pesos_ajustados\n\n\n", "import json\nimport numpy as np\nfrom pegaso.core.utils.utils import configurar_logger\n\nlog = configurar_logger(\"ajustador_pesos\")\n\n\ndef ajustar_pesos_por_desempeno(resultados_backtest: dict, ruta_salida: str) -> dict:\n    \"\"\"\n    Ajusta y normaliza los pesos de estrategias por s\u00edmbolo usando softmax estable.\n    Guarda un JSON con los pesos escalados en una escala de 0 a 10.\n    \"\"\"\n    pesos_ajustados = {}\n\n    for symbol, resultados in resultados_backtest.items():\n        # Filtrar estrategias v\u00e1lidas (n\u00fameros positivos)\n        valores_validos = {\n            estrategia: v for estrategia, v in resultados.items()\n            if isinstance(v, (int, float)) and v >= 0\n        }\n\n        if not valores_validos:\n            log.warning(f\"\u26a0\ufe0f Sin datos v\u00e1lidos para {symbol}. Saltando...\")\n            continue\n\n        estrategias = list(valores_validos.keys())\n        valores = np.array(list(valores_validos.values()), dtype=np.float64)\n\n        # Softmax estable (evita overflow exponencial)\n        valores_stable = valores - np.max(valores)\n        exp_vals = np.exp(valores_stable)\n        suma_exp = exp_vals.sum()\n\n        if suma_exp == 0:\n            log.warning(f\"\u26a0\ufe0f Softmax colaps\u00f3 para {symbol}. Asignando pesos iguales.\")\n            pesos_normalizados = {k: round(10.0 / len(valores_validos), 2) for k in estrategias}\n        else:\n            pesos_normalizados = {\n                estrategia: round((np.exp(v - np.max(valores)) / suma_exp) * 10, 2)\n                for estrategia, v in valores_validos.items()\n            }\n\n        pesos_ajustados[symbol] = pesos_normalizados\n        log.info(f\"\u2705 Pesos calculados para {symbol}: {pesos_normalizados}\")\n\n    # Guardar resultados\n    try:\n        with open(ruta_salida, \"w\") as f:\n            json.dump(pesos_ajustados, f, indent=4)\n        log.info(f\"\ud83d\udcc1 Pesos ajustados guardados en {ruta_salida}\")\n    except OSError as e:\n        log.error(f\"\u274c Error al guardar pesos en {ruta_salida}: {e}\")\n        raise\n\n    return pesos_ajustados\n\n\n"]]], 1750727260.4409347]], ["ChangeSet", ["Writing file <core/strategies/evaluador_tecnico.py>", [["ChangeContents", ["core/strategies/evaluador_tecnico.py", "import json\nimport os\nimport pandas as pd\nfrom indicators.rsi import calcular_rsi\nfrom core.utils.utils import configurar_logger\n\nlog = configurar_logger(\"eval_tecnico\")\n\nRUTA_PESOS = \"config/pesos_tecnicos.json\"\nPESOS_DEFECTO = {\n    \"rsi\": 1.0,\n    \"volumen\": 1.0,\n    \"tp_sl\": 0.7,\n    \"no_doji\": 0.5,\n    \"no_sobrecompra\": 1.0,\n    \"cuerpo_sano\": 1.0,\n    \"rsi_creciente\": 0.6,\n    \"volumen_creciente\": 0.5,\n    \"sin_mecha_sup_larga\": 0.4,\n    \"distancia_extremos\": 0.6,\n}\n\n_pesos_cache: dict | None = None\n\n\ndef _cargar_pesos(symbol: str) -> dict:\n    \"\"\"Devuelve los pesos t\u00e9cnicos para ``symbol``.\n\n    Si ``symbol`` no est\u00e1 presente en el archivo JSON se devuelven los valores\n    por defecto. Adem\u00e1s, se rellenan claves faltantes con ``PESOS_DEFECTO``.\n    \"\"\"\n\n    global _pesos_cache\n    if _pesos_cache is None:\n        if os.path.exists(RUTA_PESOS):\n            try:\n                with open(RUTA_PESOS, \"r\", encoding=\"utf-8\") as fh:\n                    _pesos_cache = json.load(fh)\n            except Exception as e:\n                log.warning(\n                    f\"Error leyendo {RUTA_PESOS}: {e}. Usando pesos por defecto\"\n                )\n                _pesos_cache = {}\n        else:\n            _pesos_cache = {}\n\n    datos_simbolo = _pesos_cache.get(symbol) or _pesos_cache.get(\"default\")\n    if not isinstance(datos_simbolo, dict):\n        datos_simbolo = {}\n\n    pesos = PESOS_DEFECTO.copy()\n    pesos.update(datos_simbolo)\n    return pesos\n\n\ndef cargar_pesos_tecnicos(symbol: str) -> dict:\n    \"\"\"Interfaz p\u00fablica para obtener los pesos de un s\u00edmbolo.\"\"\"\n    return _cargar_pesos(symbol)\n\n\ndef evaluar_puntaje_tecnico(symbol: str, df: pd.DataFrame, precio: float, sl: float, tp: float) -> dict:\n    \"\"\"Eval\u00faa condiciones t\u00e9cnicas y retorna un puntaje acumulado.\"\"\"\n    pesos = _cargar_pesos(symbol)\n    if df is None or len(df) < 30:\n        log.warning(f\"[{symbol}] datos insuficientes para score tecnico\")\n        return {\"score_total\": 0.0, \"detalles\": {}}\n\n    df = df.tail(60).copy()\n    vela = df.iloc[-1]\n    cierre = float(vela[\"close\"])\n    apertura = float(vela[\"open\"])\n    alto = float(vela[\"high\"])\n    bajo = float(vela[\"low\"])\n    cuerpo = abs(cierre - apertura)\n    rango_total = alto - bajo\n\n    rsi = calcular_rsi(df)\n    rsi_ant = calcular_rsi(df.iloc[:-1]) if len(df) > 15 else rsi\n    volumen_actual = float(vela[\"volume\"])\n    volumen_prev = float(df.iloc[-2][\"volume\"])\n    media_vol = df[\"volume\"].rolling(20).mean().iloc[-1]\n\n    detalles: dict[str, float] = {}\n    total = 0.0\n\n    def _add(clave: str, condicion: bool | None) -> None:\n        \"\"\"Suma o resta puntaje seg\u00fan ``condicion`` y registra detalles.\"\"\"\n        nonlocal total\n        peso = pesos.get(clave, 0.0)\n        if condicion is None:\n            puntos = 0.0\n        elif condicion:\n            puntos = peso\n        else:\n            puntos = -peso * 0.5\n        detalles[clave] = float(puntos)\n        total += puntos\n        if puntos < 0:\n            log.debug(f\"[{symbol}] {clave} penaliza {puntos:.2f}\")\n\n    _add(\"rsi\", rsi is not None and 40 <= rsi <= 70)\n    _add(\"volumen\", media_vol > 0 and volumen_actual > media_vol)\n    ratio = (tp - precio) / (precio - sl) if precio != sl else None\n    _add(\"tp_sl\", ratio is not None and ratio >= 1.2)\n    _add(\"no_doji\", rango_total > 0 and cuerpo / rango_total >= 0.3)\n    _add(\"no_sobrecompra\", rsi is None or rsi < 75)\n    _add(\"cuerpo_sano\", cierre > apertura and cuerpo >= 0.6 * rango_total)\n    _add(\"rsi_creciente\", rsi is not None and rsi_ant is not None and rsi > rsi_ant)\n    _add(\"volumen_creciente\", volumen_actual > volumen_prev)\n    mecha_sup = alto - max(cierre, apertura)\n    _add(\"sin_mecha_sup_larga\", mecha_sup <= 2 * cuerpo)\n    max_dia = df[\"high\"].max()\n    min_dia = df[\"low\"].min()\n    distancia_max = (max_dia - precio) / max_dia if max_dia else None\n    distancia_min = (precio - min_dia) / min_dia if min_dia else None\n    _add(\n        \"distancia_extremos\",\n        None not in (distancia_max, distancia_min)\n        and distancia_max > 0.002\n        and distancia_min > 0.002,\n    )\n\n    log.info(f\"[ENTRY ANALYSIS] {symbol}\")\n    for k, v in detalles.items():\n        signo = \"+\" if v >= 0 else \"\"\n        log.info(f\"- {k}: {'\u2705' if v > 0 else '\u274c'} ({signo}{v})\")\n    log.info(f\"- Total score: {total:.2f} / {sum(pesos.values()):.2f}\")\n\n    return {\"score_total\": round(total, 2), \"detalles\": detalles}\n\n\ndef calcular_umbral_adaptativo(score_maximo_esperado: float, tendencia: str, volatilidad: float, volumen: float, estrategias_activas: dict) -> float:\n    \"\"\"Calcula un umbral t\u00e9cnico din\u00e1mico simple.\"\"\"\n    base = score_maximo_esperado * 0.5\n    if volumen > 1:\n        base *= 0.95\n    if tendencia in {\"alcista\", \"bajista\"}:\n        base *= 0.9\n    base *= 1 + min(max(volatilidad * 5, 0.0), 0.3)\n    activos = [v for v in estrategias_activas.values() if v]\n    if activos and len(activos) < 3:\n        base *= 1.1\n    return round(base, 2)\n\n\ndef actualizar_pesos_tecnicos(symbol: str, detalles: dict, retorno: float, factor: float = 0.05) -> None:\n    \"\"\"Ajusta pesos del JSON seg\u00fan rendimiento de la operaci\u00f3n.\"\"\"\n    if not detalles:\n        return\n    pesos = _cargar_pesos(symbol)\n    modificados = False\n    for clave, puntaje in detalles.items():\n        peso_actual = pesos.get(clave, PESOS_DEFECTO.get(clave, 0.0))\n        if peso_actual <= 0:\n            continue\n        if retorno > 0 and puntaje > 0:\n            nuevo = peso_actual * (1 + factor)\n        elif retorno < 0 and puntaje > 0:\n            nuevo = peso_actual * (1 - factor)\n        else:\n            continue\n        pesos[clave] = max(0.1, round(nuevo, 3))\n        modificados = True\n    if modificados:\n        _pesos_cache[symbol] = pesos\n        try:\n            with open(RUTA_PESOS, \"w\", encoding=\"utf-8\") as fh:\n                json.dump(_pesos_cache, fh, indent=2)\n            log.info(f\"[{symbol}] Pesos tecnicos actualizados\")\n        except Exception as e:  # noqa: BLE001\n            log.warning(f\"[{symbol}] Error guardando pesos: {e}\")", "import json\nimport os\nimport pandas as pd\nfrom indicators.rsi import calcular_rsi\nfrom pegaso.core.utils.utils import configurar_logger\n\nlog = configurar_logger(\"eval_tecnico\")\n\nRUTA_PESOS = \"config/pesos_tecnicos.json\"\nPESOS_DEFECTO = {\n    \"rsi\": 1.0,\n    \"volumen\": 1.0,\n    \"tp_sl\": 0.7,\n    \"no_doji\": 0.5,\n    \"no_sobrecompra\": 1.0,\n    \"cuerpo_sano\": 1.0,\n    \"rsi_creciente\": 0.6,\n    \"volumen_creciente\": 0.5,\n    \"sin_mecha_sup_larga\": 0.4,\n    \"distancia_extremos\": 0.6,\n}\n\n_pesos_cache: dict | None = None\n\n\ndef _cargar_pesos(symbol: str) -> dict:\n    \"\"\"Devuelve los pesos t\u00e9cnicos para ``symbol``.\n\n    Si ``symbol`` no est\u00e1 presente en el archivo JSON se devuelven los valores\n    por defecto. Adem\u00e1s, se rellenan claves faltantes con ``PESOS_DEFECTO``.\n    \"\"\"\n\n    global _pesos_cache\n    if _pesos_cache is None:\n        if os.path.exists(RUTA_PESOS):\n            try:\n                with open(RUTA_PESOS, \"r\", encoding=\"utf-8\") as fh:\n                    _pesos_cache = json.load(fh)\n            except Exception as e:\n                log.warning(\n                    f\"Error leyendo {RUTA_PESOS}: {e}. Usando pesos por defecto\"\n                )\n                _pesos_cache = {}\n        else:\n            _pesos_cache = {}\n\n    datos_simbolo = _pesos_cache.get(symbol) or _pesos_cache.get(\"default\")\n    if not isinstance(datos_simbolo, dict):\n        datos_simbolo = {}\n\n    pesos = PESOS_DEFECTO.copy()\n    pesos.update(datos_simbolo)\n    return pesos\n\n\ndef cargar_pesos_tecnicos(symbol: str) -> dict:\n    \"\"\"Interfaz p\u00fablica para obtener los pesos de un s\u00edmbolo.\"\"\"\n    return _cargar_pesos(symbol)\n\n\ndef evaluar_puntaje_tecnico(symbol: str, df: pd.DataFrame, precio: float, sl: float, tp: float) -> dict:\n    \"\"\"Eval\u00faa condiciones t\u00e9cnicas y retorna un puntaje acumulado.\"\"\"\n    pesos = _cargar_pesos(symbol)\n    if df is None or len(df) < 30:\n        log.warning(f\"[{symbol}] datos insuficientes para score tecnico\")\n        return {\"score_total\": 0.0, \"detalles\": {}}\n\n    df = df.tail(60).copy()\n    vela = df.iloc[-1]\n    cierre = float(vela[\"close\"])\n    apertura = float(vela[\"open\"])\n    alto = float(vela[\"high\"])\n    bajo = float(vela[\"low\"])\n    cuerpo = abs(cierre - apertura)\n    rango_total = alto - bajo\n\n    rsi = calcular_rsi(df)\n    rsi_ant = calcular_rsi(df.iloc[:-1]) if len(df) > 15 else rsi\n    volumen_actual = float(vela[\"volume\"])\n    volumen_prev = float(df.iloc[-2][\"volume\"])\n    media_vol = df[\"volume\"].rolling(20).mean().iloc[-1]\n\n    detalles: dict[str, float] = {}\n    total = 0.0\n\n    def _add(clave: str, condicion: bool | None) -> None:\n        \"\"\"Suma o resta puntaje seg\u00fan ``condicion`` y registra detalles.\"\"\"\n        nonlocal total\n        peso = pesos.get(clave, 0.0)\n        if condicion is None:\n            puntos = 0.0\n        elif condicion:\n            puntos = peso\n        else:\n            puntos = -peso * 0.5\n        detalles[clave] = float(puntos)\n        total += puntos\n        if puntos < 0:\n            log.debug(f\"[{symbol}] {clave} penaliza {puntos:.2f}\")\n\n    _add(\"rsi\", rsi is not None and 40 <= rsi <= 70)\n    _add(\"volumen\", media_vol > 0 and volumen_actual > media_vol)\n    ratio = (tp - precio) / (precio - sl) if precio != sl else None\n    _add(\"tp_sl\", ratio is not None and ratio >= 1.2)\n    _add(\"no_doji\", rango_total > 0 and cuerpo / rango_total >= 0.3)\n    _add(\"no_sobrecompra\", rsi is None or rsi < 75)\n    _add(\"cuerpo_sano\", cierre > apertura and cuerpo >= 0.6 * rango_total)\n    _add(\"rsi_creciente\", rsi is not None and rsi_ant is not None and rsi > rsi_ant)\n    _add(\"volumen_creciente\", volumen_actual > volumen_prev)\n    mecha_sup = alto - max(cierre, apertura)\n    _add(\"sin_mecha_sup_larga\", mecha_sup <= 2 * cuerpo)\n    max_dia = df[\"high\"].max()\n    min_dia = df[\"low\"].min()\n    distancia_max = (max_dia - precio) / max_dia if max_dia else None\n    distancia_min = (precio - min_dia) / min_dia if min_dia else None\n    _add(\n        \"distancia_extremos\",\n        None not in (distancia_max, distancia_min)\n        and distancia_max > 0.002\n        and distancia_min > 0.002,\n    )\n\n    log.info(f\"[ENTRY ANALYSIS] {symbol}\")\n    for k, v in detalles.items():\n        signo = \"+\" if v >= 0 else \"\"\n        log.info(f\"- {k}: {'\u2705' if v > 0 else '\u274c'} ({signo}{v})\")\n    log.info(f\"- Total score: {total:.2f} / {sum(pesos.values()):.2f}\")\n\n    return {\"score_total\": round(total, 2), \"detalles\": detalles}\n\n\ndef calcular_umbral_adaptativo(score_maximo_esperado: float, tendencia: str, volatilidad: float, volumen: float, estrategias_activas: dict) -> float:\n    \"\"\"Calcula un umbral t\u00e9cnico din\u00e1mico simple.\"\"\"\n    base = score_maximo_esperado * 0.5\n    if volumen > 1:\n        base *= 0.95\n    if tendencia in {\"alcista\", \"bajista\"}:\n        base *= 0.9\n    base *= 1 + min(max(volatilidad * 5, 0.0), 0.3)\n    activos = [v for v in estrategias_activas.values() if v]\n    if activos and len(activos) < 3:\n        base *= 1.1\n    return round(base, 2)\n\n\ndef actualizar_pesos_tecnicos(symbol: str, detalles: dict, retorno: float, factor: float = 0.05) -> None:\n    \"\"\"Ajusta pesos del JSON seg\u00fan rendimiento de la operaci\u00f3n.\"\"\"\n    if not detalles:\n        return\n    pesos = _cargar_pesos(symbol)\n    modificados = False\n    for clave, puntaje in detalles.items():\n        peso_actual = pesos.get(clave, PESOS_DEFECTO.get(clave, 0.0))\n        if peso_actual <= 0:\n            continue\n        if retorno > 0 and puntaje > 0:\n            nuevo = peso_actual * (1 + factor)\n        elif retorno < 0 and puntaje > 0:\n            nuevo = peso_actual * (1 - factor)\n        else:\n            continue\n        pesos[clave] = max(0.1, round(nuevo, 3))\n        modificados = True\n    if modificados:\n        _pesos_cache[symbol] = pesos\n        try:\n            with open(RUTA_PESOS, \"w\", encoding=\"utf-8\") as fh:\n                json.dump(_pesos_cache, fh, indent=2)\n            log.info(f\"[{symbol}] Pesos tecnicos actualizados\")\n        except Exception as e:  # noqa: BLE001\n            log.warning(f\"[{symbol}] Error guardando pesos: {e}\")"]]], 1750727260.4587715]], ["ChangeSet", ["Writing file <core/strategies/pesos.py>", [["ChangeContents", ["core/strategies/pesos.py", "import json\nimport os\nfrom dataclasses import dataclass, field\nfrom typing import Dict, Optional\nimport pandas as pd\nfrom collections import defaultdict\n\nfrom core.utils.utils import configurar_logger\n\nlog = configurar_logger(\"pesos\")\n\n# -----------------------------------------------------------\n# Funci\u00f3n utilitaria para normalizar pesos\n# -----------------------------------------------------------\ndef normalizar_pesos(\n    pesos_actuales: Dict[str, float],\n    total: float = 100,\n    peso_min: float = 0.5,\n    factor_temporal: Optional[float] = None,\n) -> Dict[str, float]:\n    \"\"\"Normaliza los pesos, respetando un m\u00ednimo y aplicando factor temporal si se indica.\"\"\"\n\n    pesos_temporales = {\n        estrategia: valor * factor_temporal if factor_temporal else valor\n        for estrategia, valor in pesos_actuales.items()\n    }\n\n    pesos_min = {\n        estrategia: max(valor, peso_min)\n        for estrategia, valor in pesos_temporales.items()\n    }\n\n    suma_actual = sum(pesos_min.values())\n    if suma_actual == 0:\n        return {estrategia: 0.0 for estrategia in pesos_min}\n\n    factor = total / suma_actual\n    return {\n        estrategia: round(valor * factor, 4) for estrategia, valor in pesos_min.items()\n    }\n\n\n# -----------------------------------------------------------\n# Clase principal de gesti\u00f3n\n# -----------------------------------------------------------\n@dataclass\nclass GestorPesos:\n    \"\"\"Maneja la carga, almacenamiento y c\u00e1lculo de pesos por estrategia.\"\"\"\n    ruta: str = \"config/estrategias_pesos.json\"\n    pesos: Dict[str, Dict[str, float]] = field(init=False, default_factory=dict)\n\n    def __post_init__(self) -> None:\n        self.pesos = self._cargar_pesos()\n\n    def _cargar_pesos(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"Carga pesos desde JSON validando el formato y repara si es necesario.\"\"\"\n        if not os.path.exists(self.ruta):\n            log.error(f\"\u274c No se encontr\u00f3 archivo de pesos: {self.ruta}\")\n            raise ValueError(\"Archivo de pesos inexistente\")\n\n        try:\n            with open(self.ruta, \"r\") as f:\n                datos = json.load(f)\n        except json.JSONDecodeError as e:\n            log.error(f\"\u274c Error cargando pesos desde JSON: {e}\")\n            datos = self._restaurar_desde_base()\n        if not isinstance(datos, dict) or not datos:\n            raise ValueError(\"\u274c Archivo de pesos inv\u00e1lido o vac\u00edo.\")\n        return datos\n\n    def _restaurar_desde_base(self) -> dict:\n        \"\"\"Restaura pesos desde una copia base.\"\"\"\n        ruta_base = \"config/estrategias_pesos_base.json\"\n        if not os.path.exists(ruta_base):\n            raise ValueError(\"No hay copia base para recuperar pesos\")\n\n        with open(ruta_base, \"r\") as base:\n            datos = json.load(base)\n        with open(self.ruta, \"w\") as reparado:\n            json.dump(datos, reparado, indent=4)\n        log.info(\"\ud83d\udd04 Pesos restaurados desde copia base\")\n        return datos\n\n    def guardar(self, pesos: Dict[str, Dict[str, float]]) -> None:\n        \"\"\"Guarda los pesos actualizados en disco.\"\"\"\n        try:\n            with open(self.ruta, \"w\") as f:\n                json.dump(pesos, f, indent=4)\n            self.pesos = pesos\n            log.info(\"\u2705 Pesos guardados.\")\n        except Exception as e:\n            log.error(f\"\u274c Error al guardar pesos: {e}\")\n\n    def obtener_peso(self, estrategia: str, symbol: str) -> float:\n        return self.pesos.get(symbol, {}).get(estrategia, 0.0)\n\n    def obtener_pesos_symbol(self, symbol: str) -> Dict[str, float]:\n        return self.pesos.get(symbol, {})\n\n    def calcular_desde_backtest(\n        self, simbolos, carpeta=\"backtesting\", escala=20\n    ) -> None:\n        \"\"\"Recalcula pesos desde los CSV de \u00f3rdenes ganadoras por s\u00edmbolo.\"\"\"\n        pesos_por_symbol = {}\n\n        for symbol in simbolos:\n            ruta = f\"{carpeta}/ordenes_{symbol.replace('/', '_')}_resultado.csv\"\n            if not os.path.exists(ruta):\n                log.warning(f\"\u274c Archivo no encontrado: {ruta}\")\n                continue\n\n            try:\n                df = pd.read_csv(ruta)\n            except pd.errors.EmptyDataError:\n                log.warning(f\"\u26a0\ufe0f Archivo vac\u00edo: {ruta}\")\n                continue\n\n            conteo = defaultdict(int)\n            for _, fila in df.iterrows():\n                if fila.get(\"resultado\") != \"ganancia\":\n                    continue\n                try:\n                    estrategias = json.loads(\n                        fila[\"estrategias_activas\"].replace(\"'\", '\"')\n                    )\n                    for estrategia, activa in estrategias.items():\n                        if activa:\n                            conteo[estrategia] += 1\n                except Exception as e:\n                    log.warning(f\"\u26a0\ufe0f Estrategia mal formateada: {e}\")\n                    continue\n\n            total = sum(conteo.values())\n            if total == 0:\n                continue\n\n            normalizados = {\n                k: round(v / total * 10, 2) for k, v in conteo.items()\n            }\n\n            suma_actual = sum(normalizados.values())\n            factor = escala / suma_actual if suma_actual > 0 else 1.0\n            reescalados = {\n                k: round(v * factor, 2) for k, v in normalizados.items()\n            }\n\n            pesos_por_symbol[symbol] = reescalados\n            log.info(f\"\ud83d\udcca {symbol}: {reescalados}\")\n\n        self.guardar(pesos_por_symbol)\n\n# -----------------------------------------------------------\n# Gesti\u00f3n de pesos de salida\n# -----------------------------------------------------------\n@dataclass\nclass GestorPesosSalidas:\n    \"\"\"Maneja la carga de pesos para estrategias de salida.\"\"\"\n    ruta: str = \"config/pesos_salidas.json\"\n    pesos: Dict[str, Dict[str, float]] = field(init=False, default_factory=dict)\n\n    def __post_init__(self) -> None:\n        self.pesos = self._cargar_pesos()\n\n    def _cargar_pesos(self) -> Dict[str, Dict[str, float]]:\n        if not os.path.exists(self.ruta):\n            log.error(f\"\u274c No se encontr\u00f3 archivo de pesos: {self.ruta}\")\n            raise ValueError(\"Archivo de pesos inexistente\")\n        try:\n            with open(self.ruta, \"r\") as fh:\n                datos = json.load(fh)\n        except json.JSONDecodeError as e:\n            log.error(f\"\u274c Error cargando pesos de salida: {e}\")\n            datos = {}\n        if not isinstance(datos, dict):\n            raise ValueError(\"\u274c Archivo de pesos de salida inv\u00e1lido\")\n        return datos\n\n    def obtener(self, razon: str, symbol: str) -> float:\n        return self.pesos.get(symbol, {}).get(razon, 0.0)\n\n\n# -----------------------------------------------------------\n# Inicializaci\u00f3n autom\u00e1tica\n# -----------------------------------------------------------\ntry:\n    gestor_pesos = GestorPesos()\n    gestor_pesos_salidas = GestorPesosSalidas()\nexcept ValueError as e:\n    log.error(e)\n    raise\n\n\n# Funci\u00f3n p\u00fablica para acceder desde otros m\u00f3dulos\ndef cargar_pesos_estrategias() -> Dict[str, Dict[str, float]]:\n    return GestorPesos().pesos\n\ndef obtener_peso_salida(razon: str, symbol: str) -> float:\n    \"\"\"Devuelve el peso de una estrategia de salida para el s\u00edmbolo dado.\"\"\"\n    try:\n        return gestor_pesos_salidas.obtener(razon, symbol)\n    except Exception:\n        return 0.0\n", "import json\nimport os\nfrom dataclasses import dataclass, field\nfrom typing import Dict, Optional\nimport pandas as pd\nfrom collections import defaultdict\n\nfrom pegaso.core.utils.utils import configurar_logger\n\nlog = configurar_logger(\"pesos\")\n\n# -----------------------------------------------------------\n# Funci\u00f3n utilitaria para normalizar pesos\n# -----------------------------------------------------------\ndef normalizar_pesos(\n    pesos_actuales: Dict[str, float],\n    total: float = 100,\n    peso_min: float = 0.5,\n    factor_temporal: Optional[float] = None,\n) -> Dict[str, float]:\n    \"\"\"Normaliza los pesos, respetando un m\u00ednimo y aplicando factor temporal si se indica.\"\"\"\n\n    pesos_temporales = {\n        estrategia: valor * factor_temporal if factor_temporal else valor\n        for estrategia, valor in pesos_actuales.items()\n    }\n\n    pesos_min = {\n        estrategia: max(valor, peso_min)\n        for estrategia, valor in pesos_temporales.items()\n    }\n\n    suma_actual = sum(pesos_min.values())\n    if suma_actual == 0:\n        return {estrategia: 0.0 for estrategia in pesos_min}\n\n    factor = total / suma_actual\n    return {\n        estrategia: round(valor * factor, 4) for estrategia, valor in pesos_min.items()\n    }\n\n\n# -----------------------------------------------------------\n# Clase principal de gesti\u00f3n\n# -----------------------------------------------------------\n@dataclass\nclass GestorPesos:\n    \"\"\"Maneja la carga, almacenamiento y c\u00e1lculo de pesos por estrategia.\"\"\"\n    ruta: str = \"config/estrategias_pesos.json\"\n    pesos: Dict[str, Dict[str, float]] = field(init=False, default_factory=dict)\n\n    def __post_init__(self) -> None:\n        self.pesos = self._cargar_pesos()\n\n    def _cargar_pesos(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"Carga pesos desde JSON validando el formato y repara si es necesario.\"\"\"\n        if not os.path.exists(self.ruta):\n            log.error(f\"\u274c No se encontr\u00f3 archivo de pesos: {self.ruta}\")\n            raise ValueError(\"Archivo de pesos inexistente\")\n\n        try:\n            with open(self.ruta, \"r\") as f:\n                datos = json.load(f)\n        except json.JSONDecodeError as e:\n            log.error(f\"\u274c Error cargando pesos desde JSON: {e}\")\n            datos = self._restaurar_desde_base()\n        if not isinstance(datos, dict) or not datos:\n            raise ValueError(\"\u274c Archivo de pesos inv\u00e1lido o vac\u00edo.\")\n        return datos\n\n    def _restaurar_desde_base(self) -> dict:\n        \"\"\"Restaura pesos desde una copia base.\"\"\"\n        ruta_base = \"config/estrategias_pesos_base.json\"\n        if not os.path.exists(ruta_base):\n            raise ValueError(\"No hay copia base para recuperar pesos\")\n\n        with open(ruta_base, \"r\") as base:\n            datos = json.load(base)\n        with open(self.ruta, \"w\") as reparado:\n            json.dump(datos, reparado, indent=4)\n        log.info(\"\ud83d\udd04 Pesos restaurados desde copia base\")\n        return datos\n\n    def guardar(self, pesos: Dict[str, Dict[str, float]]) -> None:\n        \"\"\"Guarda los pesos actualizados en disco.\"\"\"\n        try:\n            with open(self.ruta, \"w\") as f:\n                json.dump(pesos, f, indent=4)\n            self.pesos = pesos\n            log.info(\"\u2705 Pesos guardados.\")\n        except Exception as e:\n            log.error(f\"\u274c Error al guardar pesos: {e}\")\n\n    def obtener_peso(self, estrategia: str, symbol: str) -> float:\n        return self.pesos.get(symbol, {}).get(estrategia, 0.0)\n\n    def obtener_pesos_symbol(self, symbol: str) -> Dict[str, float]:\n        return self.pesos.get(symbol, {})\n\n    def calcular_desde_backtest(\n        self, simbolos, carpeta=\"backtesting\", escala=20\n    ) -> None:\n        \"\"\"Recalcula pesos desde los CSV de \u00f3rdenes ganadoras por s\u00edmbolo.\"\"\"\n        pesos_por_symbol = {}\n\n        for symbol in simbolos:\n            ruta = f\"{carpeta}/ordenes_{symbol.replace('/', '_')}_resultado.csv\"\n            if not os.path.exists(ruta):\n                log.warning(f\"\u274c Archivo no encontrado: {ruta}\")\n                continue\n\n            try:\n                df = pd.read_csv(ruta)\n            except pd.errors.EmptyDataError:\n                log.warning(f\"\u26a0\ufe0f Archivo vac\u00edo: {ruta}\")\n                continue\n\n            conteo = defaultdict(int)\n            for _, fila in df.iterrows():\n                if fila.get(\"resultado\") != \"ganancia\":\n                    continue\n                try:\n                    estrategias = json.loads(\n                        fila[\"estrategias_activas\"].replace(\"'\", '\"')\n                    )\n                    for estrategia, activa in estrategias.items():\n                        if activa:\n                            conteo[estrategia] += 1\n                except Exception as e:\n                    log.warning(f\"\u26a0\ufe0f Estrategia mal formateada: {e}\")\n                    continue\n\n            total = sum(conteo.values())\n            if total == 0:\n                continue\n\n            normalizados = {\n                k: round(v / total * 10, 2) for k, v in conteo.items()\n            }\n\n            suma_actual = sum(normalizados.values())\n            factor = escala / suma_actual if suma_actual > 0 else 1.0\n            reescalados = {\n                k: round(v * factor, 2) for k, v in normalizados.items()\n            }\n\n            pesos_por_symbol[symbol] = reescalados\n            log.info(f\"\ud83d\udcca {symbol}: {reescalados}\")\n\n        self.guardar(pesos_por_symbol)\n\n# -----------------------------------------------------------\n# Gesti\u00f3n de pesos de salida\n# -----------------------------------------------------------\n@dataclass\nclass GestorPesosSalidas:\n    \"\"\"Maneja la carga de pesos para estrategias de salida.\"\"\"\n    ruta: str = \"config/pesos_salidas.json\"\n    pesos: Dict[str, Dict[str, float]] = field(init=False, default_factory=dict)\n\n    def __post_init__(self) -> None:\n        self.pesos = self._cargar_pesos()\n\n    def _cargar_pesos(self) -> Dict[str, Dict[str, float]]:\n        if not os.path.exists(self.ruta):\n            log.error(f\"\u274c No se encontr\u00f3 archivo de pesos: {self.ruta}\")\n            raise ValueError(\"Archivo de pesos inexistente\")\n        try:\n            with open(self.ruta, \"r\") as fh:\n                datos = json.load(fh)\n        except json.JSONDecodeError as e:\n            log.error(f\"\u274c Error cargando pesos de salida: {e}\")\n            datos = {}\n        if not isinstance(datos, dict):\n            raise ValueError(\"\u274c Archivo de pesos de salida inv\u00e1lido\")\n        return datos\n\n    def obtener(self, razon: str, symbol: str) -> float:\n        return self.pesos.get(symbol, {}).get(razon, 0.0)\n\n\n# -----------------------------------------------------------\n# Inicializaci\u00f3n autom\u00e1tica\n# -----------------------------------------------------------\ntry:\n    gestor_pesos = GestorPesos()\n    gestor_pesos_salidas = GestorPesosSalidas()\nexcept ValueError as e:\n    log.error(e)\n    raise\n\n\n# Funci\u00f3n p\u00fablica para acceder desde otros m\u00f3dulos\ndef cargar_pesos_estrategias() -> Dict[str, Dict[str, float]]:\n    return GestorPesos().pesos\n\ndef obtener_peso_salida(razon: str, symbol: str) -> float:\n    \"\"\"Devuelve el peso de una estrategia de salida para el s\u00edmbolo dado.\"\"\"\n    try:\n        return gestor_pesos_salidas.obtener(razon, symbol)\n    except Exception:\n        return 0.0\n"]]], 1750727260.4779382]], ["ChangeSet", ["Writing file <core/strategies/entry/analisis_previo.py>", [["ChangeContents", ["core/strategies/entry/analisis_previo.py", "import pandas as pd\nfrom core.utils.utils import configurar_logger\nfrom indicators.rsi import calcular_rsi\n\n# Umbrales configurables\nUMBRAL_PERDIDA_DIA = -0.02  # -2%\nUMBRAL_CERCANIA_EXTREMO = 0.003  # 0.3%\nUMBRAL_CUERPO_DOJI = 0.3  # cuerpo < 30% del rango total\nUMBRAL_RSI_BAJO = 35\nUMBRAL_CUERPO_ALCISTA = 0.6\n\nlog = configurar_logger(\"analisis_previo\")\n\ndef validar_condiciones_tecnicas_extra(symbol: str, datos: pd.DataFrame, precio: float, sl: float, tp: float) -> bool:\n    if datos is None or len(datos) < 30:\n        log.warning(f\"[{symbol}] Datos insuficientes para validaci\u00f3n previa.\")\n        return False\n\n    datos = datos.tail(60).copy()\n    vela = datos.iloc[-1]\n    cierre = float(vela[\"close\"])\n    apertura = float(vela[\"open\"])\n    alto = float(vela[\"high\"])\n    bajo = float(vela[\"low\"])\n    volumen_actual = float(vela[\"volume\"])\n    cuerpo = abs(cierre - apertura)\n    rango_total = alto - bajo\n\n    rsi = calcular_rsi(datos)\n    cambio_diario_pct = ((cierre - datos[\"close\"].iloc[-2]) / datos[\"close\"].iloc[-2]) * 100\n    tp_sl_ratio = (tp - precio) / (precio - sl) if sl != precio else 999\n\n    max_dia = datos[\"high\"].max()\n    min_dia = datos[\"low\"].min()\n    media_vol = datos[\"volume\"].rolling(20).mean().iloc[-1]\n    ema12 = datos[\"close\"].ewm(span=12).mean().iloc[-1]\n    ema26 = datos[\"close\"].ewm(span=26).mean().iloc[-1]\n\n    # \u274c Precio demasiado cerca del m\u00e1ximo del d\u00eda\n    if (max_dia - precio) / max_dia < 0.002:\n        log.info(f\"\u274c {symbol} muy cerca del m\u00e1ximo. Precio: {precio:.2f}, M\u00e1ximo: {max_dia:.2f}\")\n        return False\n\n    # \u274c Precio muy cerca del m\u00ednimo y vela no es alcista\n    if (precio - min_dia) / min_dia < 0.002 and cierre <= apertura:\n        log.info(f\"\u274c {symbol} muy cerca del m\u00ednimo diario sin reversi\u00f3n. Precio: {precio:.2f}, M\u00ednimo: {min_dia:.2f}\")\n        return False\n\n    # \u274c Vela tipo Doji o indecisi\u00f3n\n    if cuerpo / rango_total < 0.2:\n        log.info(f\"\u274c {symbol} vela de indecisi\u00f3n detectada (Doji). Cuerpo/Rango: {cuerpo:.2f}/{rango_total:.2f}\")\n        return False\n\n    # \u274c Relaci\u00f3n TP/SL desfavorable\n    if tp_sl_ratio < 1.2:\n        log.info(f\"\u274c {symbol} relaci\u00f3n TP/SL desfavorable. TP: {tp}, SL: {sl}, Ratio: {tp_sl_ratio:.2f}\")\n        return False\n\n    # \u274c P\u00e9rdida diaria significativa (>2%)\n    if cambio_diario_pct < -2:\n        log.info(f\"\u274c {symbol} ca\u00edda diaria del {cambio_diario_pct:.2f}%. No es buen momento para entrar.\")\n        return False\n\n    # \u274c Volumen decreciente con cierre por encima de apertura\n    if cierre > apertura and volumen_actual < datos[\"volume\"].iloc[-2]:\n        log.info(f\"\u274c {symbol} volumen decreciente con cierre alcista. Riesgo de falso rompimiento.\")\n        return False\n\n    # \u274c Volumen actual muy bajo respecto a la media\n    if volumen_actual < 0.6 * media_vol:\n        log.info(f\"\u274c {symbol} volumen muy bajo ({volumen_actual:.2f} vs media {media_vol:.2f})\")\n        return False\n\n    # \u274c RSI en sobrecompra\n    if rsi is not None and rsi > 75:\n        log.info(f\"\u274c {symbol} RSI demasiado alto ({rsi:.2f}). Riesgo de sobrecompra.\")\n        return False\n\n    # \u274c Cruce de medias bajista (EMA12 < EMA26)\n    if ema12 < ema26:\n        log.info(f\"\u274c {symbol} EMA12 ({ema12:.2f}) < EMA26 ({ema26:.2f}). No hay tendencia alcista clara.\")\n        return False\n\n    # \u274c Mecha superior larga (rechazo de precios altos)\n    mecha_sup = alto - max(cierre, apertura)\n    if mecha_sup > 2 * cuerpo:\n        log.info(f\"\u274c {symbol} mecha superior larga. Rechazo de precios altos. Mecha: {mecha_sup:.2f}, Cuerpo: {cuerpo:.2f}\")\n        return False\n\n    # \u2705 Confirmaci\u00f3n de volumen en vela verde fuerte\n    if cierre > apertura and cuerpo > 0.6 * rango_total:\n        if volumen_actual < media_vol:\n            log.info(f\"\u274c {symbol} sin volumen suficiente en vela fuerte. Volumen: {volumen_actual:.2f} < Media: {media_vol:.2f}\")\n            return False\n\n    return True", "import pandas as pd\nfrom pegaso.core.utils.utils import configurar_logger\nfrom indicators.rsi import calcular_rsi\n\n# Umbrales configurables\nUMBRAL_PERDIDA_DIA = -0.02  # -2%\nUMBRAL_CERCANIA_EXTREMO = 0.003  # 0.3%\nUMBRAL_CUERPO_DOJI = 0.3  # cuerpo < 30% del rango total\nUMBRAL_RSI_BAJO = 35\nUMBRAL_CUERPO_ALCISTA = 0.6\n\nlog = configurar_logger(\"analisis_previo\")\n\ndef validar_condiciones_tecnicas_extra(symbol: str, datos: pd.DataFrame, precio: float, sl: float, tp: float) -> bool:\n    if datos is None or len(datos) < 30:\n        log.warning(f\"[{symbol}] Datos insuficientes para validaci\u00f3n previa.\")\n        return False\n\n    datos = datos.tail(60).copy()\n    vela = datos.iloc[-1]\n    cierre = float(vela[\"close\"])\n    apertura = float(vela[\"open\"])\n    alto = float(vela[\"high\"])\n    bajo = float(vela[\"low\"])\n    volumen_actual = float(vela[\"volume\"])\n    cuerpo = abs(cierre - apertura)\n    rango_total = alto - bajo\n\n    rsi = calcular_rsi(datos)\n    cambio_diario_pct = ((cierre - datos[\"close\"].iloc[-2]) / datos[\"close\"].iloc[-2]) * 100\n    tp_sl_ratio = (tp - precio) / (precio - sl) if sl != precio else 999\n\n    max_dia = datos[\"high\"].max()\n    min_dia = datos[\"low\"].min()\n    media_vol = datos[\"volume\"].rolling(20).mean().iloc[-1]\n    ema12 = datos[\"close\"].ewm(span=12).mean().iloc[-1]\n    ema26 = datos[\"close\"].ewm(span=26).mean().iloc[-1]\n\n    # \u274c Precio demasiado cerca del m\u00e1ximo del d\u00eda\n    if (max_dia - precio) / max_dia < 0.002:\n        log.info(f\"\u274c {symbol} muy cerca del m\u00e1ximo. Precio: {precio:.2f}, M\u00e1ximo: {max_dia:.2f}\")\n        return False\n\n    # \u274c Precio muy cerca del m\u00ednimo y vela no es alcista\n    if (precio - min_dia) / min_dia < 0.002 and cierre <= apertura:\n        log.info(f\"\u274c {symbol} muy cerca del m\u00ednimo diario sin reversi\u00f3n. Precio: {precio:.2f}, M\u00ednimo: {min_dia:.2f}\")\n        return False\n\n    # \u274c Vela tipo Doji o indecisi\u00f3n\n    if cuerpo / rango_total < 0.2:\n        log.info(f\"\u274c {symbol} vela de indecisi\u00f3n detectada (Doji). Cuerpo/Rango: {cuerpo:.2f}/{rango_total:.2f}\")\n        return False\n\n    # \u274c Relaci\u00f3n TP/SL desfavorable\n    if tp_sl_ratio < 1.2:\n        log.info(f\"\u274c {symbol} relaci\u00f3n TP/SL desfavorable. TP: {tp}, SL: {sl}, Ratio: {tp_sl_ratio:.2f}\")\n        return False\n\n    # \u274c P\u00e9rdida diaria significativa (>2%)\n    if cambio_diario_pct < -2:\n        log.info(f\"\u274c {symbol} ca\u00edda diaria del {cambio_diario_pct:.2f}%. No es buen momento para entrar.\")\n        return False\n\n    # \u274c Volumen decreciente con cierre por encima de apertura\n    if cierre > apertura and volumen_actual < datos[\"volume\"].iloc[-2]:\n        log.info(f\"\u274c {symbol} volumen decreciente con cierre alcista. Riesgo de falso rompimiento.\")\n        return False\n\n    # \u274c Volumen actual muy bajo respecto a la media\n    if volumen_actual < 0.6 * media_vol:\n        log.info(f\"\u274c {symbol} volumen muy bajo ({volumen_actual:.2f} vs media {media_vol:.2f})\")\n        return False\n\n    # \u274c RSI en sobrecompra\n    if rsi is not None and rsi > 75:\n        log.info(f\"\u274c {symbol} RSI demasiado alto ({rsi:.2f}). Riesgo de sobrecompra.\")\n        return False\n\n    # \u274c Cruce de medias bajista (EMA12 < EMA26)\n    if ema12 < ema26:\n        log.info(f\"\u274c {symbol} EMA12 ({ema12:.2f}) < EMA26 ({ema26:.2f}). No hay tendencia alcista clara.\")\n        return False\n\n    # \u274c Mecha superior larga (rechazo de precios altos)\n    mecha_sup = alto - max(cierre, apertura)\n    if mecha_sup > 2 * cuerpo:\n        log.info(f\"\u274c {symbol} mecha superior larga. Rechazo de precios altos. Mecha: {mecha_sup:.2f}, Cuerpo: {cuerpo:.2f}\")\n        return False\n\n    # \u2705 Confirmaci\u00f3n de volumen en vela verde fuerte\n    if cierre > apertura and cuerpo > 0.6 * rango_total:\n        if volumen_actual < media_vol:\n            log.info(f\"\u274c {symbol} sin volumen suficiente en vela fuerte. Volumen: {volumen_actual:.2f} < Media: {media_vol:.2f}\")\n            return False\n\n    return True"]]], 1750727260.4983988]], ["ChangeSet", ["Writing file <core/strategies/entry/gestor_entradas.py>", [["ChangeContents", ["core/strategies/entry/gestor_entradas.py", "\"\"\"Gestor de estrategias de entrada.\n\nEval\u00faa las estrategias activas y calcula el score t\u00e9cnico total y la diversidad.\n\"\"\"\nfrom __future__ import annotations\n\nimport pandas as pd\nfrom core.strategies.pesos import gestor_pesos\nfrom strategies.entry.loader import cargar_estrategias\nfrom indicators.correlacion import calcular_correlacion\nfrom core.strategies.entry.validador_entradas import verificar_liquidez_orden\nfrom core.strategies.estrategias import (\n    obtener_estrategias_por_tendencia,\n    calcular_sinergia,\n)\nfrom core.strategies.score_tecnico import calcular_score_tecnico\nfrom core.utils import configurar_logger\n\nlog = configurar_logger(\"entradas\")\n\n\n_FUNCIONES = cargar_estrategias()\n\ndef evaluar_estrategias(symbol: str, df: pd.DataFrame, tendencia: str) -> dict:\n    \"\"\"Eval\u00faa las estrategias correspondientes a ``tendencia``\n    Retorna un diccionario con puntaje_total, estrategias_activas y diversidad.\n    \"\"\"\n    global _FUNCIONES\n    if not _FUNCIONES:\n        _FUNCIONES = cargar_estrategias()\n\n    nombres = obtener_estrategias_por_tendencia(tendencia)\n    activas: dict[str, bool] = {}\n    puntaje_total = 0.0\n\n    for nombre in nombres:\n        func = _FUNCIONES.get(nombre)\n        if not callable(func):\n            log.warning(f\"Estrategia no encontrada: {nombre}\")\n            continue\n\n        try:\n            resultado = func(df)\n            activo = bool(resultado.get(\"activo\")) if isinstance(resultado, dict) else False\n        except Exception as exc:  # noqa: BLE001\n            log.warning(f\"Error ejecutando {nombre}: {exc}\")\n            activo = False\n        activas[nombre] = activo\n        if activo:\n            puntaje_total += gestor_pesos.obtener_peso(nombre, symbol)\n\n    diversidad = sum(1 for a in activas.values() if a)\n    sinergia = calcular_sinergia(activas, tendencia)\n    \n\n    return {\n        \"puntaje_total\": round(puntaje_total, 2),\n        \"estrategias_activas\": activas,\n        \"diversidad\": diversidad,\n        \"sinergia\": sinergia,\n    }\n\n\ndef _validar_correlacion(symbol: str, df: pd.DataFrame, df_ref: pd.DataFrame, umbral: float) -> bool:\n    if df is not None and df_ref is not None and umbral < 1.0:\n        correlacion = calcular_correlacion(df, df_ref)\n        if correlacion is not None and correlacion >= umbral:\n            log.info(\n                f\"\ud83d\udeab [{symbol}] Rechazo por correlaci\u00f3n {correlacion:.2f} >= {umbral}\"\n            )\n            return False\n    return True\n\n\ndef _validar_diversidad(symbol: str, estrategias: dict) -> bool:\n    activas = sum(1 for v in estrategias.values() if v)\n    if activas <= 0:\n        log.info(f\"\ud83d\udeab [{symbol}] Rechazo por falta de estrategias activas\")\n        return False\n    return True\n\n\ndef _validar_score(symbol: str, potencia: float, umbral: float) -> bool:\n    if potencia < umbral:\n        log.info(\n            f\"\ud83d\udeab [{symbol}] Rechazo por score {potencia:.2f} < {umbral:.2f}\"\n        )\n        return False\n    return True\n\n\ndef _validar_volumen(symbol: str, df: pd.DataFrame, cantidad: float) -> bool:\n    if df is not None and cantidad > 0:\n        if not verificar_liquidez_orden(df, cantidad):\n            log.info(\n                f\"\ud83d\udeab [{symbol}] Rechazo por volumen insuficiente para {cantidad}\"\n            )\n            return False\n    return True\n\n\ndef entrada_permitida(\n    symbol: str,\n    potencia: float,\n    umbral: float,\n    estrategias_activas: dict,\n    rsi: float,\n    slope: float,\n    momentum: float,\n    df=None,\n    direccion: str = \"long\",\n    cantidad: float = 0.0,\n    df_referencia=None,\n    umbral_correlacion: float = 0.9,\n    tendencia: str | None = None,\n    score: float | None = None,\n    persistencia: float = 0.0,\n    persistencia_minima: float = 0.0,\n) -> bool:\n    \"\"\"Versi\u00f3n simplificada usada en las pruebas unitarias.\"\"\"\n    score_tecnico = score if score is not None else calcular_score_tecnico(\n        df if df is not None else pd.DataFrame(),\n        rsi,\n        momentum,\n        slope,\n        tendencia or \"lateral\",\n    )\n    potencia_ajustada = potencia * (1 + score_tecnico / 3)\n\n    if not _validar_correlacion(symbol, df, df_referencia, umbral_correlacion):\n        return False\n    if not _validar_diversidad(symbol, estrategias_activas):\n        return False\n    if not _validar_score(symbol, potencia_ajustada, umbral):\n        return False\n    if not _validar_volumen(symbol, df, cantidad):\n        return False\n    return True\n\n\n\n\n\n", "\"\"\"Gestor de estrategias de entrada.\n\nEval\u00faa las estrategias activas y calcula el score t\u00e9cnico total y la diversidad.\n\"\"\"\nfrom __future__ import annotations\n\nimport pandas as pd\nfrom core.strategies.pesos import gestor_pesos\nfrom strategies.entry.loader import cargar_estrategias\nfrom indicators.correlacion import calcular_correlacion\nfrom pegaso.core.strategies.entry.validador_entradas import verificar_liquidez_orden\nfrom core.strategies.estrategias import (\n    obtener_estrategias_por_tendencia,\n    calcular_sinergia,\n)\nfrom core.strategies.score_tecnico import calcular_score_tecnico\nfrom core.utils import configurar_logger\n\nlog = configurar_logger(\"entradas\")\n\n\n_FUNCIONES = cargar_estrategias()\n\ndef evaluar_estrategias(symbol: str, df: pd.DataFrame, tendencia: str) -> dict:\n    \"\"\"Eval\u00faa las estrategias correspondientes a ``tendencia``\n    Retorna un diccionario con puntaje_total, estrategias_activas y diversidad.\n    \"\"\"\n    global _FUNCIONES\n    if not _FUNCIONES:\n        _FUNCIONES = cargar_estrategias()\n\n    nombres = obtener_estrategias_por_tendencia(tendencia)\n    activas: dict[str, bool] = {}\n    puntaje_total = 0.0\n\n    for nombre in nombres:\n        func = _FUNCIONES.get(nombre)\n        if not callable(func):\n            log.warning(f\"Estrategia no encontrada: {nombre}\")\n            continue\n\n        try:\n            resultado = func(df)\n            activo = bool(resultado.get(\"activo\")) if isinstance(resultado, dict) else False\n        except Exception as exc:  # noqa: BLE001\n            log.warning(f\"Error ejecutando {nombre}: {exc}\")\n            activo = False\n        activas[nombre] = activo\n        if activo:\n            puntaje_total += gestor_pesos.obtener_peso(nombre, symbol)\n\n    diversidad = sum(1 for a in activas.values() if a)\n    sinergia = calcular_sinergia(activas, tendencia)\n    \n\n    return {\n        \"puntaje_total\": round(puntaje_total, 2),\n        \"estrategias_activas\": activas,\n        \"diversidad\": diversidad,\n        \"sinergia\": sinergia,\n    }\n\n\ndef _validar_correlacion(symbol: str, df: pd.DataFrame, df_ref: pd.DataFrame, umbral: float) -> bool:\n    if df is not None and df_ref is not None and umbral < 1.0:\n        correlacion = calcular_correlacion(df, df_ref)\n        if correlacion is not None and correlacion >= umbral:\n            log.info(\n                f\"\ud83d\udeab [{symbol}] Rechazo por correlaci\u00f3n {correlacion:.2f} >= {umbral}\"\n            )\n            return False\n    return True\n\n\ndef _validar_diversidad(symbol: str, estrategias: dict) -> bool:\n    activas = sum(1 for v in estrategias.values() if v)\n    if activas <= 0:\n        log.info(f\"\ud83d\udeab [{symbol}] Rechazo por falta de estrategias activas\")\n        return False\n    return True\n\n\ndef _validar_score(symbol: str, potencia: float, umbral: float) -> bool:\n    if potencia < umbral:\n        log.info(\n            f\"\ud83d\udeab [{symbol}] Rechazo por score {potencia:.2f} < {umbral:.2f}\"\n        )\n        return False\n    return True\n\n\ndef _validar_volumen(symbol: str, df: pd.DataFrame, cantidad: float) -> bool:\n    if df is not None and cantidad > 0:\n        if not verificar_liquidez_orden(df, cantidad):\n            log.info(\n                f\"\ud83d\udeab [{symbol}] Rechazo por volumen insuficiente para {cantidad}\"\n            )\n            return False\n    return True\n\n\ndef entrada_permitida(\n    symbol: str,\n    potencia: float,\n    umbral: float,\n    estrategias_activas: dict,\n    rsi: float,\n    slope: float,\n    momentum: float,\n    df=None,\n    direccion: str = \"long\",\n    cantidad: float = 0.0,\n    df_referencia=None,\n    umbral_correlacion: float = 0.9,\n    tendencia: str | None = None,\n    score: float | None = None,\n    persistencia: float = 0.0,\n    persistencia_minima: float = 0.0,\n) -> bool:\n    \"\"\"Versi\u00f3n simplificada usada en las pruebas unitarias.\"\"\"\n    score_tecnico = score if score is not None else calcular_score_tecnico(\n        df if df is not None else pd.DataFrame(),\n        rsi,\n        momentum,\n        slope,\n        tendencia or \"lateral\",\n    )\n    potencia_ajustada = potencia * (1 + score_tecnico / 3)\n\n    if not _validar_correlacion(symbol, df, df_referencia, umbral_correlacion):\n        return False\n    if not _validar_diversidad(symbol, estrategias_activas):\n        return False\n    if not _validar_score(symbol, potencia_ajustada, umbral):\n        return False\n    if not _validar_volumen(symbol, df, cantidad):\n        return False\n    return True\n\n\n\n\n\n"]]], 1750727260.5450053]], ["ChangeSet", ["Writing file <core/strategies/entry/verificar_entradas.py>", [["ChangeContents", ["core/strategies/entry/verificar_entradas.py", "from __future__ import annotations\n\nfrom datetime import datetime\nimport pandas as pd\n\nfrom core.utils import configurar_logger\nfrom core.adaptador_dinamico import calcular_umbral_adaptativo, calcular_tp_sl_adaptativos\nfrom core.adaptador_dinamico import adaptar_configuracion as adaptar_configuracion_base\nfrom core.adaptador_configuracion_dinamica import adaptar_configuracion\nfrom core.data import coincidencia_parcial\nfrom core.strategies import filtrar_por_direccion\nfrom core.strategies import detectar_tendencia\nfrom core.strategies import (\n    evaluar_puntaje_tecnico,\n    calc_umbral_tecnico,\n    cargar_pesos_tecnicos,\n)\nfrom indicators.rsi import calcular_rsi\nfrom indicators.momentum import calcular_momentum\nfrom indicators.slope import calcular_slope\nfrom core.utils.utils import distancia_minima_valida\n\nlog = configurar_logger(\"verificar_entrada\")\n\nasync def verificar_entrada(trader, symbol: str, df: pd.DataFrame, estado) -> dict | None:\n    \"\"\"Eval\u00faa las condiciones de entrada y devuelve info de la operaci\u00f3n.\"\"\"\n    config_actual = trader.config_por_simbolo.get(symbol, {})\n    dinamica = adaptar_configuracion(symbol, df)\n    if dinamica:\n        config_actual.update(dinamica)\n    config_actual = adaptar_configuracion_base(symbol, df, config_actual)\n    trader.config_por_simbolo[symbol] = config_actual\n\n    tendencia_actual = trader.estado_tendencia.get(symbol)\n    if not tendencia_actual:\n        tendencia_actual, _ = detectar_tendencia(symbol, df)\n        trader.estado_tendencia[symbol] = tendencia_actual\n    log.debug(f\"[{symbol}] Tendencia detectada: {tendencia_actual}\")\n\n    evaluacion = trader.engine.evaluar_entrada(\n        symbol,\n        df,\n        tendencia=tendencia_actual,\n        config=config_actual,\n        pesos_symbol=trader.pesos_por_simbolo.get(symbol, {}),\n    )\n    estrategias = evaluacion.get(\"estrategias_activas\", {})\n    log.debug(f\"[{symbol}] Estrategias iniciales desde engine: {estrategias}\")\n    if not estrategias:\n        log.warning(f\"\u26a0\ufe0f [{symbol}] Sin estrategias activas tras evaluaci\u00f3n. Tendencia detectada previamente.\")\n    else:\n        log.info(f\"\ud83e\uddea [{symbol}] Estrategias activas: {list(estrategias.keys())}\")\n\n    estado.buffer[-1][\"estrategias_activas\"] = estrategias\n    trader.persistencia.actualizar(symbol, estrategias)\n\n    pesos_symbol = trader.pesos_por_simbolo.get(symbol, {})\n\n    if len(estado.buffer) < 30:\n        persistencia = coincidencia_parcial(estado.buffer, pesos_symbol, ventanas=5)\n        log.debug(f\"[{symbol}] Persistencia parcial (buffer corto): {persistencia:.2f}\")\n        if persistencia < 1:\n            return None\n\n    persistencia_score = coincidencia_parcial(estado.buffer, pesos_symbol, ventanas=5)\n    umbral = calcular_umbral_adaptativo(\n        symbol,\n        df,\n        estrategias,\n        pesos_symbol,\n        persistencia=persistencia_score,\n    )\n\n    estrategias_persistentes = {\n        e: True for e, act in estrategias.items() if act and trader.persistencia.es_persistente(symbol, e)\n    }\n    log.debug(f\"[{symbol}] Estrategias persistentes: {estrategias_persistentes}\")\n\n    if not estrategias_persistentes:\n        log.warning(f\"[{symbol}] Ninguna estrategia pas\u00f3 el filtro de persistencia.\")\n        return None\n\n    direccion = \"short\" if tendencia_actual == \"bajista\" else \"long\"\n    estrategias_persistentes, incoherentes = filtrar_por_direccion(estrategias_persistentes, direccion)\n    log.debug(f\"[{symbol}] Despu\u00e9s del filtro por direcci\u00f3n ({direccion}): {estrategias_persistentes}\")\n    log.debug(f\"[{symbol}] Estrategias incoherentes: {incoherentes}\")\n\n    if not estrategias_persistentes:\n        log.warning(f\"[{symbol}] Estrategias incoherentes con la direcci\u00f3n {direccion}.\")\n        return None\n\n    penalizacion = 0.05 * (len(incoherentes) ** 2) if incoherentes else 0.0\n    puntaje = sum(pesos_symbol.get(k, 0) for k in estrategias_persistentes)\n    puntaje += trader.persistencia.peso_extra * len(estrategias_persistentes)\n    puntaje -= penalizacion\n    estado.ultimo_umbral = umbral\n\n    cierre = trader.historial_cierres.get(symbol)\n    if cierre:\n        motivo = cierre.get(\"motivo\")\n        if motivo == \"stop loss\":\n            cooldown_velas = int(config_actual.get(\"cooldown_tras_perdida\", 5))\n            velas = cierre.get(\"velas\", 0)\n            if velas < cooldown_velas:\n                cierre[\"velas\"] = velas + 1\n                restante = cooldown_velas - velas\n                log.info(f\"\ud83d\udd52 [{symbol}] Cooldown activo por stop loss. Quedan {restante} velas.\")\n                return None\n            else:\n                trader.historial_cierres.pop(symbol, None)\n        elif motivo == \"cambio de tendencia\":\n            precio_actual = float(df[\"close\"].iloc[-1])\n            if not trader._validar_reentrada_tendencia(symbol, df, cierre, precio_actual):\n                cierre[\"velas\"] = cierre.get(\"velas\", 0) + 1\n                log.info(f\"\ud83d\udeab [{symbol}] Reentrada bloqueada por cambio de tendencia.\")\n                return None\n            else:\n                trader.historial_cierres.pop(symbol, None)\n    registro = cierre or {}\n    fecha_hoy = datetime.utcnow().date().isoformat()\n    if registro.get(\"fecha_perdidas\") == fecha_hoy and registro.get(\"perdidas_consecutivas\", 0) >= 6:\n        log.info(f\"\ud83d\udeab [{symbol}] Bloqueo por p\u00e9rdidas consecutivas en el d\u00eda.\")\n        return None\n\n    estrategias_activas = {\n        e: pesos_symbol.get(e, 0.0) for e in estrategias_persistentes\n    }\n    peso_total = sum(estrategias_activas.values())\n    peso_min_total = config_actual.get(\"peso_minimo_total\", 0.5)\n    diversidad_min = config_actual.get(\"diversidad_minima\", 2)\n    persistencia = coincidencia_parcial(estado.buffer, pesos_symbol, ventanas=5)\n\n    log.info(\n        f\"\ud83d\udcca [{symbol}] Puntaje: {puntaje:.2f}, Umbral: {umbral:.2f}, Peso total: {peso_total:.2f}, \"\n        f\"Persistencia: {persistencia:.2f}, Estrategias activas: {estrategias_activas}\"\n    )\n    razones: list[str] = []\n\n    if not trader._validar_puntaje(\n        symbol,\n        puntaje,\n        umbral,\n        config_actual.get(\"modo_agresivo\", False),\n    ):\n        razones.append(\"puntaje\")\n\n    if not await trader._validar_diversidad(\n        symbol,\n        peso_total,\n        peso_min_total,\n        estrategias_activas,\n        diversidad_min,\n        pesos_symbol,\n        df,\n        config_actual.get(\"modo_agresivo\", False),\n    ):\n        razones.append(\"diversidad\")\n\n    if not trader._validar_estrategia(symbol, df, estrategias):\n        razones.append(\"estrategia\")\n\n    ok_pers, valor_pers, minimo_pers = trader._evaluar_persistencia(\n        symbol, estado, df, pesos_symbol, tendencia_actual, puntaje, umbral, estrategias\n    )\n    if not ok_pers:\n        razones.append(\"persistencia\")\n\n    if razones:\n        agresivo = config_actual.get(\"modo_agresivo\", False)\n        if not agresivo or len(razones) > 2:\n            log.info(f\"\u274c [{symbol}] Rechazo acumulado por: {razones}\")\n            return None\n\n    rsi = calcular_rsi(df)\n    momentum = calcular_momentum(df)\n    slope = calcular_slope(df)\n    precio_actual = float(df[\"close\"].iloc[-1])\n    cantidad_simulada = await trader._calcular_cantidad_async(symbol, precio_actual)\n\n    if trader.usar_score_tecnico:\n        score_tecnico, puntos = trader._calcular_score_tecnico(\n            df, rsi, momentum, tendencia_actual, direccion\n        )\n        log.debug(f\"[{symbol}] Score t\u00e9cnico: {score_tecnico:.2f}, Componentes: {puntos}\")\n\n    if puntaje < umbral or not estrategias_persistentes:\n        log.info(f\"\u274c [{symbol}] Filtro t\u00e9cnico final bloque\u00f3 la entrada.\")\n        return None\n\n    log.info(f\"\u2705 [{symbol}] Se\u00f1al de entrada generada con {len(estrategias_activas)} estrategias.\")\n    precio = precio_actual\n    sl, tp = calcular_tp_sl_adaptativos(\n        symbol,\n        df,\n        config_actual,\n        trader.capital_por_simbolo.get(symbol, 0),\n        precio,\n    )\n\n    if not distancia_minima_valida(precio, sl, tp):\n        log.warning(\n            f\"\ud83d\udccf [{symbol}] Distancia SL/TP insuficiente. SL: {sl:.2f} TP: {tp:.2f}\"\n        )\n        return None\n\n    evaluacion = evaluar_puntaje_tecnico(symbol, df, precio, sl, tp)\n    score_total = evaluacion[\"score_total\"]\n    vol = 0.0\n    if \"volume\" in df.columns and len(df) > 20:\n        vol = df[\"volume\"].iloc[-1] / (df[\"volume\"].rolling(20).mean().iloc[-1] or 1)\n    volatilidad = df[\"close\"].pct_change().tail(20).std()\n    pesos_simbolo = cargar_pesos_tecnicos(symbol)\n    score_max = sum(pesos_simbolo.values())\n    umbral_tecnico = calc_umbral_tecnico(\n        score_max,\n        tendencia_actual,\n        volatilidad,\n        vol,\n        estrategias_persistentes,\n    )\n    log.info(\n        f\"- Umbral adaptativo: {umbral_tecnico:.2f} \u2192 {'\u2705' if score_total >= umbral_tecnico else '\u274c'} Entrada permitida\"\n    )\n    if score_total < umbral_tecnico:\n        log.info(f\"[{symbol}] Entrada rechazada por score t\u00e9cnico {score_total:.2f} < {umbral_tecnico:.2f}\")\n        return None\n\n    return {\n        \"symbol\": symbol,\n        \"precio\": precio,\n        \"sl\": sl,\n        \"tp\": tp,\n        \"estrategias\": estrategias_activas,\n        \"puntaje\": puntaje,\n        \"umbral\": umbral,\n        \"tendencia\": tendencia_actual,\n        \"direccion\": direccion,\n        \"score_tecnico\": score_tecnico if trader.usar_score_tecnico else None,\n        \"detalles_tecnicos\": evaluacion.get(\"detalles\", {}),\n    }", "from __future__ import annotations\n\nfrom datetime import datetime\nimport pandas as pd\n\nfrom core.utils import configurar_logger\nfrom core.adaptador_dinamico import calcular_umbral_adaptativo, calcular_tp_sl_adaptativos\nfrom core.adaptador_dinamico import adaptar_configuracion as adaptar_configuracion_base\nfrom core.adaptador_configuracion_dinamica import adaptar_configuracion\nfrom core.data import coincidencia_parcial\nfrom core.strategies import filtrar_por_direccion\nfrom core.strategies import detectar_tendencia\nfrom core.strategies import (\n    evaluar_puntaje_tecnico,\n    calc_umbral_tecnico,\n    cargar_pesos_tecnicos,\n)\nfrom indicators.rsi import calcular_rsi\nfrom indicators.momentum import calcular_momentum\nfrom indicators.slope import calcular_slope\nfrom pegaso.core.utils.utils import distancia_minima_valida\n\nlog = configurar_logger(\"verificar_entrada\")\n\nasync def verificar_entrada(trader, symbol: str, df: pd.DataFrame, estado) -> dict | None:\n    \"\"\"Eval\u00faa las condiciones de entrada y devuelve info de la operaci\u00f3n.\"\"\"\n    config_actual = trader.config_por_simbolo.get(symbol, {})\n    dinamica = adaptar_configuracion(symbol, df)\n    if dinamica:\n        config_actual.update(dinamica)\n    config_actual = adaptar_configuracion_base(symbol, df, config_actual)\n    trader.config_por_simbolo[symbol] = config_actual\n\n    tendencia_actual = trader.estado_tendencia.get(symbol)\n    if not tendencia_actual:\n        tendencia_actual, _ = detectar_tendencia(symbol, df)\n        trader.estado_tendencia[symbol] = tendencia_actual\n    log.debug(f\"[{symbol}] Tendencia detectada: {tendencia_actual}\")\n\n    evaluacion = trader.engine.evaluar_entrada(\n        symbol,\n        df,\n        tendencia=tendencia_actual,\n        config=config_actual,\n        pesos_symbol=trader.pesos_por_simbolo.get(symbol, {}),\n    )\n    estrategias = evaluacion.get(\"estrategias_activas\", {})\n    log.debug(f\"[{symbol}] Estrategias iniciales desde engine: {estrategias}\")\n    if not estrategias:\n        log.warning(f\"\u26a0\ufe0f [{symbol}] Sin estrategias activas tras evaluaci\u00f3n. Tendencia detectada previamente.\")\n    else:\n        log.info(f\"\ud83e\uddea [{symbol}] Estrategias activas: {list(estrategias.keys())}\")\n\n    estado.buffer[-1][\"estrategias_activas\"] = estrategias\n    trader.persistencia.actualizar(symbol, estrategias)\n\n    pesos_symbol = trader.pesos_por_simbolo.get(symbol, {})\n\n    if len(estado.buffer) < 30:\n        persistencia = coincidencia_parcial(estado.buffer, pesos_symbol, ventanas=5)\n        log.debug(f\"[{symbol}] Persistencia parcial (buffer corto): {persistencia:.2f}\")\n        if persistencia < 1:\n            return None\n\n    persistencia_score = coincidencia_parcial(estado.buffer, pesos_symbol, ventanas=5)\n    umbral = calcular_umbral_adaptativo(\n        symbol,\n        df,\n        estrategias,\n        pesos_symbol,\n        persistencia=persistencia_score,\n    )\n\n    estrategias_persistentes = {\n        e: True for e, act in estrategias.items() if act and trader.persistencia.es_persistente(symbol, e)\n    }\n    log.debug(f\"[{symbol}] Estrategias persistentes: {estrategias_persistentes}\")\n\n    if not estrategias_persistentes:\n        log.warning(f\"[{symbol}] Ninguna estrategia pas\u00f3 el filtro de persistencia.\")\n        return None\n\n    direccion = \"short\" if tendencia_actual == \"bajista\" else \"long\"\n    estrategias_persistentes, incoherentes = filtrar_por_direccion(estrategias_persistentes, direccion)\n    log.debug(f\"[{symbol}] Despu\u00e9s del filtro por direcci\u00f3n ({direccion}): {estrategias_persistentes}\")\n    log.debug(f\"[{symbol}] Estrategias incoherentes: {incoherentes}\")\n\n    if not estrategias_persistentes:\n        log.warning(f\"[{symbol}] Estrategias incoherentes con la direcci\u00f3n {direccion}.\")\n        return None\n\n    penalizacion = 0.05 * (len(incoherentes) ** 2) if incoherentes else 0.0\n    puntaje = sum(pesos_symbol.get(k, 0) for k in estrategias_persistentes)\n    puntaje += trader.persistencia.peso_extra * len(estrategias_persistentes)\n    puntaje -= penalizacion\n    estado.ultimo_umbral = umbral\n\n    cierre = trader.historial_cierres.get(symbol)\n    if cierre:\n        motivo = cierre.get(\"motivo\")\n        if motivo == \"stop loss\":\n            cooldown_velas = int(config_actual.get(\"cooldown_tras_perdida\", 5))\n            velas = cierre.get(\"velas\", 0)\n            if velas < cooldown_velas:\n                cierre[\"velas\"] = velas + 1\n                restante = cooldown_velas - velas\n                log.info(f\"\ud83d\udd52 [{symbol}] Cooldown activo por stop loss. Quedan {restante} velas.\")\n                return None\n            else:\n                trader.historial_cierres.pop(symbol, None)\n        elif motivo == \"cambio de tendencia\":\n            precio_actual = float(df[\"close\"].iloc[-1])\n            if not trader._validar_reentrada_tendencia(symbol, df, cierre, precio_actual):\n                cierre[\"velas\"] = cierre.get(\"velas\", 0) + 1\n                log.info(f\"\ud83d\udeab [{symbol}] Reentrada bloqueada por cambio de tendencia.\")\n                return None\n            else:\n                trader.historial_cierres.pop(symbol, None)\n    registro = cierre or {}\n    fecha_hoy = datetime.utcnow().date().isoformat()\n    if registro.get(\"fecha_perdidas\") == fecha_hoy and registro.get(\"perdidas_consecutivas\", 0) >= 6:\n        log.info(f\"\ud83d\udeab [{symbol}] Bloqueo por p\u00e9rdidas consecutivas en el d\u00eda.\")\n        return None\n\n    estrategias_activas = {\n        e: pesos_symbol.get(e, 0.0) for e in estrategias_persistentes\n    }\n    peso_total = sum(estrategias_activas.values())\n    peso_min_total = config_actual.get(\"peso_minimo_total\", 0.5)\n    diversidad_min = config_actual.get(\"diversidad_minima\", 2)\n    persistencia = coincidencia_parcial(estado.buffer, pesos_symbol, ventanas=5)\n\n    log.info(\n        f\"\ud83d\udcca [{symbol}] Puntaje: {puntaje:.2f}, Umbral: {umbral:.2f}, Peso total: {peso_total:.2f}, \"\n        f\"Persistencia: {persistencia:.2f}, Estrategias activas: {estrategias_activas}\"\n    )\n    razones: list[str] = []\n\n    if not trader._validar_puntaje(\n        symbol,\n        puntaje,\n        umbral,\n        config_actual.get(\"modo_agresivo\", False),\n    ):\n        razones.append(\"puntaje\")\n\n    if not await trader._validar_diversidad(\n        symbol,\n        peso_total,\n        peso_min_total,\n        estrategias_activas,\n        diversidad_min,\n        pesos_symbol,\n        df,\n        config_actual.get(\"modo_agresivo\", False),\n    ):\n        razones.append(\"diversidad\")\n\n    if not trader._validar_estrategia(symbol, df, estrategias):\n        razones.append(\"estrategia\")\n\n    ok_pers, valor_pers, minimo_pers = trader._evaluar_persistencia(\n        symbol, estado, df, pesos_symbol, tendencia_actual, puntaje, umbral, estrategias\n    )\n    if not ok_pers:\n        razones.append(\"persistencia\")\n\n    if razones:\n        agresivo = config_actual.get(\"modo_agresivo\", False)\n        if not agresivo or len(razones) > 2:\n            log.info(f\"\u274c [{symbol}] Rechazo acumulado por: {razones}\")\n            return None\n\n    rsi = calcular_rsi(df)\n    momentum = calcular_momentum(df)\n    slope = calcular_slope(df)\n    precio_actual = float(df[\"close\"].iloc[-1])\n    cantidad_simulada = await trader._calcular_cantidad_async(symbol, precio_actual)\n\n    if trader.usar_score_tecnico:\n        score_tecnico, puntos = trader._calcular_score_tecnico(\n            df, rsi, momentum, tendencia_actual, direccion\n        )\n        log.debug(f\"[{symbol}] Score t\u00e9cnico: {score_tecnico:.2f}, Componentes: {puntos}\")\n\n    if puntaje < umbral or not estrategias_persistentes:\n        log.info(f\"\u274c [{symbol}] Filtro t\u00e9cnico final bloque\u00f3 la entrada.\")\n        return None\n\n    log.info(f\"\u2705 [{symbol}] Se\u00f1al de entrada generada con {len(estrategias_activas)} estrategias.\")\n    precio = precio_actual\n    sl, tp = calcular_tp_sl_adaptativos(\n        symbol,\n        df,\n        config_actual,\n        trader.capital_por_simbolo.get(symbol, 0),\n        precio,\n    )\n\n    if not distancia_minima_valida(precio, sl, tp):\n        log.warning(\n            f\"\ud83d\udccf [{symbol}] Distancia SL/TP insuficiente. SL: {sl:.2f} TP: {tp:.2f}\"\n        )\n        return None\n\n    evaluacion = evaluar_puntaje_tecnico(symbol, df, precio, sl, tp)\n    score_total = evaluacion[\"score_total\"]\n    vol = 0.0\n    if \"volume\" in df.columns and len(df) > 20:\n        vol = df[\"volume\"].iloc[-1] / (df[\"volume\"].rolling(20).mean().iloc[-1] or 1)\n    volatilidad = df[\"close\"].pct_change().tail(20).std()\n    pesos_simbolo = cargar_pesos_tecnicos(symbol)\n    score_max = sum(pesos_simbolo.values())\n    umbral_tecnico = calc_umbral_tecnico(\n        score_max,\n        tendencia_actual,\n        volatilidad,\n        vol,\n        estrategias_persistentes,\n    )\n    log.info(\n        f\"- Umbral adaptativo: {umbral_tecnico:.2f} \u2192 {'\u2705' if score_total >= umbral_tecnico else '\u274c'} Entrada permitida\"\n    )\n    if score_total < umbral_tecnico:\n        log.info(f\"[{symbol}] Entrada rechazada por score t\u00e9cnico {score_total:.2f} < {umbral_tecnico:.2f}\")\n        return None\n\n    return {\n        \"symbol\": symbol,\n        \"precio\": precio,\n        \"sl\": sl,\n        \"tp\": tp,\n        \"estrategias\": estrategias_activas,\n        \"puntaje\": puntaje,\n        \"umbral\": umbral,\n        \"tendencia\": tendencia_actual,\n        \"direccion\": direccion,\n        \"score_tecnico\": score_tecnico if trader.usar_score_tecnico else None,\n        \"detalles_tecnicos\": evaluacion.get(\"detalles\", {}),\n    }"]]], 1750727260.729854]], ["ChangeSet", ["Writing file <core/strategies/exit/gestor_salidas.py>", [["ChangeContents", ["core/strategies/exit/gestor_salidas.py", "# estrategias_salida/gestor_salidas.py\nimport pandas as pd\nimport inspect\nfrom core.utils.utils import validar_dataframe\nfrom core.strategies.tendencia import detectar_tendencia\nfrom strategies.entry.gestor_entradas import evaluar_estrategias\nfrom core.adaptador_dinamico import calcular_umbral_adaptativo\nfrom core.adaptador_umbral import calcular_umbral_salida_adaptativo\nfrom core.strategies.pesos import obtener_peso_salida\nfrom core.utils import configurar_logger\n\nlog = configurar_logger(\"gestor_salidas\")\n\nfrom strategies.exit.loader_salidas import cargar_estrategias_salida\n\ndef evaluar_salidas(orden: dict, df, config=None, contexto=None):\n    symbol = orden.get(\"symbol\", \"SYM\")\n    if not validar_dataframe(df, [\"close\", \"high\", \"low\", \"volume\"]):\n        log.warning(f\"[{symbol}] DataFrame inv\u00e1lido para gestor de salidas\")\n        return {\"cerrar\": False, \"razon\": \"Datos insuficientes\"}\n        \n    funciones = cargar_estrategias_salida()\n    resultados = []\n    PRIORIDAD_ABSOLUTA = {\"Stop Loss\", \"Estrategia: Cambio de tendencia\"}\n\n    for f in funciones:\n        if not callable(f):\n            continue  # Evita errores por strings u objetos incorrectos\n\n        try:\n            params = list(inspect.signature(f).parameters.keys())\n            if \"symbol\" in params and \"orden\" in params and \"config\" in params:\n                resultado = f(symbol, orden, df, config=config)\n            elif \"symbol\" in params and \"orden\" in params:\n                resultado = f(symbol, orden, df)\n            elif \"symbol\" in params and \"config\" in params:\n                resultado = f(symbol, df, config=config)\n            elif \"symbol\" in params:\n                resultado = f(symbol, df)\n            elif \"orden\" in params and \"config\" in params:\n                resultado = f(orden, df, config=config)\n            elif \"orden\" in params:\n                resultado = f(orden, df)\n            elif \"config\" in params:\n                resultado = f(df, config=config)\n            else:\n                resultado = f(df)\n        except Exception as e:\n            log.warning(f\"\u274c Error ejecutando estrategia de salida: {f} \u2192 {e}\")\n            continue\n\n        if resultado.get(\"cerrar\", False):\n            evento = resultado.get(\"evento\", resultado.get(\"razon\", \"Sin motivo\"))\n            razon = resultado.get(\"razon\", \"Sin motivo\")\n            if evento in PRIORIDAD_ABSOLUTA:\n                log.info(f\"[{symbol}] Cierre prioritario por {evento}\")\n                return {\"cerrar\": True, \"razon\": evento}\n            resultados.append(evento)\n\n    peso_total = sum(obtener_peso_salida(razon, symbol) for razon in resultados)\n    umbral = calcular_umbral_salida_adaptativo(symbol, config or {}, contexto)\n    min_conf = (config or {}).get(\"min_confirmaciones_salida\", 1)\n    log.info(\n        f\"[SALIDA] {symbol} | Score: {peso_total:.2f} | Umbral: {umbral:.2f} | Se\u00f1ales: {resultados}\"\n    )\n    cerrar = peso_total >= umbral and len(resultados) >= min_conf\n    if cerrar:\n        razon = f\"Score {peso_total:.2f} \u2265 {umbral:.2f} con {len(resultados)} se\u00f1ales\"\n    else:\n        razon = (\n            f\"Score insuficiente {peso_total:.2f} < {umbral:.2f}\"\n            if len(resultados) >= min_conf\n            else f\"Se\u00f1ales insuficientes: {len(resultados)}/{min_conf}\"\n        )\n\n    return {\n        \"cerrar\": cerrar,\n        \"razon\": razon,\n        \"detalles\": resultados,\n        \"score\": peso_total,\n        \"umbral\": umbral,\n    }\n\ndef verificar_filtro_tecnico(symbol, df, estrategias_activas, pesos_symbol, config=None):\n    if not validar_dataframe(df, [\"high\", \"low\", \"close\"]):\n        return False\n\n    tendencia, _ = detectar_tendencia(symbol, df)\n    evaluacion = evaluar_estrategias(symbol, df, tendencia)\n    if not evaluacion:\n        return False\n\n    activas = [k for k, v in evaluacion[\"estrategias_activas\"].items() if v]\n    puntaje = evaluacion[\"puntaje_total\"]\n    umbral = calcular_umbral_adaptativo(\n        symbol,\n        df,\n        evaluacion[\"estrategias_activas\"],\n        pesos_symbol,\n        persistencia=0.0,\n        config=config,\n    )\n\n    return len(activas) >= 1 and puntaje >= 0.4 * umbral\n\n\n", "# estrategias_salida/gestor_salidas.py\nimport pandas as pd\nimport inspect\nfrom pegaso.core.utils.utils import validar_dataframe\nfrom core.strategies.tendencia import detectar_tendencia\nfrom strategies.entry.gestor_entradas import evaluar_estrategias\nfrom core.adaptador_dinamico import calcular_umbral_adaptativo\nfrom core.adaptador_umbral import calcular_umbral_salida_adaptativo\nfrom core.strategies.pesos import obtener_peso_salida\nfrom core.utils import configurar_logger\n\nlog = configurar_logger(\"gestor_salidas\")\n\nfrom strategies.exit.loader_salidas import cargar_estrategias_salida\n\ndef evaluar_salidas(orden: dict, df, config=None, contexto=None):\n    symbol = orden.get(\"symbol\", \"SYM\")\n    if not validar_dataframe(df, [\"close\", \"high\", \"low\", \"volume\"]):\n        log.warning(f\"[{symbol}] DataFrame inv\u00e1lido para gestor de salidas\")\n        return {\"cerrar\": False, \"razon\": \"Datos insuficientes\"}\n        \n    funciones = cargar_estrategias_salida()\n    resultados = []\n    PRIORIDAD_ABSOLUTA = {\"Stop Loss\", \"Estrategia: Cambio de tendencia\"}\n\n    for f in funciones:\n        if not callable(f):\n            continue  # Evita errores por strings u objetos incorrectos\n\n        try:\n            params = list(inspect.signature(f).parameters.keys())\n            if \"symbol\" in params and \"orden\" in params and \"config\" in params:\n                resultado = f(symbol, orden, df, config=config)\n            elif \"symbol\" in params and \"orden\" in params:\n                resultado = f(symbol, orden, df)\n            elif \"symbol\" in params and \"config\" in params:\n                resultado = f(symbol, df, config=config)\n            elif \"symbol\" in params:\n                resultado = f(symbol, df)\n            elif \"orden\" in params and \"config\" in params:\n                resultado = f(orden, df, config=config)\n            elif \"orden\" in params:\n                resultado = f(orden, df)\n            elif \"config\" in params:\n                resultado = f(df, config=config)\n            else:\n                resultado = f(df)\n        except Exception as e:\n            log.warning(f\"\u274c Error ejecutando estrategia de salida: {f} \u2192 {e}\")\n            continue\n\n        if resultado.get(\"cerrar\", False):\n            evento = resultado.get(\"evento\", resultado.get(\"razon\", \"Sin motivo\"))\n            razon = resultado.get(\"razon\", \"Sin motivo\")\n            if evento in PRIORIDAD_ABSOLUTA:\n                log.info(f\"[{symbol}] Cierre prioritario por {evento}\")\n                return {\"cerrar\": True, \"razon\": evento}\n            resultados.append(evento)\n\n    peso_total = sum(obtener_peso_salida(razon, symbol) for razon in resultados)\n    umbral = calcular_umbral_salida_adaptativo(symbol, config or {}, contexto)\n    min_conf = (config or {}).get(\"min_confirmaciones_salida\", 1)\n    log.info(\n        f\"[SALIDA] {symbol} | Score: {peso_total:.2f} | Umbral: {umbral:.2f} | Se\u00f1ales: {resultados}\"\n    )\n    cerrar = peso_total >= umbral and len(resultados) >= min_conf\n    if cerrar:\n        razon = f\"Score {peso_total:.2f} \u2265 {umbral:.2f} con {len(resultados)} se\u00f1ales\"\n    else:\n        razon = (\n            f\"Score insuficiente {peso_total:.2f} < {umbral:.2f}\"\n            if len(resultados) >= min_conf\n            else f\"Se\u00f1ales insuficientes: {len(resultados)}/{min_conf}\"\n        )\n\n    return {\n        \"cerrar\": cerrar,\n        \"razon\": razon,\n        \"detalles\": resultados,\n        \"score\": peso_total,\n        \"umbral\": umbral,\n    }\n\ndef verificar_filtro_tecnico(symbol, df, estrategias_activas, pesos_symbol, config=None):\n    if not validar_dataframe(df, [\"high\", \"low\", \"close\"]):\n        return False\n\n    tendencia, _ = detectar_tendencia(symbol, df)\n    evaluacion = evaluar_estrategias(symbol, df, tendencia)\n    if not evaluacion:\n        return False\n\n    activas = [k for k, v in evaluacion[\"estrategias_activas\"].items() if v]\n    puntaje = evaluacion[\"puntaje_total\"]\n    umbral = calcular_umbral_adaptativo(\n        symbol,\n        df,\n        evaluacion[\"estrategias_activas\"],\n        pesos_symbol,\n        persistencia=0.0,\n        config=config,\n    )\n\n    return len(activas) >= 1 and puntaje >= 0.4 * umbral\n\n\n"]]], 1750727260.7506762]], ["ChangeSet", ["Writing file <core/strategies/exit/salida_por_macd.py>", [["ChangeContents", ["core/strategies/exit/salida_por_macd.py", "import pandas as pd\nfrom ta.trend import MACD\nfrom core.utils import configurar_logger\nfrom core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_por_macd\")\n\ndef salida_por_macd(orden, df: pd.DataFrame) -> dict:\n    \"\"\"\n    Cierra si MACD cruza a la baja.\n    \"\"\"\n    try:\n        if len(df) < 35:\n            return resultado_salida(\n                \"Tecnico\",\n                False,\n                \"Insuficientes datos\",\n            )\n\n        macd = MACD(close=df[\"close\"])\n        macd_line = macd.macd()\n        signal_line = macd.macd_signal()\n\n        if macd_line.iloc[-2] > signal_line.iloc[-2] and macd_line.iloc[-1] < signal_line.iloc[-1]:\n            return resultado_salida(\n                \"Tecnico\",\n                True,\n                \"Cruce bajista de MACD\",\n                logger=log,\n            )\n\n        return resultado_salida(\"Tecnico\", False, \"Sin cruce bajista de MACD\")\n\n    except Exception as e:\n        return resultado_salida(\"Tecnico\", False, f\"Error en MACD: {e}\")\n", "import pandas as pd\nfrom ta.trend import MACD\nfrom core.utils import configurar_logger\nfrom pegaso.core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_por_macd\")\n\ndef salida_por_macd(orden, df: pd.DataFrame) -> dict:\n    \"\"\"\n    Cierra si MACD cruza a la baja.\n    \"\"\"\n    try:\n        if len(df) < 35:\n            return resultado_salida(\n                \"Tecnico\",\n                False,\n                \"Insuficientes datos\",\n            )\n\n        macd = MACD(close=df[\"close\"])\n        macd_line = macd.macd()\n        signal_line = macd.macd_signal()\n\n        if macd_line.iloc[-2] > signal_line.iloc[-2] and macd_line.iloc[-1] < signal_line.iloc[-1]:\n            return resultado_salida(\n                \"Tecnico\",\n                True,\n                \"Cruce bajista de MACD\",\n                logger=log,\n            )\n\n        return resultado_salida(\"Tecnico\", False, \"Sin cruce bajista de MACD\")\n\n    except Exception as e:\n        return resultado_salida(\"Tecnico\", False, f\"Error en MACD: {e}\")\n"]]], 1750727260.768547]], ["ChangeSet", ["Writing file <core/strategies/exit/salida_por_rsi.py>", [["ChangeContents", ["core/strategies/exit/salida_por_rsi.py", "import pandas as pd\nfrom ta.momentum import RSIIndicator\nfrom ta.trend import MACD\nfrom core.utils import configurar_logger\nfrom core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_por_rsi\")\n\n\ndef salida_por_rsi(df: pd.DataFrame, umbral_bajo=30) -> dict:\n    \"\"\"\n    Cierra si RSI cae por debajo del umbral (ej: 30)\n    \"\"\"\n    if len(df) < 15:\n         return resultado_salida(\n            \"Tecnico\",\n            False,\n            \"Insuficientes datos\",\n        )\n\n    rsi = RSIIndicator(close=df[\"close\"], window=14).rsi()\n    if rsi.iloc[-1] < umbral_bajo:\n       return resultado_salida(\n            \"Tecnico\",\n            True,\n            f\"RSI bajo ({rsi.iloc[-1]:.2f}) < {umbral_bajo}\",\n            logger=log,\n        )\n\n    return resultado_salida(\"Tecnico\", False, \"RSI no bajo\")", "import pandas as pd\nfrom ta.momentum import RSIIndicator\nfrom ta.trend import MACD\nfrom core.utils import configurar_logger\nfrom pegaso.core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_por_rsi\")\n\n\ndef salida_por_rsi(df: pd.DataFrame, umbral_bajo=30) -> dict:\n    \"\"\"\n    Cierra si RSI cae por debajo del umbral (ej: 30)\n    \"\"\"\n    if len(df) < 15:\n         return resultado_salida(\n            \"Tecnico\",\n            False,\n            \"Insuficientes datos\",\n        )\n\n    rsi = RSIIndicator(close=df[\"close\"], window=14).rsi()\n    if rsi.iloc[-1] < umbral_bajo:\n       return resultado_salida(\n            \"Tecnico\",\n            True,\n            f\"RSI bajo ({rsi.iloc[-1]:.2f}) < {umbral_bajo}\",\n            logger=log,\n        )\n\n    return resultado_salida(\"Tecnico\", False, \"RSI no bajo\")"]]], 1750727260.7855844]], ["ChangeSet", ["Writing file <core/strategies/exit/salida_por_tendencia.py>", [["ChangeContents", ["core/strategies/exit/salida_por_tendencia.py", "import pandas as pd\nfrom core.utils.utils import validar_dataframe\nfrom core.strategies.tendencia import detectar_tendencia\nfrom core.utils import configurar_logger\nfrom core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_por_tendencia\")\n\ndef salida_por_tendencia(orden, df):\n    \"\"\"\n    Cierra si la tendencia cambia respecto a la entrada.\n    \"\"\"\n    tendencia_entrada = orden.get(\"tendencia\")\n    if not tendencia_entrada:\n        return resultado_salida(\n            \"Tecnico\",\n            False,\n            \"Sin tendencia previa registrada\",\n        )\n\n    try:\n        tendencia_actual, _ = detectar_tendencia(orden[\"symbol\"], df)\n        if tendencia_actual != tendencia_entrada:\n            return resultado_salida(\n                \"Tecnico\",\n                True,\n                f\"Cambio de tendencia: {tendencia_entrada} \u2192 {tendencia_actual}\",\n                logger=log,\n            )\n        else:\n            return resultado_salida(\"Tecnico\", False, \"Tendencia estable\")\n    except Exception as e:\n        return resultado_salida(\"Tecnico\", False, f\"Error evaluando tendencia: {e}\")\n    \n\ndef verificar_reversion_tendencia(symbol, df, tendencia_anterior):\n    if not validar_dataframe(df, [\"high\", \"low\", \"close\"]):\n        return False\n\n    nueva_tendencia, _ = detectar_tendencia(symbol, df)\n    return nueva_tendencia != tendencia_anterior\n\n\n", "import pandas as pd\nfrom pegaso.core.utils.utils import validar_dataframe\nfrom pegaso.core.strategies.tendencia import detectar_tendencia\nfrom core.utils import configurar_logger\nfrom pegaso.core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_por_tendencia\")\n\ndef salida_por_tendencia(orden, df):\n    \"\"\"\n    Cierra si la tendencia cambia respecto a la entrada.\n    \"\"\"\n    tendencia_entrada = orden.get(\"tendencia\")\n    if not tendencia_entrada:\n        return resultado_salida(\n            \"Tecnico\",\n            False,\n            \"Sin tendencia previa registrada\",\n        )\n\n    try:\n        tendencia_actual, _ = detectar_tendencia(orden[\"symbol\"], df)\n        if tendencia_actual != tendencia_entrada:\n            return resultado_salida(\n                \"Tecnico\",\n                True,\n                f\"Cambio de tendencia: {tendencia_entrada} \u2192 {tendencia_actual}\",\n                logger=log,\n            )\n        else:\n            return resultado_salida(\"Tecnico\", False, \"Tendencia estable\")\n    except Exception as e:\n        return resultado_salida(\"Tecnico\", False, f\"Error evaluando tendencia: {e}\")\n    \n\ndef verificar_reversion_tendencia(symbol, df, tendencia_anterior):\n    if not validar_dataframe(df, [\"high\", \"low\", \"close\"]):\n        return False\n\n    nueva_tendencia, _ = detectar_tendencia(symbol, df)\n    return nueva_tendencia != tendencia_anterior\n\n\n"]]], 1750727260.8017237]], ["ChangeSet", ["Writing file <core/strategies/exit/salida_stoploss.py>", [["ChangeContents", ["core/strategies/exit/salida_stoploss.py", "# estrategias_salida/salida_stoploss.py\n\nimport pandas as pd\n\nfrom core.strategies.tendencia import detectar_tendencia\nfrom core.strategies.estrategias import (\n    obtener_estrategias_por_tendencia,\n    ESTRATEGIAS_POR_TENDENCIA,\n)\nfrom core.utils.utils import validar_dataframe\nfrom core.adaptador_dinamico import calcular_umbral_adaptativo\nfrom strategies.entry.gestor_entradas import evaluar_estrategias\nfrom core.strategies.pesos import gestor_pesos\nfrom core.utils import configurar_logger\nfrom core.strategies.exit.salida_utils import resultado_salida\nfrom indicators.rsi import calcular_rsi\nfrom indicators.slope import calcular_slope\nfrom indicators.vwap import calcular_vwap\n\nlog = configurar_logger(\"salida_stoploss\")\n\npesos = gestor_pesos.pesos\n\ndef validar_sl_tecnico(df: pd.DataFrame, direccion: str = \"long\") -> bool:\n    \"\"\"Comprueba si existen razones t\u00e9cnicas s\u00f3lidas para ejecutar el SL.\"\"\"\n    try:\n        if not validar_dataframe(df, [\"close\"]):\n            return True\n\n        rsi = calcular_rsi(df)\n        slope = calcular_slope(df.tail(5))\n        precio = df[\"close\"].iloc[-1]\n        ma9 = df[\"close\"].rolling(window=9).mean().iloc[-1]\n        ma20 = df[\"close\"].rolling(window=20).mean().iloc[-1]\n        vwap = calcular_vwap(df)\n\n        debajo_ma = precio < ma9 and precio < ma20\n        debajo_vwap = vwap is not None and precio < vwap\n        velas_rojas = (df[\"close\"].diff().tail(5) < 0).sum()\n        persistencia = velas_rojas >= 3\n\n        if direccion in [\"long\", \"compra\"]:\n            return (\n                (rsi is not None and rsi < 40)\n                and slope < 0\n                and (debajo_vwap or debajo_ma)\n                and persistencia\n            )\n        return True\n\n    except Exception as e:\n        log.warning(f\"Error validando SL t\u00e9cnico: {e}\")\n        return True\n    \ndef salida_stoploss(orden: dict, df: pd.DataFrame, config: dict = None) -> dict:\n    \"\"\"\n    Eval\u00faa si debe cerrarse una orden cuyo precio ha tocado el SL,\n    o si puede mantenerse por razones t\u00e9cnicas justificadas.\n    \"\"\"\n    try:\n        symbol = orden.get(\"symbol\")\n        if not symbol or not validar_dataframe(df, [\"high\", \"low\", \"close\"]):\n            return resultado_salida(\n                \"Stop Loss\",\n                True,\n                \"Datos inv\u00e1lidos o s\u00edmbolo no definido\",\n                logger=log,\n            )\n\n        sl = orden.get(\"stop_loss\")\n        precio_actual = df[\"close\"].iloc[-1]\n\n        # \ud83d\uded1 Si el precio no ha tocado el SL, no se eval\u00faa nada\n        if precio_actual > sl:\n            return resultado_salida(\n                \"Stop Loss\",\n                False,\n                f\"SL no alcanzado a\u00fan (precio: {precio_actual:.2f} > SL: {sl:.2f})\",\n            )\n\n        # \u2699\ufe0f Evaluaci\u00f3n t\u00e9cnica solo si se ha tocado el SL\n        tendencia, _ = detectar_tendencia(symbol, df)\n        if not tendencia:\n            return resultado_salida(\n                \"Stop Loss\",\n                True,\n                \"Tendencia no identificada\",\n                logger=log,\n            )\n\n        evaluacion = evaluar_estrategias(symbol, df, tendencia)\n        if not evaluacion:\n            return resultado_salida(\n                \"Stop Loss\",\n                True,\n                \"Evaluaci\u00f3n de estrategias fallida\",\n                logger=log,\n            )\n\n        estrategias_activas = evaluacion.get(\"estrategias_activas\", {})\n        puntaje = evaluacion.get(\"puntaje_total\", 0)\n        activas = [k for k, v in estrategias_activas.items() if v]\n\n        # Configuraci\u00f3n personalizada\n        factor_umbral = config.get(\"factor_umbral_sl\", 0.7) if config else 0.7\n        min_estrategias_relevantes = config.get(\"min_estrategias_relevantes_sl\", 3) if config else 3\n\n        # Carga de pesos para umbral\n        pesos_symbol = pesos.get(symbol, {})\n        umbral = calcular_umbral_adaptativo(\n            symbol,\n            df,\n            estrategias_activas,\n            pesos_symbol,\n            persistencia=0.0,\n            config=config,\n        )\n\n        # Concordancia con la tendencia actual\n        esperadas = ESTRATEGIAS_POR_TENDENCIA.get(tendencia, [])\n        activas_relevantes = [e for e in activas if e in esperadas]\n\n        condiciones_validas = (\n            len(activas_relevantes) >= min_estrategias_relevantes and\n            puntaje >= factor_umbral * umbral\n        )\n\n        if condiciones_validas:\n            mensaje = (\n                f\"\ud83d\udee1\ufe0f SL evitado en {symbol} \u2192 Tendencia: {tendencia}, \"\n                f\"Estrategias activas: {activas}, Puntaje: {puntaje:.2f}/{umbral:.2f}\"\n            )\n            log.info(mensaje)\n            return resultado_salida(\n                \"Stop Loss\",\n                False,\n                \"SL evitado por validaci\u00f3n t\u00e9cnica y concordancia con tendencia\",\n            )\n\n        return resultado_salida(\n            \"Stop Loss\",\n            True,\n            \"Condiciones t\u00e9cnicas d\u00e9biles para mantener\",\n            logger=log,\n        )\n\n    except Exception as e:\n        return resultado_salida(\n            \"Stop Loss\",\n            True,\n            f\"Error interno en SL: {e}\",\n            logger=log,\n        )\n    \ndef verificar_salida_stoploss(\n    orden: dict, df: pd.DataFrame, config: dict | None = None\n) -> dict:\n    \"\"\"Determina si debe ejecutarse el Stop Loss o mantenerse la operaci\u00f3n.\"\"\"\n\n    if df is None or not isinstance(df, pd.DataFrame):\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"\u274c DataFrame no v\u00e1lido (None o tipo incorrecto)\",\n            motivo=\"\u274c DataFrame no v\u00e1lido (None o tipo incorrecto)\",\n            evitado=False,\n        )\n    if df.empty or len(df) < 15:\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"\u274c DataFrame insuficiente para evaluar SL\",\n            motivo=\"\u274c DataFrame insuficiente para evaluar SL\",\n            evitado=False,\n        )\n    if not validar_dataframe(df, [\"close\", \"high\", \"low\"]):\n         return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"Datos insuficientes\",\n            motivo=\"Datos insuficientes\",\n            evitado=False,\n        )\n    if not all(k in orden for k in [\"precio_entrada\", \"stop_loss\", \"direccion\"]):\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"\u274c Orden incompleta\",\n            motivo=\"\u274c Orden incompleta\",\n            evitado=False,\n        )\n    \n    symbol = orden.get(\"symbol\", \"SYM\")\n    \n    precio_actual = float(df[\"close\"].iloc[-1])\n    precio_entrada = orden.get(\"precio_entrada\", precio_actual)\n    direccion = orden.get(\"direccion\", \"long\")\n    precio_actual = float(df[\"close\"].iloc[-1])\n    precio_entrada = orden.get(\"precio_entrada\", precio_actual)\n    sl_config = orden.get(\"stop_loss\")\n\n    # --- Cierre inmediato por Break Even ---\n    if orden.get(\"break_even_activado\"):\n        if (\n            direccion in (\"long\", \"compra\") and precio_actual <= precio_entrada\n        ) or (\n            direccion in (\"short\", \"venta\") and precio_actual >= precio_entrada\n        ):\n            log.info(\n                f\"\ud83d\udfe2 Cierre por Break Even en {symbol} | Precio actual: {precio_actual:.2f} <= Entrada: {precio_entrada:.2f}\"\n            )\n            return {\"cerrar\": True, \"motivo\": \"Break Even\", \"evitado\": False}\n\n    # --- C\u00e1lculo din\u00e1mico del SL ---\n    atr = None\n    if df is not None and len(df) >= 20:\n        atr = (df[\"high\"].tail(20) - df[\"low\"].tail(20)).mean()\n\n    ratio = config.get(\"sl_ratio\", 1.5) if config else 1.5\n    if atr is not None:\n        sl_dinamico = (\n            precio_entrada - atr * ratio\n            if direccion in (\"long\", \"compra\")\n            else precio_entrada + atr * ratio\n        )\n        if direccion in (\"long\", \"compra\"):\n            sl_config = max(sl_config, sl_dinamico)\n        else:\n            sl_config = min(sl_config, sl_dinamico)\n\n    orden[\"stop_loss\"] = sl_config\n\n    if (direccion in (\"long\", \"compra\") and precio_actual > sl_config) or (\n        direccion in (\"short\", \"venta\") and precio_actual < sl_config\n    ):\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            f\"SL no alcanzado a\u00fan (precio: {precio_actual:.2f} vs SL: {sl_config:.2f})\",\n            motivo=f\"SL no alcanzado a\u00fan (precio: {precio_actual:.2f} vs SL: {sl_config:.2f})\",\n            evitado=False,\n        )\n\n    tendencia, _ = detectar_tendencia(symbol, df)\n    evaluacion = evaluar_estrategias(symbol, df, tendencia)\n    estrategias_activas = evaluacion.get(\"estrategias_activas\", {}) if evaluacion else {}\n    puntaje = evaluacion.get(\"puntaje_total\", 0) if evaluacion else 0\n    activas = [k for k, v in estrategias_activas.items() if v]\n\n    pesos_symbol = pesos.get(symbol, {})\n    umbral = calcular_umbral_adaptativo(\n        symbol,\n        df,\n        estrategias_activas,\n        pesos_symbol,\n        persistencia=0.0,\n        config=config,\n    )\n\n    factor_umbral = config.get(\"factor_umbral_sl\", 0.7) if config else 0.7\n    min_estrategias_relevantes = config.get(\"min_estrategias_relevantes_sl\", 3) if config else 3\n    esperadas = ESTRATEGIAS_POR_TENDENCIA.get(tendencia, [])\n    activas_relevantes = [e for e in activas if e in esperadas]\n    condiciones_validas = (\n        len(activas_relevantes) >= min_estrategias_relevantes\n        and puntaje >= factor_umbral * umbral\n    )\n\n    duracion = orden.get(\"duracion_en_velas\", 0)\n    max_velas = config.get(\"max_velas_sin_tp\", 10) if config else 10\n    intentos = len(orden.get(\"sl_evitar_info\", []))\n    max_evitar = config.get(\"max_evitar_sl\", 2) if config else 2\n\n    cerrar_forzado = validar_sl_tecnico(df, direccion) or puntaje < 0.75 * umbral or duracion >= max_velas or intentos >= max_evitar\n\n    if condiciones_validas and not cerrar_forzado:\n        log.info(\n            f\"\ud83d\udee1\ufe0f SL evitado en {symbol} | Puntaje: {puntaje:.2f}/{umbral:.2f} | Velas abiertas: {duracion}\"\n        )\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"SL tocado pero indicadores v\u00e1lidos para mantener\",\n            motivo=\"SL tocado pero indicadores v\u00e1lidos para mantener\",\n            evitado=True,\n        )\n    \n    if puntaje >= 2.5 * umbral:\n        log.info(\n            f\"\ud83d\udee1\ufe0f SL evitado por score excepcional en {symbol} \u2192 {puntaje:.2f}/{umbral:.2f}\"\n        )\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"Score t\u00e9cnico muy alto\",\n            motivo=\"Score t\u00e9cnico muy alto\",\n            evitado=True,\n        )\n\n    log.info(\n        f\"\ud83d\udd34 SL forzado en {symbol} | Score t\u00e9cnico: {puntaje:.2f}/{umbral:.2f} | Velas abiertas: {duracion}\"\n    )\n    return resultado_salida(\n        \"Stop Loss\",\n        True,\n        f\"SL forzado | Score: {puntaje:.2f}/{umbral:.2f} | Velas: {duracion}\",\n        motivo=f\"SL forzado | Score: {puntaje:.2f}/{umbral:.2f} | Velas: {duracion}\",\n        evitado=False,\n        logger=log,\n    )\n    \n\n    \n\n", "# estrategias_salida/salida_stoploss.py\n\nimport pandas as pd\n\nfrom core.strategies.tendencia import detectar_tendencia\nfrom core.strategies.estrategias import (\n    obtener_estrategias_por_tendencia,\n    ESTRATEGIAS_POR_TENDENCIA,\n)\nfrom pegaso.core.utils.utils import validar_dataframe\nfrom core.adaptador_dinamico import calcular_umbral_adaptativo\nfrom strategies.entry.gestor_entradas import evaluar_estrategias\nfrom core.strategies.pesos import gestor_pesos\nfrom core.utils import configurar_logger\nfrom pegaso.core.strategies.exit.salida_utils import resultado_salida\nfrom indicators.rsi import calcular_rsi\nfrom indicators.slope import calcular_slope\nfrom indicators.vwap import calcular_vwap\n\nlog = configurar_logger(\"salida_stoploss\")\n\npesos = gestor_pesos.pesos\n\ndef validar_sl_tecnico(df: pd.DataFrame, direccion: str = \"long\") -> bool:\n    \"\"\"Comprueba si existen razones t\u00e9cnicas s\u00f3lidas para ejecutar el SL.\"\"\"\n    try:\n        if not validar_dataframe(df, [\"close\"]):\n            return True\n\n        rsi = calcular_rsi(df)\n        slope = calcular_slope(df.tail(5))\n        precio = df[\"close\"].iloc[-1]\n        ma9 = df[\"close\"].rolling(window=9).mean().iloc[-1]\n        ma20 = df[\"close\"].rolling(window=20).mean().iloc[-1]\n        vwap = calcular_vwap(df)\n\n        debajo_ma = precio < ma9 and precio < ma20\n        debajo_vwap = vwap is not None and precio < vwap\n        velas_rojas = (df[\"close\"].diff().tail(5) < 0).sum()\n        persistencia = velas_rojas >= 3\n\n        if direccion in [\"long\", \"compra\"]:\n            return (\n                (rsi is not None and rsi < 40)\n                and slope < 0\n                and (debajo_vwap or debajo_ma)\n                and persistencia\n            )\n        return True\n\n    except Exception as e:\n        log.warning(f\"Error validando SL t\u00e9cnico: {e}\")\n        return True\n    \ndef salida_stoploss(orden: dict, df: pd.DataFrame, config: dict = None) -> dict:\n    \"\"\"\n    Eval\u00faa si debe cerrarse una orden cuyo precio ha tocado el SL,\n    o si puede mantenerse por razones t\u00e9cnicas justificadas.\n    \"\"\"\n    try:\n        symbol = orden.get(\"symbol\")\n        if not symbol or not validar_dataframe(df, [\"high\", \"low\", \"close\"]):\n            return resultado_salida(\n                \"Stop Loss\",\n                True,\n                \"Datos inv\u00e1lidos o s\u00edmbolo no definido\",\n                logger=log,\n            )\n\n        sl = orden.get(\"stop_loss\")\n        precio_actual = df[\"close\"].iloc[-1]\n\n        # \ud83d\uded1 Si el precio no ha tocado el SL, no se eval\u00faa nada\n        if precio_actual > sl:\n            return resultado_salida(\n                \"Stop Loss\",\n                False,\n                f\"SL no alcanzado a\u00fan (precio: {precio_actual:.2f} > SL: {sl:.2f})\",\n            )\n\n        # \u2699\ufe0f Evaluaci\u00f3n t\u00e9cnica solo si se ha tocado el SL\n        tendencia, _ = detectar_tendencia(symbol, df)\n        if not tendencia:\n            return resultado_salida(\n                \"Stop Loss\",\n                True,\n                \"Tendencia no identificada\",\n                logger=log,\n            )\n\n        evaluacion = evaluar_estrategias(symbol, df, tendencia)\n        if not evaluacion:\n            return resultado_salida(\n                \"Stop Loss\",\n                True,\n                \"Evaluaci\u00f3n de estrategias fallida\",\n                logger=log,\n            )\n\n        estrategias_activas = evaluacion.get(\"estrategias_activas\", {})\n        puntaje = evaluacion.get(\"puntaje_total\", 0)\n        activas = [k for k, v in estrategias_activas.items() if v]\n\n        # Configuraci\u00f3n personalizada\n        factor_umbral = config.get(\"factor_umbral_sl\", 0.7) if config else 0.7\n        min_estrategias_relevantes = config.get(\"min_estrategias_relevantes_sl\", 3) if config else 3\n\n        # Carga de pesos para umbral\n        pesos_symbol = pesos.get(symbol, {})\n        umbral = calcular_umbral_adaptativo(\n            symbol,\n            df,\n            estrategias_activas,\n            pesos_symbol,\n            persistencia=0.0,\n            config=config,\n        )\n\n        # Concordancia con la tendencia actual\n        esperadas = ESTRATEGIAS_POR_TENDENCIA.get(tendencia, [])\n        activas_relevantes = [e for e in activas if e in esperadas]\n\n        condiciones_validas = (\n            len(activas_relevantes) >= min_estrategias_relevantes and\n            puntaje >= factor_umbral * umbral\n        )\n\n        if condiciones_validas:\n            mensaje = (\n                f\"\ud83d\udee1\ufe0f SL evitado en {symbol} \u2192 Tendencia: {tendencia}, \"\n                f\"Estrategias activas: {activas}, Puntaje: {puntaje:.2f}/{umbral:.2f}\"\n            )\n            log.info(mensaje)\n            return resultado_salida(\n                \"Stop Loss\",\n                False,\n                \"SL evitado por validaci\u00f3n t\u00e9cnica y concordancia con tendencia\",\n            )\n\n        return resultado_salida(\n            \"Stop Loss\",\n            True,\n            \"Condiciones t\u00e9cnicas d\u00e9biles para mantener\",\n            logger=log,\n        )\n\n    except Exception as e:\n        return resultado_salida(\n            \"Stop Loss\",\n            True,\n            f\"Error interno en SL: {e}\",\n            logger=log,\n        )\n    \ndef verificar_salida_stoploss(\n    orden: dict, df: pd.DataFrame, config: dict | None = None\n) -> dict:\n    \"\"\"Determina si debe ejecutarse el Stop Loss o mantenerse la operaci\u00f3n.\"\"\"\n\n    if df is None or not isinstance(df, pd.DataFrame):\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"\u274c DataFrame no v\u00e1lido (None o tipo incorrecto)\",\n            motivo=\"\u274c DataFrame no v\u00e1lido (None o tipo incorrecto)\",\n            evitado=False,\n        )\n    if df.empty or len(df) < 15:\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"\u274c DataFrame insuficiente para evaluar SL\",\n            motivo=\"\u274c DataFrame insuficiente para evaluar SL\",\n            evitado=False,\n        )\n    if not validar_dataframe(df, [\"close\", \"high\", \"low\"]):\n         return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"Datos insuficientes\",\n            motivo=\"Datos insuficientes\",\n            evitado=False,\n        )\n    if not all(k in orden for k in [\"precio_entrada\", \"stop_loss\", \"direccion\"]):\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"\u274c Orden incompleta\",\n            motivo=\"\u274c Orden incompleta\",\n            evitado=False,\n        )\n    \n    symbol = orden.get(\"symbol\", \"SYM\")\n    \n    precio_actual = float(df[\"close\"].iloc[-1])\n    precio_entrada = orden.get(\"precio_entrada\", precio_actual)\n    direccion = orden.get(\"direccion\", \"long\")\n    precio_actual = float(df[\"close\"].iloc[-1])\n    precio_entrada = orden.get(\"precio_entrada\", precio_actual)\n    sl_config = orden.get(\"stop_loss\")\n\n    # --- Cierre inmediato por Break Even ---\n    if orden.get(\"break_even_activado\"):\n        if (\n            direccion in (\"long\", \"compra\") and precio_actual <= precio_entrada\n        ) or (\n            direccion in (\"short\", \"venta\") and precio_actual >= precio_entrada\n        ):\n            log.info(\n                f\"\ud83d\udfe2 Cierre por Break Even en {symbol} | Precio actual: {precio_actual:.2f} <= Entrada: {precio_entrada:.2f}\"\n            )\n            return {\"cerrar\": True, \"motivo\": \"Break Even\", \"evitado\": False}\n\n    # --- C\u00e1lculo din\u00e1mico del SL ---\n    atr = None\n    if df is not None and len(df) >= 20:\n        atr = (df[\"high\"].tail(20) - df[\"low\"].tail(20)).mean()\n\n    ratio = config.get(\"sl_ratio\", 1.5) if config else 1.5\n    if atr is not None:\n        sl_dinamico = (\n            precio_entrada - atr * ratio\n            if direccion in (\"long\", \"compra\")\n            else precio_entrada + atr * ratio\n        )\n        if direccion in (\"long\", \"compra\"):\n            sl_config = max(sl_config, sl_dinamico)\n        else:\n            sl_config = min(sl_config, sl_dinamico)\n\n    orden[\"stop_loss\"] = sl_config\n\n    if (direccion in (\"long\", \"compra\") and precio_actual > sl_config) or (\n        direccion in (\"short\", \"venta\") and precio_actual < sl_config\n    ):\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            f\"SL no alcanzado a\u00fan (precio: {precio_actual:.2f} vs SL: {sl_config:.2f})\",\n            motivo=f\"SL no alcanzado a\u00fan (precio: {precio_actual:.2f} vs SL: {sl_config:.2f})\",\n            evitado=False,\n        )\n\n    tendencia, _ = detectar_tendencia(symbol, df)\n    evaluacion = evaluar_estrategias(symbol, df, tendencia)\n    estrategias_activas = evaluacion.get(\"estrategias_activas\", {}) if evaluacion else {}\n    puntaje = evaluacion.get(\"puntaje_total\", 0) if evaluacion else 0\n    activas = [k for k, v in estrategias_activas.items() if v]\n\n    pesos_symbol = pesos.get(symbol, {})\n    umbral = calcular_umbral_adaptativo(\n        symbol,\n        df,\n        estrategias_activas,\n        pesos_symbol,\n        persistencia=0.0,\n        config=config,\n    )\n\n    factor_umbral = config.get(\"factor_umbral_sl\", 0.7) if config else 0.7\n    min_estrategias_relevantes = config.get(\"min_estrategias_relevantes_sl\", 3) if config else 3\n    esperadas = ESTRATEGIAS_POR_TENDENCIA.get(tendencia, [])\n    activas_relevantes = [e for e in activas if e in esperadas]\n    condiciones_validas = (\n        len(activas_relevantes) >= min_estrategias_relevantes\n        and puntaje >= factor_umbral * umbral\n    )\n\n    duracion = orden.get(\"duracion_en_velas\", 0)\n    max_velas = config.get(\"max_velas_sin_tp\", 10) if config else 10\n    intentos = len(orden.get(\"sl_evitar_info\", []))\n    max_evitar = config.get(\"max_evitar_sl\", 2) if config else 2\n\n    cerrar_forzado = validar_sl_tecnico(df, direccion) or puntaje < 0.75 * umbral or duracion >= max_velas or intentos >= max_evitar\n\n    if condiciones_validas and not cerrar_forzado:\n        log.info(\n            f\"\ud83d\udee1\ufe0f SL evitado en {symbol} | Puntaje: {puntaje:.2f}/{umbral:.2f} | Velas abiertas: {duracion}\"\n        )\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"SL tocado pero indicadores v\u00e1lidos para mantener\",\n            motivo=\"SL tocado pero indicadores v\u00e1lidos para mantener\",\n            evitado=True,\n        )\n    \n    if puntaje >= 2.5 * umbral:\n        log.info(\n            f\"\ud83d\udee1\ufe0f SL evitado por score excepcional en {symbol} \u2192 {puntaje:.2f}/{umbral:.2f}\"\n        )\n        return resultado_salida(\n            \"Stop Loss\",\n            False,\n            \"Score t\u00e9cnico muy alto\",\n            motivo=\"Score t\u00e9cnico muy alto\",\n            evitado=True,\n        )\n\n    log.info(\n        f\"\ud83d\udd34 SL forzado en {symbol} | Score t\u00e9cnico: {puntaje:.2f}/{umbral:.2f} | Velas abiertas: {duracion}\"\n    )\n    return resultado_salida(\n        \"Stop Loss\",\n        True,\n        f\"SL forzado | Score: {puntaje:.2f}/{umbral:.2f} | Velas: {duracion}\",\n        motivo=f\"SL forzado | Score: {puntaje:.2f}/{umbral:.2f} | Velas: {duracion}\",\n        evitado=False,\n        logger=log,\n    )\n    \n\n    \n\n"]]], 1750727260.8207457]], ["ChangeSet", ["Writing file <core/strategies/exit/salida_stoploss_atr.py>", [["ChangeContents", ["core/strategies/exit/salida_stoploss_atr.py", "import pandas as pd\nfrom indicators.atr import calcular_atr\nfrom core.utils import configurar_logger\nfrom core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_stoploss_atr\")\n\ndef salida_stoploss_atr(orden: dict, df: pd.DataFrame) -> dict:\n    try:\n        if len(df) < 20 or \"close\" not in df.columns:\n            return resultado_salida(\n                \"Stop Loss\",\n                False,\n                \"Datos insuficientes\",\n            )\n\n        direccion = orden.get(\"direccion\", \"long\")\n        precio_actual = df[\"close\"].iloc[-1]\n        entrada = orden.get(\"precio_entrada\")\n        atr = calcular_atr(df)\n\n        if atr is None or entrada is None:\n            return resultado_salida(\n                \"Stop Loss\",\n                False,\n                \"ATR o entrada no disponibles\",\n            )\n\n        margen = 1.5 * atr  # SL a 1.5 ATR\n\n        if direccion in [\"long\", \"compra\"]:\n            sl_tecnico = entrada - margen\n            if precio_actual <= sl_tecnico:\n                return resultado_salida(\n                    \"Stop Loss\",\n                    True,\n                    f\"SL-ATR activado (long) a {sl_tecnico:.4f}\",\n                    logger=log,\n                )\n        elif direccion == \"venta\":\n            sl_tecnico = entrada + margen\n            if precio_actual >= sl_tecnico:\n                return resultado_salida(\n                    \"Stop Loss\",\n                    True,\n                    f\"SL-ATR activado (short) a {sl_tecnico:.4f}\",\n                    logger=log,\n                )\n\n        return resultado_salida(\"Stop Loss\", False, \"SL-ATR no alcanzado\")\n\n    except Exception as e:\n        return resultado_salida(\"Stop Loss\", False, f\"Error SL-ATR: {e}\")\n", "import pandas as pd\nfrom indicators.atr import calcular_atr\nfrom core.utils import configurar_logger\nfrom pegaso.core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_stoploss_atr\")\n\ndef salida_stoploss_atr(orden: dict, df: pd.DataFrame) -> dict:\n    try:\n        if len(df) < 20 or \"close\" not in df.columns:\n            return resultado_salida(\n                \"Stop Loss\",\n                False,\n                \"Datos insuficientes\",\n            )\n\n        direccion = orden.get(\"direccion\", \"long\")\n        precio_actual = df[\"close\"].iloc[-1]\n        entrada = orden.get(\"precio_entrada\")\n        atr = calcular_atr(df)\n\n        if atr is None or entrada is None:\n            return resultado_salida(\n                \"Stop Loss\",\n                False,\n                \"ATR o entrada no disponibles\",\n            )\n\n        margen = 1.5 * atr  # SL a 1.5 ATR\n\n        if direccion in [\"long\", \"compra\"]:\n            sl_tecnico = entrada - margen\n            if precio_actual <= sl_tecnico:\n                return resultado_salida(\n                    \"Stop Loss\",\n                    True,\n                    f\"SL-ATR activado (long) a {sl_tecnico:.4f}\",\n                    logger=log,\n                )\n        elif direccion == \"venta\":\n            sl_tecnico = entrada + margen\n            if precio_actual >= sl_tecnico:\n                return resultado_salida(\n                    \"Stop Loss\",\n                    True,\n                    f\"SL-ATR activado (short) a {sl_tecnico:.4f}\",\n                    logger=log,\n                )\n\n        return resultado_salida(\"Stop Loss\", False, \"SL-ATR no alcanzado\")\n\n    except Exception as e:\n        return resultado_salida(\"Stop Loss\", False, f\"Error SL-ATR: {e}\")\n"]]], 1750727260.8384848]], ["ChangeSet", ["Writing file <core/strategies/exit/salida_takeprofit_atr.py>", [["ChangeContents", ["core/strategies/exit/salida_takeprofit_atr.py", "import pandas as pd\nfrom indicators.atr import calcular_atr\nfrom core.utils import configurar_logger\nfrom core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_takeprofit_atr\")\n\ndef salida_takeprofit_atr(orden: dict, df: pd.DataFrame) -> dict:\n    try:\n        if len(df) < 20 or \"close\" not in df.columns:\n            return resultado_salida(\n                \"Take Profit\",\n                False,\n                \"Datos insuficientes\",\n            )\n\n        direccion = orden.get(\"direccion\", \"long\")\n        precio_actual = df[\"close\"].iloc[-1]\n        entrada = orden.get(\"precio_entrada\")\n        atr = calcular_atr(df)\n\n        if atr is None or entrada is None:\n             return resultado_salida(\n                \"Take Profit\",\n                False,\n                \"ATR o entrada no disponibles\",\n            )\n\n        margen_tp = 2.5 * atr  # Take Profit a 2.5 ATR\n\n        if direccion in [\"long\", \"compra\"]:\n            tp_tecnico = entrada + margen_tp\n            if precio_actual >= tp_tecnico:\n                return resultado_salida(\n                    \"Take Profit\",\n                    True,\n                    f\"TP-ATR alcanzado (long) a {tp_tecnico:.4f}\",\n                    logger=log,\n                )\n        elif direccion == \"venta\":\n            tp_tecnico = entrada - margen_tp\n            if precio_actual <= tp_tecnico:\n                return resultado_salida(\n                    \"Take Profit\",\n                    True,\n                    f\"TP-ATR alcanzado (short) a {tp_tecnico:.4f}\",\n                    logger=log,\n                )\n\n        return resultado_salida(\"Take Profit\", False, \"TP-ATR no alcanzado\")\n\n    except Exception as e:\n        return resultado_salida(\"Take Profit\", False, f\"Error TP-ATR: {e}\")\n", "import pandas as pd\nfrom indicators.atr import calcular_atr\nfrom core.utils import configurar_logger\nfrom pegaso.core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_takeprofit_atr\")\n\ndef salida_takeprofit_atr(orden: dict, df: pd.DataFrame) -> dict:\n    try:\n        if len(df) < 20 or \"close\" not in df.columns:\n            return resultado_salida(\n                \"Take Profit\",\n                False,\n                \"Datos insuficientes\",\n            )\n\n        direccion = orden.get(\"direccion\", \"long\")\n        precio_actual = df[\"close\"].iloc[-1]\n        entrada = orden.get(\"precio_entrada\")\n        atr = calcular_atr(df)\n\n        if atr is None or entrada is None:\n             return resultado_salida(\n                \"Take Profit\",\n                False,\n                \"ATR o entrada no disponibles\",\n            )\n\n        margen_tp = 2.5 * atr  # Take Profit a 2.5 ATR\n\n        if direccion in [\"long\", \"compra\"]:\n            tp_tecnico = entrada + margen_tp\n            if precio_actual >= tp_tecnico:\n                return resultado_salida(\n                    \"Take Profit\",\n                    True,\n                    f\"TP-ATR alcanzado (long) a {tp_tecnico:.4f}\",\n                    logger=log,\n                )\n        elif direccion == \"venta\":\n            tp_tecnico = entrada - margen_tp\n            if precio_actual <= tp_tecnico:\n                return resultado_salida(\n                    \"Take Profit\",\n                    True,\n                    f\"TP-ATR alcanzado (short) a {tp_tecnico:.4f}\",\n                    logger=log,\n                )\n\n        return resultado_salida(\"Take Profit\", False, \"TP-ATR no alcanzado\")\n\n    except Exception as e:\n        return resultado_salida(\"Take Profit\", False, f\"Error TP-ATR: {e}\")\n"]]], 1750727260.8554037]], ["ChangeSet", ["Writing file <core/strategies/exit/salida_tiempo_maximo.py>", [["ChangeContents", ["core/strategies/exit/salida_tiempo_maximo.py", "import pandas as pd\nfrom datetime import datetime, timedelta\nfrom core.utils import configurar_logger\nfrom core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_tiempo_maximo\")\n\ndef salida_tiempo_maximo(orden: dict, df: pd.DataFrame) -> dict:\n    try:\n        timestamp = orden.get(\"timestamp\")\n        if not timestamp:\n            return resultado_salida(\n                \"Tecnico\",\n                False,\n                \"Sin timestamp de apertura\",\n            )\n\n        # Convierte el timestamp ISO a objeto datetime\n        if isinstance(timestamp, str):\n            timestamp_dt = datetime.fromisoformat(timestamp)\n        elif isinstance(timestamp, (int, float)):\n            timestamp_dt = datetime.utcfromtimestamp(timestamp / 1000)\n        else:\n            return resultado_salida(\n                \"Tecnico\",\n                False,\n                \"Formato de timestamp no v\u00e1lido\",\n            )\n\n        tiempo_maximo = timedelta(hours=4)  # l\u00edmite de vida de una orden\n        ahora = datetime.utcnow()\n        tiempo_abierta = ahora - timestamp_dt\n\n        if tiempo_abierta > tiempo_maximo:\n            return resultado_salida(\n                \"Tecnico\",\n                True,\n                f\"Orden super\u00f3 las {tiempo_maximo.total_seconds() // 3600:.0f}h\",\n                logger=log,\n            )\n\n        return resultado_salida(\n            \"Tecnico\",\n            False,\n            f\"Tiempo actual {tiempo_abierta}\",\n        )\n    except Exception as e:\n        return resultado_salida(\"Tecnico\", False, f\"Error en salida por tiempo: {e}\")", "import pandas as pd\nfrom datetime import datetime, timedelta\nfrom core.utils import configurar_logger\nfrom pegaso.core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_tiempo_maximo\")\n\ndef salida_tiempo_maximo(orden: dict, df: pd.DataFrame) -> dict:\n    try:\n        timestamp = orden.get(\"timestamp\")\n        if not timestamp:\n            return resultado_salida(\n                \"Tecnico\",\n                False,\n                \"Sin timestamp de apertura\",\n            )\n\n        # Convierte el timestamp ISO a objeto datetime\n        if isinstance(timestamp, str):\n            timestamp_dt = datetime.fromisoformat(timestamp)\n        elif isinstance(timestamp, (int, float)):\n            timestamp_dt = datetime.utcfromtimestamp(timestamp / 1000)\n        else:\n            return resultado_salida(\n                \"Tecnico\",\n                False,\n                \"Formato de timestamp no v\u00e1lido\",\n            )\n\n        tiempo_maximo = timedelta(hours=4)  # l\u00edmite de vida de una orden\n        ahora = datetime.utcnow()\n        tiempo_abierta = ahora - timestamp_dt\n\n        if tiempo_abierta > tiempo_maximo:\n            return resultado_salida(\n                \"Tecnico\",\n                True,\n                f\"Orden super\u00f3 las {tiempo_maximo.total_seconds() // 3600:.0f}h\",\n                logger=log,\n            )\n\n        return resultado_salida(\n            \"Tecnico\",\n            False,\n            f\"Tiempo actual {tiempo_abierta}\",\n        )\n    except Exception as e:\n        return resultado_salida(\"Tecnico\", False, f\"Error en salida por tiempo: {e}\")"]]], 1750727260.8722963]], ["ChangeSet", ["Writing file <core/strategies/exit/salida_trailing_stop.py>", [["ChangeContents", ["core/strategies/exit/salida_trailing_stop.py", "import pandas as pd\nfrom indicators.atr import calcular_atr\nfrom core.utils import configurar_logger\nfrom core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_trailing_stop\")\n\ndef salida_trailing_stop(orden: dict, df: pd.DataFrame, config: dict = None) -> dict:\n    \"\"\"\n    Eval\u00faa si debe cerrarse una orden utilizando l\u00f3gica de trailing stop.\n\n    Par\u00e1metros:\n        - orden: dict con detalles de la orden\n        - df: DataFrame con datos recientes del mercado\n        - config: dict opcional con par\u00e1metros personalizados:\n            * trailing_pct (ej. 0.015 para 1.5%)\n            * modo (para variantes futuras del algoritmo)\n\n    Devuelve:\n        - dict con claves:\n            * cerrar (bool): True si debe cerrarse\n            * razon (str): explicaci\u00f3n\n    \"\"\"\n    try:\n        if df is None or len(df) < 3 or not {\"close\"}.issubset(df.columns):\n            return resultado_salida(\n                \"Trailing Stop\",\n                False,\n                \"Datos insuficientes o mal formateados\",\n            )\n\n        precio_actual = df[\"close\"].iloc[-1]\n        direccion = orden.get(\"direccion\", \"long\")\n\n        # --- Distancia basada en ATR ---\n        atr_mult = config.get(\"atr_multiplicador\", 1.0) if config else 1.0\n        atr = calcular_atr(df)\n        if atr is None:\n            return resultado_salida(\n                \"Trailing Stop\",\n                False,\n                \"ATR no disponible\",\n            )\n        trailing_dist = atr * atr_mult\n\n        # --- Inicializa max_precio si no existe ---\n        if \"max_precio\" not in orden:\n            orden[\"max_precio\"] = orden[\"precio_entrada\"]\n\n        # --- L\u00f3gica de trailing por direcci\u00f3n ---\n        if direccion in [\"compra\", \"long\"]:\n            if precio_actual > orden[\"max_precio\"]:\n                orden[\"max_precio\"] = precio_actual\n            elif precio_actual < orden[\"max_precio\"] - trailing_dist:\n                return resultado_salida(\n                    \"Trailing Stop\",\n                    True,\n                    f\"Trailing Stop activado (long) \u2192 Max: {orden['max_precio']:.2f}, Precio actual: {precio_actual:.2f}\",\n                    logger=log,\n                )\n\n        elif direccion in [\"venta\", \"short\"]:\n            if precio_actual < orden[\"max_precio\"]:\n                orden[\"max_precio\"] = precio_actual\n            elif precio_actual > orden[\"max_precio\"] + trailing_dist:\n                return resultado_salida(\n                    \"Trailing Stop\",\n                    True,\n                    f\"Trailing Stop activado (short) \u2192 Min: {orden['max_precio']:.2f}, Precio actual: {precio_actual:.2f}\",\n                    logger=log,\n                )\n\n        return resultado_salida(\"Trailing Stop\", False, \"Trailing no activado\")\n\n    except Exception as e:\n        return resultado_salida(\n            \"Trailing Stop\",\n            False,\n            f\"Error en trailing stop: {e}\",\n        )\n\n\n\ndef verificar_trailing_stop(\n    info: dict, precio_actual: float, df: pd.DataFrame | None = None, config: dict = None\n) -> tuple[bool, str]:\n    \"\"\"\n    Eval\u00faa si debe cerrarse la orden usando l\u00f3gica de trailing stop.\n\n    Par\u00e1metros:\n        - info: dict con informaci\u00f3n de la orden (precio_entrada, max_price, etc.)\n        - precio_actual: \u00faltimo precio de mercado\n        - config: configuraci\u00f3n personalizada con claves:\n            * trailing_start_ratio (ej: 1.015 para +1.5%)\n            * trailing_distance_ratio (ej: 0.02 para -2%)\n\n    Devuelve:\n        - (True, \"raz\u00f3n\") si debe cerrarse\n        - (False, \"\") si no\n    \"\"\"\n    entrada = info[\"precio_entrada\"]\n    max_price = info.get(\"max_price\", entrada)\n    \n\n    buffer_pct = config.get(\"trailing_buffer\", 0.0) if config else 0.0\n    if precio_actual > max_price * (1 + buffer_pct):\n        info[\"max_price\"] = precio_actual\n        max_price = precio_actual\n    trailing_start_ratio = config.get(\"trailing_start_ratio\", 1.015) if config else 1.015\n    atr_mult = config.get(\"atr_multiplicador\", 1.0) if config else 1.0\n    usar_atr = config.get(\"trailing_por_atr\", False) if config else False\n\n    atr = calcular_atr(df) if df is not None else None\n    if atr is None:\n        return False, \"ATR no disponible\"\n\n    trailing_trigger = entrada * trailing_start_ratio\n    if max_price >= trailing_trigger:\n        if usar_atr:\n            trailing_stop = max_price - atr * atr_mult\n        else:\n            distancia_ratio = config.get(\"trailing_distance_ratio\", 0.02) if config else 0.02\n            trailing_stop = max_price * (1 - distancia_ratio)\n\n        if config.get(\"uso_trailing_technico\", False) and df is not None and len(df) >= 5:\n            soporte = df[\"low\"].rolling(window=5).min().iloc[-1]\n            resistencia = df[\"high\"].rolling(window=5).max().iloc[-1]\n            if info.get(\"direccion\", \"long\") in (\"long\", \"compra\"):\n                trailing_stop = max(trailing_stop, soporte)\n            else:\n                trailing_stop = min(trailing_stop, resistencia)\n\n        if info.get(\"direccion\", \"long\") in (\"long\", \"compra\"):\n            if precio_actual <= trailing_stop:\n                return True, f\"Trailing Stop activado \u2014 M\u00e1ximo: {max_price:.2f}, L\u00edmite: {trailing_stop:.2f}, Precio actual: {precio_actual:.2f}\"\n        else:\n            if precio_actual >= trailing_stop:\n                return True, f\"Trailing Stop activado \u2014 M\u00ednimo: {max_price:.2f}, L\u00edmite: {trailing_stop:.2f}, Precio actual: {precio_actual:.2f}\"\n        return False, f\"Trailing supervisando \u2014 M\u00e1x {max_price:.2f}, L\u00edmite {trailing_stop:.2f}\"\n\n    return False, \"\"\n", "import pandas as pd\nfrom indicators.atr import calcular_atr\nfrom core.utils import configurar_logger\nfrom pegaso.core.strategies.exit.salida_utils import resultado_salida\n\nlog = configurar_logger(\"salida_trailing_stop\")\n\ndef salida_trailing_stop(orden: dict, df: pd.DataFrame, config: dict = None) -> dict:\n    \"\"\"\n    Eval\u00faa si debe cerrarse una orden utilizando l\u00f3gica de trailing stop.\n\n    Par\u00e1metros:\n        - orden: dict con detalles de la orden\n        - df: DataFrame con datos recientes del mercado\n        - config: dict opcional con par\u00e1metros personalizados:\n            * trailing_pct (ej. 0.015 para 1.5%)\n            * modo (para variantes futuras del algoritmo)\n\n    Devuelve:\n        - dict con claves:\n            * cerrar (bool): True si debe cerrarse\n            * razon (str): explicaci\u00f3n\n    \"\"\"\n    try:\n        if df is None or len(df) < 3 or not {\"close\"}.issubset(df.columns):\n            return resultado_salida(\n                \"Trailing Stop\",\n                False,\n                \"Datos insuficientes o mal formateados\",\n            )\n\n        precio_actual = df[\"close\"].iloc[-1]\n        direccion = orden.get(\"direccion\", \"long\")\n\n        # --- Distancia basada en ATR ---\n        atr_mult = config.get(\"atr_multiplicador\", 1.0) if config else 1.0\n        atr = calcular_atr(df)\n        if atr is None:\n            return resultado_salida(\n                \"Trailing Stop\",\n                False,\n                \"ATR no disponible\",\n            )\n        trailing_dist = atr * atr_mult\n\n        # --- Inicializa max_precio si no existe ---\n        if \"max_precio\" not in orden:\n            orden[\"max_precio\"] = orden[\"precio_entrada\"]\n\n        # --- L\u00f3gica de trailing por direcci\u00f3n ---\n        if direccion in [\"compra\", \"long\"]:\n            if precio_actual > orden[\"max_precio\"]:\n                orden[\"max_precio\"] = precio_actual\n            elif precio_actual < orden[\"max_precio\"] - trailing_dist:\n                return resultado_salida(\n                    \"Trailing Stop\",\n                    True,\n                    f\"Trailing Stop activado (long) \u2192 Max: {orden['max_precio']:.2f}, Precio actual: {precio_actual:.2f}\",\n                    logger=log,\n                )\n\n        elif direccion in [\"venta\", \"short\"]:\n            if precio_actual < orden[\"max_precio\"]:\n                orden[\"max_precio\"] = precio_actual\n            elif precio_actual > orden[\"max_precio\"] + trailing_dist:\n                return resultado_salida(\n                    \"Trailing Stop\",\n                    True,\n                    f\"Trailing Stop activado (short) \u2192 Min: {orden['max_precio']:.2f}, Precio actual: {precio_actual:.2f}\",\n                    logger=log,\n                )\n\n        return resultado_salida(\"Trailing Stop\", False, \"Trailing no activado\")\n\n    except Exception as e:\n        return resultado_salida(\n            \"Trailing Stop\",\n            False,\n            f\"Error en trailing stop: {e}\",\n        )\n\n\n\ndef verificar_trailing_stop(\n    info: dict, precio_actual: float, df: pd.DataFrame | None = None, config: dict = None\n) -> tuple[bool, str]:\n    \"\"\"\n    Eval\u00faa si debe cerrarse la orden usando l\u00f3gica de trailing stop.\n\n    Par\u00e1metros:\n        - info: dict con informaci\u00f3n de la orden (precio_entrada, max_price, etc.)\n        - precio_actual: \u00faltimo precio de mercado\n        - config: configuraci\u00f3n personalizada con claves:\n            * trailing_start_ratio (ej: 1.015 para +1.5%)\n            * trailing_distance_ratio (ej: 0.02 para -2%)\n\n    Devuelve:\n        - (True, \"raz\u00f3n\") si debe cerrarse\n        - (False, \"\") si no\n    \"\"\"\n    entrada = info[\"precio_entrada\"]\n    max_price = info.get(\"max_price\", entrada)\n    \n\n    buffer_pct = config.get(\"trailing_buffer\", 0.0) if config else 0.0\n    if precio_actual > max_price * (1 + buffer_pct):\n        info[\"max_price\"] = precio_actual\n        max_price = precio_actual\n    trailing_start_ratio = config.get(\"trailing_start_ratio\", 1.015) if config else 1.015\n    atr_mult = config.get(\"atr_multiplicador\", 1.0) if config else 1.0\n    usar_atr = config.get(\"trailing_por_atr\", False) if config else False\n\n    atr = calcular_atr(df) if df is not None else None\n    if atr is None:\n        return False, \"ATR no disponible\"\n\n    trailing_trigger = entrada * trailing_start_ratio\n    if max_price >= trailing_trigger:\n        if usar_atr:\n            trailing_stop = max_price - atr * atr_mult\n        else:\n            distancia_ratio = config.get(\"trailing_distance_ratio\", 0.02) if config else 0.02\n            trailing_stop = max_price * (1 - distancia_ratio)\n\n        if config.get(\"uso_trailing_technico\", False) and df is not None and len(df) >= 5:\n            soporte = df[\"low\"].rolling(window=5).min().iloc[-1]\n            resistencia = df[\"high\"].rolling(window=5).max().iloc[-1]\n            if info.get(\"direccion\", \"long\") in (\"long\", \"compra\"):\n                trailing_stop = max(trailing_stop, soporte)\n            else:\n                trailing_stop = min(trailing_stop, resistencia)\n\n        if info.get(\"direccion\", \"long\") in (\"long\", \"compra\"):\n            if precio_actual <= trailing_stop:\n                return True, f\"Trailing Stop activado \u2014 M\u00e1ximo: {max_price:.2f}, L\u00edmite: {trailing_stop:.2f}, Precio actual: {precio_actual:.2f}\"\n        else:\n            if precio_actual >= trailing_stop:\n                return True, f\"Trailing Stop activado \u2014 M\u00ednimo: {max_price:.2f}, L\u00edmite: {trailing_stop:.2f}, Precio actual: {precio_actual:.2f}\"\n        return False, f\"Trailing supervisando \u2014 M\u00e1x {max_price:.2f}, L\u00edmite {trailing_stop:.2f}\"\n\n    return False, \"\"\n"]]], 1750727260.8961148]], ["ChangeSet", ["Writing file <core/strategies/exit/salida_utils.py>", [["ChangeContents", ["core/strategies/exit/salida_utils.py", "from __future__ import annotations\nfrom core.utils.utils import configurar_logger\n\nlog = configurar_logger(\"salida_utils\")\n\nPRIORIDAD_EVENTOS = {\n    \"Stop Loss\": 3,\n    \"Take Profit\": 2,\n    \"Trailing Stop\": 1,\n    \"Tecnico\": 0,\n}\n\n\ndef resultado_salida(evento: str, cerrar: bool, razon: str, logger=None, **extras) -> dict:\n    \"\"\"Genera un diccionario est\u00e1ndar para resultados de salida.\"\"\"\n    if logger and cerrar:\n        logger.info(f\"{evento} \u2192 {razon}\")\n    data = {\"cerrar\": cerrar, \"evento\": evento, \"razon\": razon}\n    data.update(extras)\n    return data", "from __future__ import annotations\nfrom pegaso.core.utils.utils import configurar_logger\n\nlog = configurar_logger(\"salida_utils\")\n\nPRIORIDAD_EVENTOS = {\n    \"Stop Loss\": 3,\n    \"Take Profit\": 2,\n    \"Trailing Stop\": 1,\n    \"Tecnico\": 0,\n}\n\n\ndef resultado_salida(evento: str, cerrar: bool, razon: str, logger=None, **extras) -> dict:\n    \"\"\"Genera un diccionario est\u00e1ndar para resultados de salida.\"\"\"\n    if logger and cerrar:\n        logger.info(f\"{evento} \u2192 {razon}\")\n    data = {\"cerrar\": cerrar, \"evento\": evento, \"razon\": razon}\n    data.update(extras)\n    return data"]]], 1750727260.9138663]], ["ChangeSet", ["Writing file <core/strategies/exit/verificar_salidas.py>", [["ChangeContents", ["core/strategies/exit/verificar_salidas.py", "from __future__ import annotations\n\nfrom datetime import datetime\nimport pandas as pd\n\nfrom core.utils import configurar_logger\nfrom indicators.rsi import calcular_rsi\nfrom indicators.momentum import calcular_momentum\nfrom indicators.atr import calcular_atr\nfrom core.strategies.tendencia import detectar_tendencia\nfrom strategies.exit.salida_stoploss import verificar_salida_stoploss\nfrom strategies.exit.salida_trailing_stop import verificar_trailing_stop\nfrom strategies.exit.salida_por_tendencia import verificar_reversion_tendencia\nfrom strategies.exit.gestor_salidas import evaluar_salidas, verificar_filtro_tecnico\nfrom strategies.exit.analisis_previo_salida import (\n    permitir_cierre_tecnico,\n    evaluar_condiciones_de_cierre_anticipado,\n)\nfrom strategies.exit.analisis_salidas import patron_tecnico_fuerte\nfrom core.strategies.exit.filtro_salidas import validar_necesidad_de_salida\nfrom core.adaptador_dinamico import adaptar_configuracion as adaptar_configuracion_base\nfrom core.adaptador_configuracion_dinamica import adaptar_configuracion\nfrom core.adaptador_umbral import calcular_umbral_adaptativo\nfrom core.metricas_semanales import metricas_tracker\n\nlog = configurar_logger(\"verificar_salidas\")\n\nasync def verificar_salidas(trader, symbol: str, df: pd.DataFrame) -> None:\n    \"\"\"Eval\u00faa si la orden abierta debe cerrarse.\"\"\"\n    orden = trader.orders.obtener(symbol)\n    if not orden:\n        log.warning(f\"\u26a0\ufe0f Se intent\u00f3 verificar TP/SL sin orden activa en {symbol}\")\n        return\n\n    orden.duracion_en_velas = getattr(orden, \"duracion_en_velas\", 0) + 1\n\n    await trader._piramidar(symbol, orden, df)\n\n    precio_min = float(df[\"low\"].iloc[-1])\n    precio_max = float(df[\"high\"].iloc[-1])\n    precio_cierre = float(df[\"close\"].iloc[-1])\n    config_actual = trader.config_por_simbolo.get(symbol, {})\n    log.debug(f\"Verificando salidas para {symbol} con orden: {orden.to_dict()}\")\n\n    atr = calcular_atr(df)\n    volatilidad_rel = atr / precio_cierre if atr and precio_cierre else 1.0\n    tendencia_detectada = trader.estado_tendencia.get(symbol)\n    if not tendencia_detectada:\n        tendencia_detectada, _ = detectar_tendencia(symbol, df)\n        trader.estado_tendencia[symbol] = tendencia_detectada\n    contexto = {\n        \"volatilidad\": volatilidad_rel,\n        \"tendencia\": tendencia_detectada,\n    }\n\n    # --- Stop Loss con validaci\u00f3n ---\n    if precio_min <= orden.stop_loss:\n        rsi = calcular_rsi(df)\n        momentum = calcular_momentum(df)\n        tendencia_actual = trader.estado_tendencia.get(symbol)\n        if not tendencia_actual:\n            tendencia_actual, _ = detectar_tendencia(symbol, df)\n            trader.estado_tendencia[symbol] = tendencia_actual\n        score, _ = trader._calcular_score_tecnico(\n            df,\n            rsi,\n            momentum,\n            tendencia_actual,\n            orden.direccion,\n        )\n        if score >= 2 or patron_tecnico_fuerte(df):\n            log.info(\n                f\"\ud83d\udee1\ufe0f SL evitado por validaci\u00f3n t\u00e9cnica \u2014 Score: {score:.1f}/4\"\n            )\n            orden.sl_evitar_info = orden.sl_evitar_info or []\n            orden.sl_evitar_info.append(\n                {\n                    \"timestamp\": datetime.utcnow().isoformat(),\n                    \"sl\": orden.stop_loss,\n                    \"precio\": precio_cierre,\n                }\n            )\n            return\n        resultado = verificar_salida_stoploss(\n            orden.to_dict(), df, config=config_actual\n        )\n        if resultado.get(\"cerrar\", False):\n            if score <= 1 and not evaluar_condiciones_de_cierre_anticipado(\n                symbol,\n                df,\n                orden.to_dict(),\n                score,\n                orden.estrategias_activas,\n            ):\n                log.info(\n                    f\"\ud83d\udee1\ufe0f Cierre por SL evitado tras reevaluaci\u00f3n t\u00e9cnica: {symbol}\"\n                )\n                orden.sl_evitar_info = orden.sl_evitar_info or []\n                orden.sl_evitar_info.append(\n                    {\n                        \"timestamp\": datetime.utcnow().isoformat(),\n                        \"sl\": orden.stop_loss,\n                        \"precio\": precio_cierre,\n                    }\n                )\n            elif not permitir_cierre_tecnico(\n                symbol,\n                df,\n                precio_cierre,\n                orden.to_dict(),\n            ):\n                log.info(f\"\ud83d\udee1\ufe0f Cierre evitado por an\u00e1lisis t\u00e9cnico: {symbol}\")\n                orden.sl_evitar_info = orden.sl_evitar_info or []\n                orden.sl_evitar_info.append(\n                    {\n                        \"timestamp\": datetime.utcnow().isoformat(),\n                        \"sl\": orden.stop_loss,\n                        \"precio\": precio_cierre,\n                    }\n                )\n            else:\n                await trader._cerrar_y_reportar(\n                    orden, orden.stop_loss, \"Stop Loss\", df=df\n                )\n        else:\n            if resultado.get(\"evitado\", False):\n                log.debug(\"SL evitado correctamente, no se notificar\u00e1 por Telegram\")\n                metricas_tracker.registrar_sl_evitado()\n                orden.sl_evitar_info = orden.sl_evitar_info or []\n                orden.sl_evitar_info.append(\n                    {\n                        \"timestamp\": datetime.utcnow().isoformat(),\n                        \"sl\": orden.stop_loss,\n                        \"precio\": precio_cierre,\n                    }\n                )\n                log.info(\n                    f\"\ud83d\udee1\ufe0f SL evitado para {symbol} \u2192 {resultado.get('motivo', '')}\"\n                )\n            else:\n                log.info(f\"\u2139\ufe0f {symbol} \u2192 {resultado.get('motivo', '')}\")\n        return\n\n    # --- Take Profit ---\n    if precio_max >= orden.take_profit:\n        if (\n            not getattr(orden, \"parcial_cerrado\", False)\n            and orden.cantidad_abierta > 0\n        ):\n            if trader.es_salida_parcial_valida(\n                orden,\n                orden.take_profit,\n                config_actual,\n                df,\n            ):\n                cantidad_parcial = orden.cantidad_abierta * 0.5\n                if await trader._cerrar_parcial_y_reportar(\n                    orden,\n                    cantidad_parcial,\n                    orden.take_profit,\n                    \"Take Profit parcial\",\n                    df=df,\n                ):\n                    orden.parcial_cerrado = True\n                    log.info(\n                        \"\ud83d\udcb0 TP parcial alcanzado, se mantiene posici\u00f3n con trailing.\"\n                    )\n            else:\n                await trader._cerrar_y_reportar(\n                    orden, orden.take_profit, \"Take Profit\", df=df\n                )\n        elif orden.cantidad_abierta > 0:\n            await trader._cerrar_y_reportar(\n                orden, orden.take_profit, \"Take Profit\", df=df\n            )\n        return\n\n    # --- Trailing Stop ---\n    if orden.cantidad_abierta <= 0:\n        return\n    if precio_cierre > orden.max_price:\n        orden.max_price = precio_cierre\n\n    dinamica = adaptar_configuracion(symbol, df)\n    if dinamica:\n        config_actual.update(dinamica)\n    config_actual = adaptar_configuracion_base(symbol, df, config_actual)\n    trader.config_por_simbolo[symbol] = config_actual\n\n    try:\n        cerrar, motivo = verificar_trailing_stop(\n            orden.to_dict(), precio_cierre, df, config=config_actual\n        )\n    except Exception as e:\n        log.warning(f\"\u26a0\ufe0f Error en trailing stop para {symbol}: {e}\")\n        cerrar, motivo = False, \"\"\n    if cerrar:\n        if not permitir_cierre_tecnico(symbol, df, precio_cierre, orden.to_dict()):\n            log.info(f\"\ud83d\udee1\ufe0f Cierre evitado por an\u00e1lisis t\u00e9cnico: {symbol}\")\n        elif await trader._cerrar_y_reportar(orden, precio_cierre, motivo, df=df):\n            log.info(\n                f\"\ud83d\udd04 Trailing Stop activado para {symbol} a {precio_cierre:.2f}\u20ac\"\n            )\n        return\n\n    # --- Cambio de tendencia ---\n    if verificar_reversion_tendencia(symbol, df, orden.tendencia):\n        pesos_symbol = trader.pesos_por_simbolo.get(symbol, {})\n        if not verificar_filtro_tecnico(\n            symbol, df, orden.estrategias_activas, pesos_symbol, config=config_actual\n        ):\n            nueva_tendencia = trader.estado_tendencia.get(symbol)\n            if not nueva_tendencia:\n                nueva_tendencia, _ = detectar_tendencia(symbol, df)\n                trader.estado_tendencia[symbol] = nueva_tendencia\n            if not permitir_cierre_tecnico(symbol, df, precio_cierre, orden.to_dict()):\n                log.info(f\"\ud83d\udee1\ufe0f Cierre evitado por an\u00e1lisis t\u00e9cnico: {symbol}\")\n            elif await trader._cerrar_y_reportar(\n                orden,\n                precio_cierre,\n                \"Cambio de tendencia\",\n                tendencia=nueva_tendencia,\n                df=df,\n            ):\n                log.info(\n                    f\"\ud83d\udd04 Cambio de tendencia detectado para {symbol}. Cierre recomendado.\"\n                )\n            return\n\n    # --- Estrategias de salida personalizadas ---\n    try:\n        resultado = evaluar_salidas(\n            orden.to_dict(),\n            df,\n            config=config_actual,\n            contexto=contexto,\n        )\n    except Exception as e:\n        log.warning(f\"\u26a0\ufe0f Error evaluando salidas para {symbol}: {e}\")\n        resultado = {}\n\n    if resultado.get(\"break_even\"):\n        nuevo_sl = resultado.get(\"nuevo_sl\")\n        if nuevo_sl is not None:\n            if orden.direccion in (\"long\", \"compra\"):\n                if nuevo_sl > orden.stop_loss:\n                    orden.stop_loss = nuevo_sl\n            else:\n                if nuevo_sl < orden.stop_loss:\n                    orden.stop_loss = nuevo_sl\n        orden.break_even_activado = True\n        log.info(\n            f\"\ud83d\udfe1 Break-Even activado para {symbol} \u2192 SL movido a entrada: {nuevo_sl}\"\n        )\n\n    if resultado.get(\"cerrar\", False):\n        razon = resultado.get(\"razon\", \"Estrategia desconocida\")\n        tendencia_actual = trader.estado_tendencia.get(symbol)\n        if not tendencia_actual:\n            tendencia_actual, _ = detectar_tendencia(symbol, df)\n            trader.estado_tendencia[symbol] = tendencia_actual\n        evaluacion = trader.engine.evaluar_entrada(\n            symbol,\n            df,\n            tendencia=tendencia_actual,\n            config=config_actual,\n            pesos_symbol=trader.pesos_por_simbolo.get(symbol, {}),\n        )\n        estrategias = evaluacion.get(\"estrategias_activas\", {})\n        puntaje = evaluacion.get(\"puntaje_total\", 0)\n        pesos_symbol = trader.pesos_por_simbolo.get(symbol, {})\n        umbral = calcular_umbral_adaptativo(\n            symbol,\n            df,\n            estrategias,\n            pesos_symbol,\n            persistencia=0.0,\n        )\n        if not validar_necesidad_de_salida(\n            df,\n            orden.to_dict(),\n            estrategias,\n            puntaje=puntaje,\n            umbral=umbral,\n            config=config_actual,\n        ):\n            log.info(\n                f\"\u274c Cierre por '{razon}' evitado: condiciones t\u00e9cnicas a\u00fan v\u00e1lidas.\"\n            )\n            return\n        if not permitir_cierre_tecnico(symbol, df, precio_cierre, orden.to_dict()):\n            log.info(f\"\ud83d\udee1\ufe0f Cierre evitado por an\u00e1lisis t\u00e9cnico: {symbol}\")\n            return\n        await trader._cerrar_y_reportar(\n            orden, precio_cierre, f\"Estrategia: {razon}\", df=df\n        )\n", "from __future__ import annotations\n\nfrom datetime import datetime\nimport pandas as pd\n\nfrom core.utils import configurar_logger\nfrom indicators.rsi import calcular_rsi\nfrom indicators.momentum import calcular_momentum\nfrom indicators.atr import calcular_atr\nfrom core.strategies.tendencia import detectar_tendencia\nfrom strategies.exit.salida_stoploss import verificar_salida_stoploss\nfrom strategies.exit.salida_trailing_stop import verificar_trailing_stop\nfrom strategies.exit.salida_por_tendencia import verificar_reversion_tendencia\nfrom strategies.exit.gestor_salidas import evaluar_salidas, verificar_filtro_tecnico\nfrom strategies.exit.analisis_previo_salida import (\n    permitir_cierre_tecnico,\n    evaluar_condiciones_de_cierre_anticipado,\n)\nfrom strategies.exit.analisis_salidas import patron_tecnico_fuerte\nfrom pegaso.core.strategies.exit.filtro_salidas import validar_necesidad_de_salida\nfrom core.adaptador_dinamico import adaptar_configuracion as adaptar_configuracion_base\nfrom core.adaptador_configuracion_dinamica import adaptar_configuracion\nfrom core.adaptador_umbral import calcular_umbral_adaptativo\nfrom core.metricas_semanales import metricas_tracker\n\nlog = configurar_logger(\"verificar_salidas\")\n\nasync def verificar_salidas(trader, symbol: str, df: pd.DataFrame) -> None:\n    \"\"\"Eval\u00faa si la orden abierta debe cerrarse.\"\"\"\n    orden = trader.orders.obtener(symbol)\n    if not orden:\n        log.warning(f\"\u26a0\ufe0f Se intent\u00f3 verificar TP/SL sin orden activa en {symbol}\")\n        return\n\n    orden.duracion_en_velas = getattr(orden, \"duracion_en_velas\", 0) + 1\n\n    await trader._piramidar(symbol, orden, df)\n\n    precio_min = float(df[\"low\"].iloc[-1])\n    precio_max = float(df[\"high\"].iloc[-1])\n    precio_cierre = float(df[\"close\"].iloc[-1])\n    config_actual = trader.config_por_simbolo.get(symbol, {})\n    log.debug(f\"Verificando salidas para {symbol} con orden: {orden.to_dict()}\")\n\n    atr = calcular_atr(df)\n    volatilidad_rel = atr / precio_cierre if atr and precio_cierre else 1.0\n    tendencia_detectada = trader.estado_tendencia.get(symbol)\n    if not tendencia_detectada:\n        tendencia_detectada, _ = detectar_tendencia(symbol, df)\n        trader.estado_tendencia[symbol] = tendencia_detectada\n    contexto = {\n        \"volatilidad\": volatilidad_rel,\n        \"tendencia\": tendencia_detectada,\n    }\n\n    # --- Stop Loss con validaci\u00f3n ---\n    if precio_min <= orden.stop_loss:\n        rsi = calcular_rsi(df)\n        momentum = calcular_momentum(df)\n        tendencia_actual = trader.estado_tendencia.get(symbol)\n        if not tendencia_actual:\n            tendencia_actual, _ = detectar_tendencia(symbol, df)\n            trader.estado_tendencia[symbol] = tendencia_actual\n        score, _ = trader._calcular_score_tecnico(\n            df,\n            rsi,\n            momentum,\n            tendencia_actual,\n            orden.direccion,\n        )\n        if score >= 2 or patron_tecnico_fuerte(df):\n            log.info(\n                f\"\ud83d\udee1\ufe0f SL evitado por validaci\u00f3n t\u00e9cnica \u2014 Score: {score:.1f}/4\"\n            )\n            orden.sl_evitar_info = orden.sl_evitar_info or []\n            orden.sl_evitar_info.append(\n                {\n                    \"timestamp\": datetime.utcnow().isoformat(),\n                    \"sl\": orden.stop_loss,\n                    \"precio\": precio_cierre,\n                }\n            )\n            return\n        resultado = verificar_salida_stoploss(\n            orden.to_dict(), df, config=config_actual\n        )\n        if resultado.get(\"cerrar\", False):\n            if score <= 1 and not evaluar_condiciones_de_cierre_anticipado(\n                symbol,\n                df,\n                orden.to_dict(),\n                score,\n                orden.estrategias_activas,\n            ):\n                log.info(\n                    f\"\ud83d\udee1\ufe0f Cierre por SL evitado tras reevaluaci\u00f3n t\u00e9cnica: {symbol}\"\n                )\n                orden.sl_evitar_info = orden.sl_evitar_info or []\n                orden.sl_evitar_info.append(\n                    {\n                        \"timestamp\": datetime.utcnow().isoformat(),\n                        \"sl\": orden.stop_loss,\n                        \"precio\": precio_cierre,\n                    }\n                )\n            elif not permitir_cierre_tecnico(\n                symbol,\n                df,\n                precio_cierre,\n                orden.to_dict(),\n            ):\n                log.info(f\"\ud83d\udee1\ufe0f Cierre evitado por an\u00e1lisis t\u00e9cnico: {symbol}\")\n                orden.sl_evitar_info = orden.sl_evitar_info or []\n                orden.sl_evitar_info.append(\n                    {\n                        \"timestamp\": datetime.utcnow().isoformat(),\n                        \"sl\": orden.stop_loss,\n                        \"precio\": precio_cierre,\n                    }\n                )\n            else:\n                await trader._cerrar_y_reportar(\n                    orden, orden.stop_loss, \"Stop Loss\", df=df\n                )\n        else:\n            if resultado.get(\"evitado\", False):\n                log.debug(\"SL evitado correctamente, no se notificar\u00e1 por Telegram\")\n                metricas_tracker.registrar_sl_evitado()\n                orden.sl_evitar_info = orden.sl_evitar_info or []\n                orden.sl_evitar_info.append(\n                    {\n                        \"timestamp\": datetime.utcnow().isoformat(),\n                        \"sl\": orden.stop_loss,\n                        \"precio\": precio_cierre,\n                    }\n                )\n                log.info(\n                    f\"\ud83d\udee1\ufe0f SL evitado para {symbol} \u2192 {resultado.get('motivo', '')}\"\n                )\n            else:\n                log.info(f\"\u2139\ufe0f {symbol} \u2192 {resultado.get('motivo', '')}\")\n        return\n\n    # --- Take Profit ---\n    if precio_max >= orden.take_profit:\n        if (\n            not getattr(orden, \"parcial_cerrado\", False)\n            and orden.cantidad_abierta > 0\n        ):\n            if trader.es_salida_parcial_valida(\n                orden,\n                orden.take_profit,\n                config_actual,\n                df,\n            ):\n                cantidad_parcial = orden.cantidad_abierta * 0.5\n                if await trader._cerrar_parcial_y_reportar(\n                    orden,\n                    cantidad_parcial,\n                    orden.take_profit,\n                    \"Take Profit parcial\",\n                    df=df,\n                ):\n                    orden.parcial_cerrado = True\n                    log.info(\n                        \"\ud83d\udcb0 TP parcial alcanzado, se mantiene posici\u00f3n con trailing.\"\n                    )\n            else:\n                await trader._cerrar_y_reportar(\n                    orden, orden.take_profit, \"Take Profit\", df=df\n                )\n        elif orden.cantidad_abierta > 0:\n            await trader._cerrar_y_reportar(\n                orden, orden.take_profit, \"Take Profit\", df=df\n            )\n        return\n\n    # --- Trailing Stop ---\n    if orden.cantidad_abierta <= 0:\n        return\n    if precio_cierre > orden.max_price:\n        orden.max_price = precio_cierre\n\n    dinamica = adaptar_configuracion(symbol, df)\n    if dinamica:\n        config_actual.update(dinamica)\n    config_actual = adaptar_configuracion_base(symbol, df, config_actual)\n    trader.config_por_simbolo[symbol] = config_actual\n\n    try:\n        cerrar, motivo = verificar_trailing_stop(\n            orden.to_dict(), precio_cierre, df, config=config_actual\n        )\n    except Exception as e:\n        log.warning(f\"\u26a0\ufe0f Error en trailing stop para {symbol}: {e}\")\n        cerrar, motivo = False, \"\"\n    if cerrar:\n        if not permitir_cierre_tecnico(symbol, df, precio_cierre, orden.to_dict()):\n            log.info(f\"\ud83d\udee1\ufe0f Cierre evitado por an\u00e1lisis t\u00e9cnico: {symbol}\")\n        elif await trader._cerrar_y_reportar(orden, precio_cierre, motivo, df=df):\n            log.info(\n                f\"\ud83d\udd04 Trailing Stop activado para {symbol} a {precio_cierre:.2f}\u20ac\"\n            )\n        return\n\n    # --- Cambio de tendencia ---\n    if verificar_reversion_tendencia(symbol, df, orden.tendencia):\n        pesos_symbol = trader.pesos_por_simbolo.get(symbol, {})\n        if not verificar_filtro_tecnico(\n            symbol, df, orden.estrategias_activas, pesos_symbol, config=config_actual\n        ):\n            nueva_tendencia = trader.estado_tendencia.get(symbol)\n            if not nueva_tendencia:\n                nueva_tendencia, _ = detectar_tendencia(symbol, df)\n                trader.estado_tendencia[symbol] = nueva_tendencia\n            if not permitir_cierre_tecnico(symbol, df, precio_cierre, orden.to_dict()):\n                log.info(f\"\ud83d\udee1\ufe0f Cierre evitado por an\u00e1lisis t\u00e9cnico: {symbol}\")\n            elif await trader._cerrar_y_reportar(\n                orden,\n                precio_cierre,\n                \"Cambio de tendencia\",\n                tendencia=nueva_tendencia,\n                df=df,\n            ):\n                log.info(\n                    f\"\ud83d\udd04 Cambio de tendencia detectado para {symbol}. Cierre recomendado.\"\n                )\n            return\n\n    # --- Estrategias de salida personalizadas ---\n    try:\n        resultado = evaluar_salidas(\n            orden.to_dict(),\n            df,\n            config=config_actual,\n            contexto=contexto,\n        )\n    except Exception as e:\n        log.warning(f\"\u26a0\ufe0f Error evaluando salidas para {symbol}: {e}\")\n        resultado = {}\n\n    if resultado.get(\"break_even\"):\n        nuevo_sl = resultado.get(\"nuevo_sl\")\n        if nuevo_sl is not None:\n            if orden.direccion in (\"long\", \"compra\"):\n                if nuevo_sl > orden.stop_loss:\n                    orden.stop_loss = nuevo_sl\n            else:\n                if nuevo_sl < orden.stop_loss:\n                    orden.stop_loss = nuevo_sl\n        orden.break_even_activado = True\n        log.info(\n            f\"\ud83d\udfe1 Break-Even activado para {symbol} \u2192 SL movido a entrada: {nuevo_sl}\"\n        )\n\n    if resultado.get(\"cerrar\", False):\n        razon = resultado.get(\"razon\", \"Estrategia desconocida\")\n        tendencia_actual = trader.estado_tendencia.get(symbol)\n        if not tendencia_actual:\n            tendencia_actual, _ = detectar_tendencia(symbol, df)\n            trader.estado_tendencia[symbol] = tendencia_actual\n        evaluacion = trader.engine.evaluar_entrada(\n            symbol,\n            df,\n            tendencia=tendencia_actual,\n            config=config_actual,\n            pesos_symbol=trader.pesos_por_simbolo.get(symbol, {}),\n        )\n        estrategias = evaluacion.get(\"estrategias_activas\", {})\n        puntaje = evaluacion.get(\"puntaje_total\", 0)\n        pesos_symbol = trader.pesos_por_simbolo.get(symbol, {})\n        umbral = calcular_umbral_adaptativo(\n            symbol,\n            df,\n            estrategias,\n            pesos_symbol,\n            persistencia=0.0,\n        )\n        if not validar_necesidad_de_salida(\n            df,\n            orden.to_dict(),\n            estrategias,\n            puntaje=puntaje,\n            umbral=umbral,\n            config=config_actual,\n        ):\n            log.info(\n                f\"\u274c Cierre por '{razon}' evitado: condiciones t\u00e9cnicas a\u00fan v\u00e1lidas.\"\n            )\n            return\n        if not permitir_cierre_tecnico(symbol, df, precio_cierre, orden.to_dict()):\n            log.info(f\"\ud83d\udee1\ufe0f Cierre evitado por an\u00e1lisis t\u00e9cnico: {symbol}\")\n            return\n        await trader._cerrar_y_reportar(\n            orden, precio_cierre, f\"Estrategia: {razon}\", df=df\n        )\n"]]], 1750727261.203643]], ["ChangeSet", ["Writing file <learning/aprendizaje_continuo.py>", [["ChangeContents", ["learning/aprendizaje_continuo.py", "import os\nimport glob\nimport json\nfrom datetime import datetime\n\nimport pandas as pd\nfrom dotenv import dotenv_values\n\nfrom core.utils.utils import configurar_logger\nfrom learning.analisis_resultados import analizar_estrategias_en_ordenes\nfrom learning.entrenador_estrategias import actualizar_pesos_estrategias_symbol\nfrom learning.recalibrar_semana import recalibrar_pesos_semana\nfrom core.strategies.pesos import gestor_pesos\nfrom config.configuracion import (\n    cargar_configuracion_simbolo,\n    guardar_configuracion_simbolo,\n)\nfrom core.adaptador_dinamico import (\n    calcular_umbral_adaptativo,\n    calcular_tp_sl_adaptativos,\n)\nfrom core.risk import RiskManager\n\nCONFIG = dotenv_values(\"config/claves.env\")\nMODO_REAL = CONFIG.get(\"MODO_REAL\", \"False\") == \"True\"\nCARPETA_ORDENES = \"ordenes_reales\" if MODO_REAL else \"ordenes_simuladas\"\nFEEDBACK_PATH = \"config/feedback_manual.json\"\n\nlog = configurar_logger(\"aprendizaje_continuo\")\n\n\ndef _cargar_feedback(symbol: str) -> dict:\n    \"\"\"Lee ajustes manuales de ``FEEDBACK_PATH`` si existen.\"\"\"\n    if not os.path.exists(FEEDBACK_PATH):\n        return {}\n    try:\n        with open(FEEDBACK_PATH, \"r\", encoding=\"utf-8\") as fh:\n            data = json.load(fh)\n        return data.get(symbol, {})\n    except Exception as e:\n        log.warning(f\"\u26a0\ufe0f Error leyendo feedback manual: {e}\")\n        return {}\n\n\ndef _aplicar_feedback_pesos(symbol: str, feedback: dict) -> None:\n    if not feedback.get(\"pesos\"):\n        return\n    pesos = gestor_pesos.obtener_pesos_symbol(symbol)\n    if not pesos:\n        return\n    actualizado = False\n    for estrategia, ajuste in feedback[\"pesos\"].items():\n        if estrategia in pesos:\n            try:\n                pesos[estrategia] = max(0.0, pesos[estrategia] + float(ajuste))\n                actualizado = True\n            except Exception:\n                continue\n    if actualizado:\n        datos = gestor_pesos.pesos\n        datos[symbol] = pesos\n        gestor_pesos.guardar(datos)\n        log.info(f\"\ud83d\udcdd Feedback aplicado a pesos de {symbol}\")\n\n\ndef _actualizar_config(symbol: str, df: pd.DataFrame) -> None:\n    if df.empty:\n        return\n    config = cargar_configuracion_simbolo(symbol) or {}\n    pesos_symbol = gestor_pesos.obtener_pesos_symbol(symbol)\n    estrategias = list(pesos_symbol.keys())\n    umbral = calcular_umbral_adaptativo(symbol, df, estrategias, pesos_symbol)\n    config[\"umbral_adaptativo\"] = round(float(umbral), 2)\n    precio_actual = float(df[\"close\"].iloc[-1]) if \"close\" in df.columns else None\n    if precio_actual is not None and {\"high\", \"low\", \"close\"}.issubset(df.columns):\n        sl, tp = calcular_tp_sl_adaptativos(\n            symbol,\n            df,\n            config,\n            None,\n            precio_actual,\n        )\n        tmp = df.copy()\n        tmp[\"hl\"] = tmp[\"high\"] - tmp[\"low\"]\n        tmp[\"hc\"] = abs(tmp[\"high\"] - tmp[\"close\"].shift(1))\n        tmp[\"lc\"] = abs(tmp[\"low\"] - tmp[\"close\"].shift(1))\n        tmp[\"tr\"] = tmp[[\"hl\", \"hc\", \"lc\"]].max(axis=1)\n        atr = tmp[\"tr\"].rolling(window=14).mean().iloc[-1]\n        if pd.isna(atr):\n            atr = precio_actual * 0.01\n        config[\"sl_ratio\"] = round(abs(precio_actual - sl) / atr, 2)\n        config[\"tp_ratio\"] = round(abs(tp - precio_actual) / atr, 2)\n    guardar_configuracion_simbolo(symbol, config)\n    log.info(f\"\ud83d\udd27 Configuraci\u00f3n actualizada para {symbol}\")\n\n\ndef procesar_simbolo(symbol: str, ruta: str) -> None:\n    metricas_diarias = analizar_estrategias_en_ordenes(ruta, dias=1)\n    if metricas_diarias.empty:\n        log.info(f\"[{symbol}] Sin operaciones diarias para evaluar\")\n    else:\n        actualizar_pesos_estrategias_symbol(symbol)\n    df = pd.read_parquet(ruta)\n    _actualizar_config(symbol, df.tail(60))\n    feedback = _cargar_feedback(symbol)\n    _aplicar_feedback_pesos(symbol, feedback)\n    rm = RiskManager(0.03)\n    semana = df[df[\"timestamp\"] >= (datetime.utcnow() - pd.Timedelta(days=7)).timestamp()]\n    metricas = {\n        \"ganancia_semana\": semana.get(\"retorno_total\", pd.Series()).sum(),\n        \"winrate\": (semana.get(\"retorno_total\", pd.Series()) > 0).mean(),\n        \"drawdown\": semana.get(\"retorno_total\", pd.Series()).min(),\n    }\n    rm.ajustar_umbral(metricas)\n\n\ndef ejecutar_ciclo() -> None:\n    archivos = glob.glob(os.path.join(CARPETA_ORDENES, \"*.parquet\"))\n    if not archivos:\n        log.warning(f\"\u26a0\ufe0f No se encontraron \u00f3rdenes en {CARPETA_ORDENES}\")\n        return\n    for ruta in archivos:\n        symbol = os.path.splitext(os.path.basename(ruta))[0].replace(\"_\", \"/\")\n        procesar_simbolo(symbol, ruta)\n    if datetime.utcnow().weekday() == 0:\n        recalibrar_pesos_semana()\n\n\nif __name__ == \"__main__\":\n    ejecutar_ciclo()", "import os\nimport glob\nimport json\nfrom datetime import datetime\n\nimport pandas as pd\nfrom dotenv import dotenv_values\n\nfrom pegaso.core.utils.utils import configurar_logger\nfrom learning.analisis_resultados import analizar_estrategias_en_ordenes\nfrom learning.entrenador_estrategias import actualizar_pesos_estrategias_symbol\nfrom learning.recalibrar_semana import recalibrar_pesos_semana\nfrom core.strategies.pesos import gestor_pesos\nfrom pegaso.config.configuracion import (\n    cargar_configuracion_simbolo,\n    guardar_configuracion_simbolo,\n)\nfrom core.adaptador_dinamico import (\n    calcular_umbral_adaptativo,\n    calcular_tp_sl_adaptativos,\n)\nfrom core.risk import RiskManager\n\nCONFIG = dotenv_values(\"config/claves.env\")\nMODO_REAL = CONFIG.get(\"MODO_REAL\", \"False\") == \"True\"\nCARPETA_ORDENES = \"ordenes_reales\" if MODO_REAL else \"ordenes_simuladas\"\nFEEDBACK_PATH = \"config/feedback_manual.json\"\n\nlog = configurar_logger(\"aprendizaje_continuo\")\n\n\ndef _cargar_feedback(symbol: str) -> dict:\n    \"\"\"Lee ajustes manuales de ``FEEDBACK_PATH`` si existen.\"\"\"\n    if not os.path.exists(FEEDBACK_PATH):\n        return {}\n    try:\n        with open(FEEDBACK_PATH, \"r\", encoding=\"utf-8\") as fh:\n            data = json.load(fh)\n        return data.get(symbol, {})\n    except Exception as e:\n        log.warning(f\"\u26a0\ufe0f Error leyendo feedback manual: {e}\")\n        return {}\n\n\ndef _aplicar_feedback_pesos(symbol: str, feedback: dict) -> None:\n    if not feedback.get(\"pesos\"):\n        return\n    pesos = gestor_pesos.obtener_pesos_symbol(symbol)\n    if not pesos:\n        return\n    actualizado = False\n    for estrategia, ajuste in feedback[\"pesos\"].items():\n        if estrategia in pesos:\n            try:\n                pesos[estrategia] = max(0.0, pesos[estrategia] + float(ajuste))\n                actualizado = True\n            except Exception:\n                continue\n    if actualizado:\n        datos = gestor_pesos.pesos\n        datos[symbol] = pesos\n        gestor_pesos.guardar(datos)\n        log.info(f\"\ud83d\udcdd Feedback aplicado a pesos de {symbol}\")\n\n\ndef _actualizar_config(symbol: str, df: pd.DataFrame) -> None:\n    if df.empty:\n        return\n    config = cargar_configuracion_simbolo(symbol) or {}\n    pesos_symbol = gestor_pesos.obtener_pesos_symbol(symbol)\n    estrategias = list(pesos_symbol.keys())\n    umbral = calcular_umbral_adaptativo(symbol, df, estrategias, pesos_symbol)\n    config[\"umbral_adaptativo\"] = round(float(umbral), 2)\n    precio_actual = float(df[\"close\"].iloc[-1]) if \"close\" in df.columns else None\n    if precio_actual is not None and {\"high\", \"low\", \"close\"}.issubset(df.columns):\n        sl, tp = calcular_tp_sl_adaptativos(\n            symbol,\n            df,\n            config,\n            None,\n            precio_actual,\n        )\n        tmp = df.copy()\n        tmp[\"hl\"] = tmp[\"high\"] - tmp[\"low\"]\n        tmp[\"hc\"] = abs(tmp[\"high\"] - tmp[\"close\"].shift(1))\n        tmp[\"lc\"] = abs(tmp[\"low\"] - tmp[\"close\"].shift(1))\n        tmp[\"tr\"] = tmp[[\"hl\", \"hc\", \"lc\"]].max(axis=1)\n        atr = tmp[\"tr\"].rolling(window=14).mean().iloc[-1]\n        if pd.isna(atr):\n            atr = precio_actual * 0.01\n        config[\"sl_ratio\"] = round(abs(precio_actual - sl) / atr, 2)\n        config[\"tp_ratio\"] = round(abs(tp - precio_actual) / atr, 2)\n    guardar_configuracion_simbolo(symbol, config)\n    log.info(f\"\ud83d\udd27 Configuraci\u00f3n actualizada para {symbol}\")\n\n\ndef procesar_simbolo(symbol: str, ruta: str) -> None:\n    metricas_diarias = analizar_estrategias_en_ordenes(ruta, dias=1)\n    if metricas_diarias.empty:\n        log.info(f\"[{symbol}] Sin operaciones diarias para evaluar\")\n    else:\n        actualizar_pesos_estrategias_symbol(symbol)\n    df = pd.read_parquet(ruta)\n    _actualizar_config(symbol, df.tail(60))\n    feedback = _cargar_feedback(symbol)\n    _aplicar_feedback_pesos(symbol, feedback)\n    rm = RiskManager(0.03)\n    semana = df[df[\"timestamp\"] >= (datetime.utcnow() - pd.Timedelta(days=7)).timestamp()]\n    metricas = {\n        \"ganancia_semana\": semana.get(\"retorno_total\", pd.Series()).sum(),\n        \"winrate\": (semana.get(\"retorno_total\", pd.Series()) > 0).mean(),\n        \"drawdown\": semana.get(\"retorno_total\", pd.Series()).min(),\n    }\n    rm.ajustar_umbral(metricas)\n\n\ndef ejecutar_ciclo() -> None:\n    archivos = glob.glob(os.path.join(CARPETA_ORDENES, \"*.parquet\"))\n    if not archivos:\n        log.warning(f\"\u26a0\ufe0f No se encontraron \u00f3rdenes en {CARPETA_ORDENES}\")\n        return\n    for ruta in archivos:\n        symbol = os.path.splitext(os.path.basename(ruta))[0].replace(\"_\", \"/\")\n        procesar_simbolo(symbol, ruta)\n    if datetime.utcnow().weekday() == 0:\n        recalibrar_pesos_semana()\n\n\nif __name__ == \"__main__\":\n    ejecutar_ciclo()"]]], 1750727261.8764026]], ["ChangeSet", ["Writing file <learning/aprendizaje_en_linea.py>", [["ChangeContents", ["learning/aprendizaje_en_linea.py", "import os\nimport json\nimport pandas as pd\nfrom collections import defaultdict\nfrom core.strategies.pesos import gestor_pesos\nfrom core.adaptador_dinamico import (\n    calcular_umbral_adaptativo,\n    calcular_tp_sl_adaptativos,\n)\nfrom config.configuracion import (\n    cargar_configuracion_simbolo,\n    guardar_configuracion_simbolo,\n)\nfrom core.utils.utils import configurar_logger\n\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nCARPETA_OPERACIONES = os.path.join(BASE_DIR, \"ultimas_operaciones\")\nRUTA_PESOS = \"config/estrategias_pesos.json\"\nMAX_OPERACIONES = 30\nMIN_OPERACIONES = 5\n# Nuevo tama\u00f1o de ventana para actualizar pesos\nVENTANA_ACTUALIZACION = 10\n\nlog = configurar_logger(\"trader_simulado\", modo_silencioso=True)\nos.makedirs(CARPETA_OPERACIONES, exist_ok=True)\n\n\ndef registrar_resultado_trade(symbol: str, orden: dict, ganancia: float):\n    archivo = os.path.join(CARPETA_OPERACIONES, symbol.replace(\"/\", \"_\").upper() + \".parquet\")\n\n    # ---------- Leer historial anterior de operaciones ----------\n    historial = []\n    if os.path.exists(archivo):\n        try:\n            df_prev = pd.read_parquet(archivo)\n            historial = df_prev.to_dict(\"records\")\n        except Exception as e:\n            print(f\"\u26a0\ufe0f Archivo da\u00f1ado: {archivo} \u2014 se sobrescribir\u00e1. Error: {e}\")\n            historial = []\n\n    # ---------- Validaci\u00f3n segura del campo 'estrategias_activas' ----------\n    estrategias_activas = orden.get(\"estrategias_activas\", {})\n    if isinstance(estrategias_activas, str):\n        try:\n            estrategias_activas = json.loads(estrategias_activas.replace(\"'\", \"\\\"\"))\n        except Exception as e:\n            print(f\"\u274c Error al parsear estrategias activas de {symbol}: {e}\")\n            estrategias_activas = {}\n\n    # ---------- Agregar la nueva operaci\u00f3n ----------\n    nueva_operacion = {\n        \"retorno_total\": ganancia,\n        \"estrategias_activas\": estrategias_activas\n    }\n\n    historial.append(nueva_operacion)\n    historial = historial[-MAX_OPERACIONES:]\n\n    # ---------- Guardar el historial actualizado ----------\n    try:\n        df_guardar = pd.DataFrame(historial)\n        df_guardar.to_parquet(archivo, index=False)\n    except Exception as e:\n        print(f\"\u274c Error al guardar historial para {symbol}: {e}\")\n        return\n\n    if len(historial) >= VENTANA_ACTUALIZACION and len(historial) % VENTANA_ACTUALIZACION == 0:\n        ventana = historial[-VENTANA_ACTUALIZACION:]\n        actualizar_pesos_dinamicos(symbol, ventana)\n\n\ndef actualizar_pesos_dinamicos(symbol: str, historial: list, factor_ajuste=0.05):\n    datos = defaultdict(list)\n\n    # Cargar los pesos actuales\n    pesos_actuales = gestor_pesos.obtener_pesos_symbol(symbol)\n\n    # Agrupar retornos por estrategia activa\n    for orden in historial:\n        estrategias = orden.get(\"estrategias_activas\", {})\n        if isinstance(estrategias, str):\n            try:\n                estrategias = json.loads(estrategias.replace(\"'\", \"\\\"\"))\n            except:\n                continue\n        retorno = orden.get(\"retorno_total\", 0.0)\n        for estrategia, activa in estrategias.items():\n            if activa:\n                datos[estrategia].append(retorno)\n\n    # Aplicar ajustes solo a estrategias activas\n    nuevos_pesos = pesos_actuales.copy()\n    for estrategia, retornos in datos.items():\n        if len(retornos) < MIN_OPERACIONES:\n            continue\n\n        promedio = sum(retornos) / len(retornos)\n        winrate = sum(1 for r in retornos if r > 0) / len(retornos)\n\n        peso_anterior = nuevos_pesos.get(estrategia, 0.5)\n        peso_objetivo = min(1.0, max(0.0, promedio * winrate))  # entre 0 y 1\n\n        # \u2705 Mezcla suave: 98% peso actual, 2% nuevo\n        nuevos_pesos[estrategia] = peso_anterior * 0.98 + peso_objetivo * 0.02\n\n\n    # Guardar\n    pesos_totales = gestor_pesos.pesos\n    pesos_totales[symbol] = nuevos_pesos\n    gestor_pesos.guardar(pesos_totales)\n\n    print(f\"\\n\ud83e\udde0 Pesos ajustados din\u00e1micamente para {symbol}:\")\n    for estrategia, peso in nuevos_pesos.items():\n        print(f\"  - {estrategia}: {peso:.3f}\")\n\n    # Calcular y guardar nuevo umbral (si hay al menos una estrategia activa en la \u00faltima operaci\u00f3n)\n    try:\n        df_fake = pd.DataFrame(historial)\n        estrategias = df_fake.iloc[-1].get(\"estrategias_activas\", {})\n        if isinstance(estrategias, str):\n            estrategias = json.loads(estrategias.replace(\"'\", \"\\\"\"))\n        if estrategias:\n            umbral = calcular_umbral_adaptativo(\n                symbol,\n                df_fake,\n                estrategias,\n                nuevos_pesos,\n                persistencia=0.0,\n            )\n            print(f\"\ud83d\udcc8 Umbral estimado para {symbol}: {umbral:.2f}\")\n\n            config_actual = cargar_configuracion_simbolo(symbol) or {}\n            config_actual[\"umbral_adaptativo\"] = round(float(umbral), 2)\n\n            precio_actual = None\n            if \"close\" in df_fake.columns:\n                precio_actual = float(df_fake[\"close\"].iloc[-1])\n\n            if precio_actual is not None and all(c in df_fake.columns for c in [\"high\", \"low\", \"close\"]):\n                sl, tp = calcular_tp_sl_adaptativos(\n                    symbol,\n                    df_fake,\n                    config_actual,\n                    None,\n                    precio_actual,\n                )\n                df_tmp = df_fake.copy()\n                df_tmp[\"hl\"] = df_tmp[\"high\"] - df_tmp[\"low\"]\n                df_tmp[\"hc\"] = abs(df_tmp[\"high\"] - df_tmp[\"close\"].shift(1))\n                df_tmp[\"lc\"] = abs(df_tmp[\"low\"] - df_tmp[\"close\"].shift(1))\n                df_tmp[\"tr\"] = df_tmp[[\"hl\", \"hc\", \"lc\"]].max(axis=1)\n                atr = df_tmp[\"tr\"].rolling(window=14).mean().iloc[-1]\n                if pd.isna(atr):\n                    atr = precio_actual * 0.01\n                config_actual[\"sl_ratio\"] = round(abs(precio_actual - sl) / atr, 2)\n                config_actual[\"tp_ratio\"] = round(abs(tp - precio_actual) / atr, 2)\n\n            guardar_configuracion_simbolo(symbol, config_actual)\n    except Exception as e:\n        print(f\"\u274c Error al recalcular/guardar umbral para {symbol}: {e}\")\n\n", "import os\nimport json\nimport pandas as pd\nfrom collections import defaultdict\nfrom core.strategies.pesos import gestor_pesos\nfrom core.adaptador_dinamico import (\n    calcular_umbral_adaptativo,\n    calcular_tp_sl_adaptativos,\n)\nfrom pegaso.config.configuracion import (\n    cargar_configuracion_simbolo,\n    guardar_configuracion_simbolo,\n)\nfrom pegaso.core.utils.utils import configurar_logger\n\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nCARPETA_OPERACIONES = os.path.join(BASE_DIR, \"ultimas_operaciones\")\nRUTA_PESOS = \"config/estrategias_pesos.json\"\nMAX_OPERACIONES = 30\nMIN_OPERACIONES = 5\n# Nuevo tama\u00f1o de ventana para actualizar pesos\nVENTANA_ACTUALIZACION = 10\n\nlog = configurar_logger(\"trader_simulado\", modo_silencioso=True)\nos.makedirs(CARPETA_OPERACIONES, exist_ok=True)\n\n\ndef registrar_resultado_trade(symbol: str, orden: dict, ganancia: float):\n    archivo = os.path.join(CARPETA_OPERACIONES, symbol.replace(\"/\", \"_\").upper() + \".parquet\")\n\n    # ---------- Leer historial anterior de operaciones ----------\n    historial = []\n    if os.path.exists(archivo):\n        try:\n            df_prev = pd.read_parquet(archivo)\n            historial = df_prev.to_dict(\"records\")\n        except Exception as e:\n            print(f\"\u26a0\ufe0f Archivo da\u00f1ado: {archivo} \u2014 se sobrescribir\u00e1. Error: {e}\")\n            historial = []\n\n    # ---------- Validaci\u00f3n segura del campo 'estrategias_activas' ----------\n    estrategias_activas = orden.get(\"estrategias_activas\", {})\n    if isinstance(estrategias_activas, str):\n        try:\n            estrategias_activas = json.loads(estrategias_activas.replace(\"'\", \"\\\"\"))\n        except Exception as e:\n            print(f\"\u274c Error al parsear estrategias activas de {symbol}: {e}\")\n            estrategias_activas = {}\n\n    # ---------- Agregar la nueva operaci\u00f3n ----------\n    nueva_operacion = {\n        \"retorno_total\": ganancia,\n        \"estrategias_activas\": estrategias_activas\n    }\n\n    historial.append(nueva_operacion)\n    historial = historial[-MAX_OPERACIONES:]\n\n    # ---------- Guardar el historial actualizado ----------\n    try:\n        df_guardar = pd.DataFrame(historial)\n        df_guardar.to_parquet(archivo, index=False)\n    except Exception as e:\n        print(f\"\u274c Error al guardar historial para {symbol}: {e}\")\n        return\n\n    if len(historial) >= VENTANA_ACTUALIZACION and len(historial) % VENTANA_ACTUALIZACION == 0:\n        ventana = historial[-VENTANA_ACTUALIZACION:]\n        actualizar_pesos_dinamicos(symbol, ventana)\n\n\ndef actualizar_pesos_dinamicos(symbol: str, historial: list, factor_ajuste=0.05):\n    datos = defaultdict(list)\n\n    # Cargar los pesos actuales\n    pesos_actuales = gestor_pesos.obtener_pesos_symbol(symbol)\n\n    # Agrupar retornos por estrategia activa\n    for orden in historial:\n        estrategias = orden.get(\"estrategias_activas\", {})\n        if isinstance(estrategias, str):\n            try:\n                estrategias = json.loads(estrategias.replace(\"'\", \"\\\"\"))\n            except:\n                continue\n        retorno = orden.get(\"retorno_total\", 0.0)\n        for estrategia, activa in estrategias.items():\n            if activa:\n                datos[estrategia].append(retorno)\n\n    # Aplicar ajustes solo a estrategias activas\n    nuevos_pesos = pesos_actuales.copy()\n    for estrategia, retornos in datos.items():\n        if len(retornos) < MIN_OPERACIONES:\n            continue\n\n        promedio = sum(retornos) / len(retornos)\n        winrate = sum(1 for r in retornos if r > 0) / len(retornos)\n\n        peso_anterior = nuevos_pesos.get(estrategia, 0.5)\n        peso_objetivo = min(1.0, max(0.0, promedio * winrate))  # entre 0 y 1\n\n        # \u2705 Mezcla suave: 98% peso actual, 2% nuevo\n        nuevos_pesos[estrategia] = peso_anterior * 0.98 + peso_objetivo * 0.02\n\n\n    # Guardar\n    pesos_totales = gestor_pesos.pesos\n    pesos_totales[symbol] = nuevos_pesos\n    gestor_pesos.guardar(pesos_totales)\n\n    print(f\"\\n\ud83e\udde0 Pesos ajustados din\u00e1micamente para {symbol}:\")\n    for estrategia, peso in nuevos_pesos.items():\n        print(f\"  - {estrategia}: {peso:.3f}\")\n\n    # Calcular y guardar nuevo umbral (si hay al menos una estrategia activa en la \u00faltima operaci\u00f3n)\n    try:\n        df_fake = pd.DataFrame(historial)\n        estrategias = df_fake.iloc[-1].get(\"estrategias_activas\", {})\n        if isinstance(estrategias, str):\n            estrategias = json.loads(estrategias.replace(\"'\", \"\\\"\"))\n        if estrategias:\n            umbral = calcular_umbral_adaptativo(\n                symbol,\n                df_fake,\n                estrategias,\n                nuevos_pesos,\n                persistencia=0.0,\n            )\n            print(f\"\ud83d\udcc8 Umbral estimado para {symbol}: {umbral:.2f}\")\n\n            config_actual = cargar_configuracion_simbolo(symbol) or {}\n            config_actual[\"umbral_adaptativo\"] = round(float(umbral), 2)\n\n            precio_actual = None\n            if \"close\" in df_fake.columns:\n                precio_actual = float(df_fake[\"close\"].iloc[-1])\n\n            if precio_actual is not None and all(c in df_fake.columns for c in [\"high\", \"low\", \"close\"]):\n                sl, tp = calcular_tp_sl_adaptativos(\n                    symbol,\n                    df_fake,\n                    config_actual,\n                    None,\n                    precio_actual,\n                )\n                df_tmp = df_fake.copy()\n                df_tmp[\"hl\"] = df_tmp[\"high\"] - df_tmp[\"low\"]\n                df_tmp[\"hc\"] = abs(df_tmp[\"high\"] - df_tmp[\"close\"].shift(1))\n                df_tmp[\"lc\"] = abs(df_tmp[\"low\"] - df_tmp[\"close\"].shift(1))\n                df_tmp[\"tr\"] = df_tmp[[\"hl\", \"hc\", \"lc\"]].max(axis=1)\n                atr = df_tmp[\"tr\"].rolling(window=14).mean().iloc[-1]\n                if pd.isna(atr):\n                    atr = precio_actual * 0.01\n                config_actual[\"sl_ratio\"] = round(abs(precio_actual - sl) / atr, 2)\n                config_actual[\"tp_ratio\"] = round(abs(tp - precio_actual) / atr, 2)\n\n            guardar_configuracion_simbolo(symbol, config_actual)\n    except Exception as e:\n        print(f\"\u274c Error al recalcular/guardar umbral para {symbol}: {e}\")\n\n"]]], 1750727261.9355447]], ["ChangeSet", ["Writing file <learning/entrenador_estrategias.py>", [["ChangeContents", ["learning/entrenador_estrategias.py", "import os\nimport json\nimport time\nimport pandas as pd\nfrom collections import defaultdict\nfrom dotenv import dotenv_values\nfrom core.strategies.pesos import gestor_pesos\nfrom core.utils.utils import configurar_logger\n\n# Cargar configuraci\u00f3n del .env\nCONFIG = dotenv_values(\"config/claves.env\")\nMODO_REAL = CONFIG.get(\"MODO_REAL\", \"False\") == \"True\"\nCARPETA_ORDENES = \"ordenes_reales\" if MODO_REAL else \"ordenes_simuladas\"\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nCARPETA_HISTORICO = os.path.join(BASE_DIR, \"ultimas_operaciones\")\nRUTA_PESOS = \"config/estrategias_pesos.json\"\nMIN_OPERACIONES = 5\n\nlog = configurar_logger(\"trader_simulado\", modo_silencioso=True)\n\ndef evaluar_estrategias(ordenes: pd.DataFrame):\n    datos = defaultdict(list)\n    for _, orden in ordenes.iterrows():\n        estrategias = orden.get(\"estrategias_activas\", {})\n        if isinstance(estrategias, str):\n            try:\n                estrategias = json.loads(estrategias.replace(\"'\", \"\\\"\"))\n            except Exception as e:\n                print(f\"\u26a0\ufe0f Error al parsear estrategias: {e}\")\n                continue\n        retorno = orden.get(\"retorno_total\", 0.0)\n        for estrategia, activa in estrategias.items():\n            if activa:\n                datos[estrategia].append(retorno)\n    return datos\n\ndef normalizar_scores(scores):\n    max_score = max(scores.values(), default=1)\n    return {k: v / max_score for k, v in scores.items()}\n\ndef dividir_train_test(df: pd.DataFrame, test_ratio: float = 0.2):\n    \"\"\"Divide el DataFrame en particiones de entrenamiento y prueba.\"\"\"\n    if df.empty:\n        return df, pd.DataFrame()\n    n_test = max(1, int(len(df) * test_ratio))\n    df_train = df.iloc[:-n_test]\n    df_test = df.iloc[-n_test:]\n    return df_train, df_test\n\ndef actualizar_pesos_estrategias_symbol(symbol: str):\n    FACTOR_SUAVIZADO = 0.02  # 2% de ajuste diario m\u00e1ximo\n\n    archivo = f\"{symbol.replace('/', '_').upper()}.parquet\"\n    ruta = os.path.join(CARPETA_HISTORICO, archivo)\n\n    for intento in range(3):\n        if os.path.exists(ruta):\n            break\n        time.sleep(0.3)\n\n    if not os.path.exists(ruta):\n        print(f\"\u26a0\ufe0f No se encontr\u00f3 historial para {symbol} en {CARPETA_HISTORICO}\")\n        return\n\n    try:\n        ordenes = pd.read_parquet(ruta)\n    except Exception as e:\n        print(f\"\u274c Error al leer el archivo {ruta}: {e}\")\n        return\n\n    if len(ordenes) < MIN_OPERACIONES:\n        log.info(f\"\u26a0\ufe0f Insuficientes operaciones para {symbol}.\")\n        return\n\n    train_df, test_df = dividir_train_test(ordenes)\n\n    # FACTOR_SUAVIZADO adaptativo seg\u00fan la volatilidad de los retornos\n    if \"retorno_total\" in train_df.columns:\n        vol_ret = train_df[\"retorno_total\"].std() or 0.0\n    else:\n        vol_ret = 0.0\n    FACTOR_SUAVIZADO = max(0.01, min(0.05, 0.02 + vol_ret * 0.1))\n\n    datos_estrategias = evaluar_estrategias(train_df)\n    nuevos_scores = {}\n\n    for estrategia, retornos in datos_estrategias.items():\n        if len(retornos) < MIN_OPERACIONES:\n            continue\n        promedio = sum(retornos) / len(retornos)\n        winrate = sum(1 for r in retornos if r > 0) / len(retornos)\n        score = promedio * winrate * 100\n        if score > 0:\n            nuevos_scores[estrategia] = score\n\n    if not nuevos_scores:\n        log.info(f\"\u26a0\ufe0f No se generaron scores v\u00e1lidos para {symbol}.\")\n        return\n\n    # Normalizaci\u00f3n de los nuevos scores (entre 0 y 1)\n    nuevos_scores_normalizados = normalizar_scores(nuevos_scores)\n\n    # Cargar pesos actuales\n    pesos_totales = gestor_pesos.pesos\n    pesos_actuales = pesos_totales.get(symbol, {})\n\n    # Aplicar suavizado\n    pesos_suavizados = pesos_actuales.copy()\n    for estrategia, score in nuevos_scores_normalizados.items():\n        peso_actual = pesos_actuales.get(estrategia, 0.5)\n        peso_nuevo = peso_actual * (1 - FACTOR_SUAVIZADO) + score * FACTOR_SUAVIZADO\n        pesos_suavizados[estrategia] = peso_nuevo\n\n    # Guardar nuevos pesos\n    pesos_totales[symbol] = pesos_suavizados\n    gestor_pesos.guardar(pesos_totales)\n\n    print(f\"\u2705 Pesos suavizados para {symbol} en modo {'REAL' if MODO_REAL else 'SIMULADO'}:\")\n    for estrategia, peso in pesos_suavizados.items():\n        print(f\"  - {estrategia}: {peso:.3f}\")\n\n    # --------- Validaci\u00f3n b\u00e1sica usando el conjunto de prueba ---------\n    datos_test = evaluar_estrategias(test_df)\n    resultados = [r for lst in datos_test.values() for r in lst]\n    if resultados:\n        promedio = sum(resultados) / len(resultados)\n        winrate = sum(1 for r in resultados if r > 0) / len(resultados)\n        log.info(\n            f\"\ud83d\udcca Validaci\u00f3n {symbol}: retorno medio {promedio:.3f}, winrate {winrate*100:.2f}%\"\n        )\n", "import os\nimport json\nimport time\nimport pandas as pd\nfrom collections import defaultdict\nfrom dotenv import dotenv_values\nfrom core.strategies.pesos import gestor_pesos\nfrom pegaso.core.utils.utils import configurar_logger\n\n# Cargar configuraci\u00f3n del .env\nCONFIG = dotenv_values(\"config/claves.env\")\nMODO_REAL = CONFIG.get(\"MODO_REAL\", \"False\") == \"True\"\nCARPETA_ORDENES = \"ordenes_reales\" if MODO_REAL else \"ordenes_simuladas\"\nBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nCARPETA_HISTORICO = os.path.join(BASE_DIR, \"ultimas_operaciones\")\nRUTA_PESOS = \"config/estrategias_pesos.json\"\nMIN_OPERACIONES = 5\n\nlog = configurar_logger(\"trader_simulado\", modo_silencioso=True)\n\ndef evaluar_estrategias(ordenes: pd.DataFrame):\n    datos = defaultdict(list)\n    for _, orden in ordenes.iterrows():\n        estrategias = orden.get(\"estrategias_activas\", {})\n        if isinstance(estrategias, str):\n            try:\n                estrategias = json.loads(estrategias.replace(\"'\", \"\\\"\"))\n            except Exception as e:\n                print(f\"\u26a0\ufe0f Error al parsear estrategias: {e}\")\n                continue\n        retorno = orden.get(\"retorno_total\", 0.0)\n        for estrategia, activa in estrategias.items():\n            if activa:\n                datos[estrategia].append(retorno)\n    return datos\n\ndef normalizar_scores(scores):\n    max_score = max(scores.values(), default=1)\n    return {k: v / max_score for k, v in scores.items()}\n\ndef dividir_train_test(df: pd.DataFrame, test_ratio: float = 0.2):\n    \"\"\"Divide el DataFrame en particiones de entrenamiento y prueba.\"\"\"\n    if df.empty:\n        return df, pd.DataFrame()\n    n_test = max(1, int(len(df) * test_ratio))\n    df_train = df.iloc[:-n_test]\n    df_test = df.iloc[-n_test:]\n    return df_train, df_test\n\ndef actualizar_pesos_estrategias_symbol(symbol: str):\n    FACTOR_SUAVIZADO = 0.02  # 2% de ajuste diario m\u00e1ximo\n\n    archivo = f\"{symbol.replace('/', '_').upper()}.parquet\"\n    ruta = os.path.join(CARPETA_HISTORICO, archivo)\n\n    for intento in range(3):\n        if os.path.exists(ruta):\n            break\n        time.sleep(0.3)\n\n    if not os.path.exists(ruta):\n        print(f\"\u26a0\ufe0f No se encontr\u00f3 historial para {symbol} en {CARPETA_HISTORICO}\")\n        return\n\n    try:\n        ordenes = pd.read_parquet(ruta)\n    except Exception as e:\n        print(f\"\u274c Error al leer el archivo {ruta}: {e}\")\n        return\n\n    if len(ordenes) < MIN_OPERACIONES:\n        log.info(f\"\u26a0\ufe0f Insuficientes operaciones para {symbol}.\")\n        return\n\n    train_df, test_df = dividir_train_test(ordenes)\n\n    # FACTOR_SUAVIZADO adaptativo seg\u00fan la volatilidad de los retornos\n    if \"retorno_total\" in train_df.columns:\n        vol_ret = train_df[\"retorno_total\"].std() or 0.0\n    else:\n        vol_ret = 0.0\n    FACTOR_SUAVIZADO = max(0.01, min(0.05, 0.02 + vol_ret * 0.1))\n\n    datos_estrategias = evaluar_estrategias(train_df)\n    nuevos_scores = {}\n\n    for estrategia, retornos in datos_estrategias.items():\n        if len(retornos) < MIN_OPERACIONES:\n            continue\n        promedio = sum(retornos) / len(retornos)\n        winrate = sum(1 for r in retornos if r > 0) / len(retornos)\n        score = promedio * winrate * 100\n        if score > 0:\n            nuevos_scores[estrategia] = score\n\n    if not nuevos_scores:\n        log.info(f\"\u26a0\ufe0f No se generaron scores v\u00e1lidos para {symbol}.\")\n        return\n\n    # Normalizaci\u00f3n de los nuevos scores (entre 0 y 1)\n    nuevos_scores_normalizados = normalizar_scores(nuevos_scores)\n\n    # Cargar pesos actuales\n    pesos_totales = gestor_pesos.pesos\n    pesos_actuales = pesos_totales.get(symbol, {})\n\n    # Aplicar suavizado\n    pesos_suavizados = pesos_actuales.copy()\n    for estrategia, score in nuevos_scores_normalizados.items():\n        peso_actual = pesos_actuales.get(estrategia, 0.5)\n        peso_nuevo = peso_actual * (1 - FACTOR_SUAVIZADO) + score * FACTOR_SUAVIZADO\n        pesos_suavizados[estrategia] = peso_nuevo\n\n    # Guardar nuevos pesos\n    pesos_totales[symbol] = pesos_suavizados\n    gestor_pesos.guardar(pesos_totales)\n\n    print(f\"\u2705 Pesos suavizados para {symbol} en modo {'REAL' if MODO_REAL else 'SIMULADO'}:\")\n    for estrategia, peso in pesos_suavizados.items():\n        print(f\"  - {estrategia}: {peso:.3f}\")\n\n    # --------- Validaci\u00f3n b\u00e1sica usando el conjunto de prueba ---------\n    datos_test = evaluar_estrategias(test_df)\n    resultados = [r for lst in datos_test.values() for r in lst]\n    if resultados:\n        promedio = sum(resultados) / len(resultados)\n        winrate = sum(1 for r in resultados if r > 0) / len(resultados)\n        log.info(\n            f\"\ud83d\udcca Validaci\u00f3n {symbol}: retorno medio {promedio:.3f}, winrate {winrate*100:.2f}%\"\n        )\n"]]], 1750727262.0102286]], ["ChangeSet", ["Writing file <scripts/migrate_parquet_to_db.py>", [["ChangeContents", ["scripts/migrate_parquet_to_db.py", "import os\nimport pandas as pd\nfrom core.ordenes_model import Orden\nfrom core.orders import ordenes_reales\n\nPARQUET_PATH = os.path.join(\"ordenes_reales\", \"ordenes_reales.parquet\")\n\n\ndef migrate():\n    if not os.path.exists(PARQUET_PATH):\n        print(\"No hay archivo Parquet para migrar.\")\n        return\n    try:\n        df = pd.read_parquet(PARQUET_PATH)\n    except Exception as e:\n        print(f\"Error leyendo archivo Parquet: {e}\")\n        return\n\n    count = 0\n    for _, row in df.iterrows():\n        orden = Orden.from_dict(row.to_dict())\n        ordenes_reales.actualizar_orden(orden.symbol, orden)\n        count += 1\n\n    backup = PARQUET_PATH + \".bak\"\n    os.rename(PARQUET_PATH, backup)\n    print(f\"Migradas {count} \u00f3rdenes. Archivo original movido a {backup}\")\n\n\nif __name__ == \"__main__\":\n    migrate()", "import os\nimport pandas as pd\nfrom core.ordenes_model import Orden\nfrom pegaso.core.orders import ordenes_reales\n\nPARQUET_PATH = os.path.join(\"ordenes_reales\", \"ordenes_reales.parquet\")\n\n\ndef migrate():\n    if not os.path.exists(PARQUET_PATH):\n        print(\"No hay archivo Parquet para migrar.\")\n        return\n    try:\n        df = pd.read_parquet(PARQUET_PATH)\n    except Exception as e:\n        print(f\"Error leyendo archivo Parquet: {e}\")\n        return\n\n    count = 0\n    for _, row in df.iterrows():\n        orden = Orden.from_dict(row.to_dict())\n        ordenes_reales.actualizar_orden(orden.symbol, orden)\n        count += 1\n\n    backup = PARQUET_PATH + \".bak\"\n    os.rename(PARQUET_PATH, backup)\n    print(f\"Migradas {count} \u00f3rdenes. Archivo original movido a {backup}\")\n\n\nif __name__ == \"__main__\":\n    migrate()"]]], 1750727262.0800831]], ["ChangeSet", ["Writing file <scripts/refactor_imports.py>", [["ChangeContents", ["scripts/refactor_imports.py", "from rope.base.project import Project\nfrom rope.base.libutils import path_to_resource\nimport os\n\n# Ruta base del proyecto (asume que est\u00e1s en la ra\u00edz)\nruta_proyecto = os.path.abspath(\".\")\nproyecto = Project(ruta_proyecto)\n\nprint(\"\ud83d\ude80 Iniciando refactorizaci\u00f3n de imports ''...\")\n\n# Directorios que deben ser ignorados\nEXCLUIR_DIRS = {\"venv\", \".git\", \"__pycache__\", \".pytest_cache\", \"node_modules\"}\n\nfor carpeta, _, archivos in os.walk(ruta_proyecto):\n    # Salta cualquier carpeta que contenga uno de los excluidos\n    if any(excluir in carpeta for excluir in EXCLUIR_DIRS):\n        continue\n\n    for archivo in archivos:\n        if archivo.endswith(\".py\"):\n            ruta_archivo = os.path.join(carpeta, archivo)\n            try:\n                recurso = path_to_resource(proyecto, ruta_archivo)\n                contenido = recurso.read()  # \u2190 esto ya devuelve un `str`\n                if \"\" in contenido:\n                    nuevo_contenido = contenido.replace(\"\", \"\")\n                    recurso.write(nuevo_contenido)  # \u2190 escribimos str directamente\n                    print(f\"\u2705 Refactorizado: {ruta_archivo}\")\n            except Exception as e:\n                print(f\"\u26a0\ufe0f Error en {ruta_archivo}: {e}\")\n\nproyecto.close()\nprint(\"\\n\ud83c\udf89 Refactorizaci\u00f3n completada sin uso de .decode() innecesario.\")\n\n", "from rope.base.project import Project\nfrom rope.base.libutils import path_to_resource\nimport os\n\n# Ruta base del proyecto (asume que est\u00e1s en la ra\u00edz)\nruta_proyecto = os.path.abspath(\".\")\nproyecto = Project(ruta_proyecto)\n\nprint(\"\ud83d\ude80 Iniciando refactorizaci\u00f3n de imports 'pegaso.'...\")\n\n# Directorios que deben ser ignorados\nEXCLUIR_DIRS = {\"venv\", \".git\", \"__pycache__\", \".pytest_cache\", \"node_modules\"}\n\nfor carpeta, _, archivos in os.walk(ruta_proyecto):\n    # Salta cualquier carpeta que contenga uno de los excluidos\n    if any(excluir in carpeta for excluir in EXCLUIR_DIRS):\n        continue\n\n    for archivo in archivos:\n        if archivo.endswith(\".py\"):\n            ruta_archivo = os.path.join(carpeta, archivo)\n            try:\n                recurso = path_to_resource(proyecto, ruta_archivo)\n                contenido = recurso.read()  # \u2190 esto ya devuelve un `str`\n                if \"pegaso.\" in contenido:\n                    nuevo_contenido = contenido.replace(\"pegaso.\", \"\")\n                    recurso.write(nuevo_contenido)  # \u2190 escribimos str directamente\n                    print(f\"\u2705 Refactorizado: {ruta_archivo}\")\n            except Exception as e:\n                print(f\"\u26a0\ufe0f Error en {ruta_archivo}: {e}\")\n\nproyecto.close()\nprint(\"\\n\ud83c\udf89 Refactorizaci\u00f3n completada sin uso de .decode() innecesario.\")\n\n"]]], 1750727262.2961106]], ["ChangeSet", ["Writing file <test/test_backtest.py>", [["ChangeContents", ["test/test_backtest.py", "import sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path(__file__).resolve().parents[1]))\n\n\n\nimport asyncio\nimport pandas as pd\nfrom config.config_manager import Config\nfrom backtesting.backtest import BacktestTrader\n\n\nclass DummyClient:\n    def fetch_balance(self):\n        return {\"total\": {\"EUR\": 1000}}\n\n\nasync def fake_fetch_balance_async(client):\n    return {\"total\": {\"EUR\": 1000}}\n\n\ndef generar_velas(n=40, symbol=\"BTC/EUR\"):\n    ts = pd.date_range(\"2024-01-01\", periods=n, freq=\"T\")\n    velas = []\n    precio = 100\n    for i, t in enumerate(ts):\n        vela = {\n            \"symbol\": symbol,\n            \"timestamp\": int(t.timestamp() * 1000),\n            \"open\": precio,\n            \"high\": precio + 1,\n            \"low\": precio - 1,\n            \"close\": precio + 1,\n            \"volume\": 10,\n        }\n        velas.append(vela)\n        precio += 1\n    return velas\n\n\ndef crear_trader(monkeypatch):\n    monkeypatch.setattr(\"core.trader_modular.crear_cliente\", lambda cfg: DummyClient())\n    monkeypatch.setattr(\"binance_api.cliente.crear_cliente\", lambda cfg=None: DummyClient())\n    monkeypatch.setattr(\"core.trader_modular.cargar_pesos_estrategias\", lambda: {\"BTC/EUR\": {\"s1\": 1}})\n    monkeypatch.setattr(\"core.ordenes_reales.obtener_todas_las_ordenes\", lambda: {})\n    monkeypatch.setattr(\"core.ordenes_reales.sincronizar_ordenes_binance\", lambda symbols: {})\n    monkeypatch.setattr(\"core.trader_modular.calcular_fraccion_kelly\", lambda: 1.0)\n    monkeypatch.setattr(\"pandas.read_parquet\", lambda *a, **k: pd.DataFrame({\"close\": [1, 2, 3, 4]}))\n    monkeypatch.setattr(\"core.trader_modular.fetch_balance_async\", fake_fetch_balance_async)\n\n    cfg = Config(\n        api_key=\"\",\n        api_secret=\"\",\n        modo_real=False,\n        intervalo_velas=\"1m\",\n        symbols=[\"BTC/EUR\"],\n        umbral_riesgo_diario=0.1,\n        min_order_eur=10,\n        persistencia_minima=1,\n        usar_score_tecnico=False,\n    )\n    return BacktestTrader(cfg)\n\n\ndef alimentar_velas(trader, n=40):\n    velas = generar_velas(n)\n    for vela in velas:\n        asyncio.run(trader._procesar_vela(vela))\n\n\ndef test_abre_operacion(monkeypatch):\n    trader = crear_trader(monkeypatch)\n    opened = {}\n\n    async def fake_eval(symbol, df, estado):\n        if trader.risk.riesgo_superado(1000):\n            return None\n        return {\n            \"symbol\": symbol,\n            \"precio\": df[\"close\"].iloc[-1],\n            \"sl\": 90,\n            \"tp\": 110,\n            \"estrategias\": {\"s1\": True},\n            \"tendencia\": \"alcista\",\n            \"direccion\": \"long\",\n            \"puntaje\": 5.0,\n            \"umbral\": 3.0,\n        }\n\n    async def fake_open(*args, **info):\n        opened[\"symbol\"] = args[0]\n\n    monkeypatch.setattr(trader, \"evaluar_condiciones_de_entrada\", fake_eval)\n    monkeypatch.setattr(trader.orders, \"abrir_async\", fake_open)\n    monkeypatch.setattr(trader.risk, \"riesgo_superado\", lambda capital: False)\n    async def qty(*args, **kwargs):\n        return 1.0\n    monkeypatch.setattr(trader, \"_calcular_cantidad_async\", qty)\n\n    alimentar_velas(trader)\n\n    assert opened.get(\"symbol\") == \"BTC/EUR\"\n\n\ndef test_riesgo_bloquea(monkeypatch):\n    trader = crear_trader(monkeypatch)\n    called = {}\n\n    async def fake_eval(symbol, df, estado):\n        if trader.risk.riesgo_superado(1000):\n            return None\n        return {\n            \"symbol\": symbol,\n            \"precio\": df[\"close\"].iloc[-1],\n            \"sl\": 90,\n            \"tp\": 110,\n            \"estrategias\": {\"s1\": True},\n            \"tendencia\": \"alcista\",\n            \"direccion\": \"long\",\n            \"puntaje\": 5.0,\n            \"umbral\": 3.0,\n        }\n\n    monkeypatch.setattr(trader, \"evaluar_condiciones_de_entrada\", fake_eval)\n\n    async def fake_open(*args, **info):\n        called[\"symbol\"] = args[0]\n\n    monkeypatch.setattr(trader.orders, \"abrir_async\", fake_open)\n    monkeypatch.setattr(trader.risk, \"riesgo_superado\", lambda capital: True)\n    async def qty(*args, **kwargs):\n        return 1.0\n    monkeypatch.setattr(trader, \"_calcular_cantidad_async\", qty)\n\n    alimentar_velas(trader)\n\n    assert not called\n\n\ndef test_capital_insuficiente(monkeypatch):\n    trader = crear_trader(monkeypatch)\n    called = {}\n\n    async def fake_eval(symbol, df, estado):\n        return {\n            \"symbol\": symbol,\n            \"precio\": df[\"close\"].iloc[-1],\n            \"sl\": 90,\n            \"tp\": 110,\n            \"estrategias\": {\"s1\": True},\n            \"tendencia\": \"alcista\",\n            \"direccion\": \"long\",\n            \"puntaje\": 5.0,\n            \"umbral\": 3.0,\n        }\n\n    monkeypatch.setattr(trader, \"evaluar_condiciones_de_entrada\", fake_eval)\n    async def fake_open_async(*args, **info):\n        called[\"symbol\"] = args[0]\n    monkeypatch.setattr(trader.orders, \"abrir_async\", fake_open_async)\n    monkeypatch.setattr(trader.risk, \"riesgo_superado\", lambda capital: False)\n    async def qty_zero(*args, **kwargs):\n        return 0.0\n    monkeypatch.setattr(trader, \"_calcular_cantidad_async\", qty_zero)\n\n    alimentar_velas(trader)\n\n    assert not called\n\n\ndef test_puntaje_insuficiente(monkeypatch):\n    trader = crear_trader(monkeypatch)\n    called = {}\n\n    async def fake_eval(symbol, df, estado):\n        return None\n\n    monkeypatch.setattr(trader, \"evaluar_condiciones_de_entrada\", fake_eval)\n    async def fake_open_async2(*args, **info):\n        called[\"symbol\"] = args[0]\n    monkeypatch.setattr(trader.orders, \"abrir_async\", fake_open_async2)\n    monkeypatch.setattr(trader.risk, \"riesgo_superado\", lambda capital: False)\n    async def qty(*args, **kwargs):\n        return 1.0\n    monkeypatch.setattr(trader, \"_calcular_cantidad_async\", qty)\n\n    alimentar_velas(trader)\n\n    assert not called", "import sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path(__file__).resolve().parents[1]))\n\n\n\nimport asyncio\nimport pandas as pd\nfrom pegaso.config.config_manager import Config\nfrom backtesting.backtest import BacktestTrader\n\n\nclass DummyClient:\n    def fetch_balance(self):\n        return {\"total\": {\"EUR\": 1000}}\n\n\nasync def fake_fetch_balance_async(client):\n    return {\"total\": {\"EUR\": 1000}}\n\n\ndef generar_velas(n=40, symbol=\"BTC/EUR\"):\n    ts = pd.date_range(\"2024-01-01\", periods=n, freq=\"T\")\n    velas = []\n    precio = 100\n    for i, t in enumerate(ts):\n        vela = {\n            \"symbol\": symbol,\n            \"timestamp\": int(t.timestamp() * 1000),\n            \"open\": precio,\n            \"high\": precio + 1,\n            \"low\": precio - 1,\n            \"close\": precio + 1,\n            \"volume\": 10,\n        }\n        velas.append(vela)\n        precio += 1\n    return velas\n\n\ndef crear_trader(monkeypatch):\n    monkeypatch.setattr(\"core.trader_modular.crear_cliente\", lambda cfg: DummyClient())\n    monkeypatch.setattr(\"binance_api.cliente.crear_cliente\", lambda cfg=None: DummyClient())\n    monkeypatch.setattr(\"core.trader_modular.cargar_pesos_estrategias\", lambda: {\"BTC/EUR\": {\"s1\": 1}})\n    monkeypatch.setattr(\"core.ordenes_reales.obtener_todas_las_ordenes\", lambda: {})\n    monkeypatch.setattr(\"core.ordenes_reales.sincronizar_ordenes_binance\", lambda symbols: {})\n    monkeypatch.setattr(\"core.trader_modular.calcular_fraccion_kelly\", lambda: 1.0)\n    monkeypatch.setattr(\"pandas.read_parquet\", lambda *a, **k: pd.DataFrame({\"close\": [1, 2, 3, 4]}))\n    monkeypatch.setattr(\"core.trader_modular.fetch_balance_async\", fake_fetch_balance_async)\n\n    cfg = Config(\n        api_key=\"\",\n        api_secret=\"\",\n        modo_real=False,\n        intervalo_velas=\"1m\",\n        symbols=[\"BTC/EUR\"],\n        umbral_riesgo_diario=0.1,\n        min_order_eur=10,\n        persistencia_minima=1,\n        usar_score_tecnico=False,\n    )\n    return BacktestTrader(cfg)\n\n\ndef alimentar_velas(trader, n=40):\n    velas = generar_velas(n)\n    for vela in velas:\n        asyncio.run(trader._procesar_vela(vela))\n\n\ndef test_abre_operacion(monkeypatch):\n    trader = crear_trader(monkeypatch)\n    opened = {}\n\n    async def fake_eval(symbol, df, estado):\n        if trader.risk.riesgo_superado(1000):\n            return None\n        return {\n            \"symbol\": symbol,\n            \"precio\": df[\"close\"].iloc[-1],\n            \"sl\": 90,\n            \"tp\": 110,\n            \"estrategias\": {\"s1\": True},\n            \"tendencia\": \"alcista\",\n            \"direccion\": \"long\",\n            \"puntaje\": 5.0,\n            \"umbral\": 3.0,\n        }\n\n    async def fake_open(*args, **info):\n        opened[\"symbol\"] = args[0]\n\n    monkeypatch.setattr(trader, \"evaluar_condiciones_de_entrada\", fake_eval)\n    monkeypatch.setattr(trader.orders, \"abrir_async\", fake_open)\n    monkeypatch.setattr(trader.risk, \"riesgo_superado\", lambda capital: False)\n    async def qty(*args, **kwargs):\n        return 1.0\n    monkeypatch.setattr(trader, \"_calcular_cantidad_async\", qty)\n\n    alimentar_velas(trader)\n\n    assert opened.get(\"symbol\") == \"BTC/EUR\"\n\n\ndef test_riesgo_bloquea(monkeypatch):\n    trader = crear_trader(monkeypatch)\n    called = {}\n\n    async def fake_eval(symbol, df, estado):\n        if trader.risk.riesgo_superado(1000):\n            return None\n        return {\n            \"symbol\": symbol,\n            \"precio\": df[\"close\"].iloc[-1],\n            \"sl\": 90,\n            \"tp\": 110,\n            \"estrategias\": {\"s1\": True},\n            \"tendencia\": \"alcista\",\n            \"direccion\": \"long\",\n            \"puntaje\": 5.0,\n            \"umbral\": 3.0,\n        }\n\n    monkeypatch.setattr(trader, \"evaluar_condiciones_de_entrada\", fake_eval)\n\n    async def fake_open(*args, **info):\n        called[\"symbol\"] = args[0]\n\n    monkeypatch.setattr(trader.orders, \"abrir_async\", fake_open)\n    monkeypatch.setattr(trader.risk, \"riesgo_superado\", lambda capital: True)\n    async def qty(*args, **kwargs):\n        return 1.0\n    monkeypatch.setattr(trader, \"_calcular_cantidad_async\", qty)\n\n    alimentar_velas(trader)\n\n    assert not called\n\n\ndef test_capital_insuficiente(monkeypatch):\n    trader = crear_trader(monkeypatch)\n    called = {}\n\n    async def fake_eval(symbol, df, estado):\n        return {\n            \"symbol\": symbol,\n            \"precio\": df[\"close\"].iloc[-1],\n            \"sl\": 90,\n            \"tp\": 110,\n            \"estrategias\": {\"s1\": True},\n            \"tendencia\": \"alcista\",\n            \"direccion\": \"long\",\n            \"puntaje\": 5.0,\n            \"umbral\": 3.0,\n        }\n\n    monkeypatch.setattr(trader, \"evaluar_condiciones_de_entrada\", fake_eval)\n    async def fake_open_async(*args, **info):\n        called[\"symbol\"] = args[0]\n    monkeypatch.setattr(trader.orders, \"abrir_async\", fake_open_async)\n    monkeypatch.setattr(trader.risk, \"riesgo_superado\", lambda capital: False)\n    async def qty_zero(*args, **kwargs):\n        return 0.0\n    monkeypatch.setattr(trader, \"_calcular_cantidad_async\", qty_zero)\n\n    alimentar_velas(trader)\n\n    assert not called\n\n\ndef test_puntaje_insuficiente(monkeypatch):\n    trader = crear_trader(monkeypatch)\n    called = {}\n\n    async def fake_eval(symbol, df, estado):\n        return None\n\n    monkeypatch.setattr(trader, \"evaluar_condiciones_de_entrada\", fake_eval)\n    async def fake_open_async2(*args, **info):\n        called[\"symbol\"] = args[0]\n    monkeypatch.setattr(trader.orders, \"abrir_async\", fake_open_async2)\n    monkeypatch.setattr(trader.risk, \"riesgo_superado\", lambda capital: False)\n    async def qty(*args, **kwargs):\n        return 1.0\n    monkeypatch.setattr(trader, \"_calcular_cantidad_async\", qty)\n\n    alimentar_velas(trader)\n\n    assert not called"]]], 1750727262.3225014]], ["ChangeSet", ["Writing file <test/test_entrada.py>", [["ChangeContents", ["test/test_entrada.py", "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\")))\n\nimport pandas as pd\nfrom core.strategies.entry.loader import cargar_estrategias\nfrom collections import defaultdict\nfrom pathlib import Path\nimport os\n\ndef cargar_datos_ejemplo():\n    archivo = Path(\"datos/btc_eur_1m.parquet\")  # Cambia aqu\u00ed si quieres otro s\u00edmbolo\n    if not archivo.exists():\n        raise FileNotFoundError(f\"No se encontr\u00f3 el archivo: {archivo}\")\n    df = pd.read_parquet(archivo)\n    return df\n\ndef test_contador_activaciones_y_csv():\n    df = cargar_datos_ejemplo()\n    estrategias = cargar_estrategias()\n    contador = defaultdict(int)\n\n    for i in range(100, len(df)):\n        sub_df = df.iloc[i-100:i].copy()\n        for nombre, funcion in estrategias.items():\n            try:\n                resultado = funcion(sub_df)\n                if isinstance(resultado, dict) and resultado.get(\"activo\", False):\n                    contador[nombre] += 1\n            except Exception as e:\n                print(f\"\u274c Error en estrategia {nombre}: {str(e)}\")\n\n    # Mostrar resultados\n    print(\"\\n\ud83d\udcca Activaciones por estrategia:\")\n    for nombre, cantidad in sorted(contador.items(), key=lambda x: -x[1]):\n        print(f\"\u27a1\ufe0f {nombre}: {cantidad} activaciones\")\n\n    # Guardar en CSV\n    resultados_df = pd.DataFrame([\n        {\"estrategia\": nombre, \"activaciones\": cantidad}\n        for nombre, cantidad in sorted(contador.items())\n    ])\n    os.makedirs(\"resultados\", exist_ok=True)\n    ruta_csv = Path(\"resultados/activaciones_estrategias.csv\")\n    resultados_df.to_csv(ruta_csv, index=False)\n    print(f\"\\n\u2705 Resultados guardados en: {ruta_csv.resolve()}\")\n\n    # Asegura que al menos una estrategia se haya activado\n    assert any(c > 0 for c in contador.values()), \"Ninguna estrategia se activ\u00f3\"", "import sys\nimport os\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\")))\n\nimport pandas as pd\nfrom pegaso.core.strategies.entry.loader import cargar_estrategias\nfrom collections import defaultdict\nfrom pathlib import Path\nimport os\n\ndef cargar_datos_ejemplo():\n    archivo = Path(\"datos/btc_eur_1m.parquet\")  # Cambia aqu\u00ed si quieres otro s\u00edmbolo\n    if not archivo.exists():\n        raise FileNotFoundError(f\"No se encontr\u00f3 el archivo: {archivo}\")\n    df = pd.read_parquet(archivo)\n    return df\n\ndef test_contador_activaciones_y_csv():\n    df = cargar_datos_ejemplo()\n    estrategias = cargar_estrategias()\n    contador = defaultdict(int)\n\n    for i in range(100, len(df)):\n        sub_df = df.iloc[i-100:i].copy()\n        for nombre, funcion in estrategias.items():\n            try:\n                resultado = funcion(sub_df)\n                if isinstance(resultado, dict) and resultado.get(\"activo\", False):\n                    contador[nombre] += 1\n            except Exception as e:\n                print(f\"\u274c Error en estrategia {nombre}: {str(e)}\")\n\n    # Mostrar resultados\n    print(\"\\n\ud83d\udcca Activaciones por estrategia:\")\n    for nombre, cantidad in sorted(contador.items(), key=lambda x: -x[1]):\n        print(f\"\u27a1\ufe0f {nombre}: {cantidad} activaciones\")\n\n    # Guardar en CSV\n    resultados_df = pd.DataFrame([\n        {\"estrategia\": nombre, \"activaciones\": cantidad}\n        for nombre, cantidad in sorted(contador.items())\n    ])\n    os.makedirs(\"resultados\", exist_ok=True)\n    ruta_csv = Path(\"resultados/activaciones_estrategias.csv\")\n    resultados_df.to_csv(ruta_csv, index=False)\n    print(f\"\\n\u2705 Resultados guardados en: {ruta_csv.resolve()}\")\n\n    # Asegura que al menos una estrategia se haya activado\n    assert any(c > 0 for c in contador.values()), \"Ninguna estrategia se activ\u00f3\""]]], 1750727262.3696134]], ["ChangeSet", ["Writing file <test/test_filtros_correlacion.py>", [["ChangeContents", ["test/test_filtros_correlacion.py", "import sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path(__file__).resolve().parents[1]))\n\nimport pandas as pd\nfrom core.strategies.entry.validador_entradas import verificar_liquidez_orden\nfrom core.strategies.entry.gestor_entradas import entrada_permitida\n\n\ndef test_verificar_liquidez_orden():\n    df = pd.DataFrame({\"volume\": [100] * 20})\n    assert not verificar_liquidez_orden(df, 30, ventana=20, factor=0.2)\n    assert verificar_liquidez_orden(df, 10, ventana=20, factor=0.2)\n\n\ndef test_entrada_rechazada_por_correlacion():\n    datos = {\"close\": list(range(30)), \"volume\": [100] * 30}\n    df1 = pd.DataFrame(datos)\n    df2 = pd.DataFrame(datos)\n    estrategias = {f\"e{i}\": True for i in range(5)}\n    permitido = entrada_permitida(\n        \"AAA\",\n        1.0,\n        0.5,\n        estrategias,\n        60,\n        1,\n        1,\n        df1,\n        \"long\",\n        cantidad=1,\n        df_referencia=df2,\n        umbral_correlacion=0.8,\n    )\n    assert permitido is False", "import sys\nfrom pathlib import Path\n\nsys.path.insert(0, str(Path(__file__).resolve().parents[1]))\n\nimport pandas as pd\nfrom pegaso.core.strategies.entry.validador_entradas import verificar_liquidez_orden\nfrom pegaso.core.strategies.entry.gestor_entradas import entrada_permitida\n\n\ndef test_verificar_liquidez_orden():\n    df = pd.DataFrame({\"volume\": [100] * 20})\n    assert not verificar_liquidez_orden(df, 30, ventana=20, factor=0.2)\n    assert verificar_liquidez_orden(df, 10, ventana=20, factor=0.2)\n\n\ndef test_entrada_rechazada_por_correlacion():\n    datos = {\"close\": list(range(30)), \"volume\": [100] * 30}\n    df1 = pd.DataFrame(datos)\n    df2 = pd.DataFrame(datos)\n    estrategias = {f\"e{i}\": True for i in range(5)}\n    permitido = entrada_permitida(\n        \"AAA\",\n        1.0,\n        0.5,\n        estrategias,\n        60,\n        1,\n        1,\n        df1,\n        \"long\",\n        cantidad=1,\n        df_referencia=df2,\n        umbral_correlacion=0.8,\n    )\n    assert permitido is False"]]], 1750727262.3948162]], ["ChangeSet", ["Writing file <test/test_loaders.py>", [["ChangeContents", ["test/test_loaders.py", "import unittest\n\nfrom core.strategies.entry.loader import cargar_estrategias\nfrom core.strategies.exit.loader_salidas import cargar_estrategias_salida\n\nclass TestStrategyLoaders(unittest.TestCase):\n    def test_cargar_estrategias(self):\n        estrategias = cargar_estrategias()\n        self.assertIsInstance(estrategias, dict)\n        self.assertTrue(estrategias, \"No se cargaron estrategias de entrada\")\n        for nombre, func in estrategias.items():\n            self.assertTrue(callable(func), f\"{nombre} no es callable\")\n\n    def test_cargar_estrategias_salida(self):\n        estrategias = cargar_estrategias_salida()\n        self.assertIsInstance(estrategias, list)\n        self.assertTrue(estrategias, \"No se cargaron estrategias de salida\")\n        for func in estrategias:\n            self.assertTrue(callable(func), f\"{func} no es callable\")\n\nif __name__ == '__main__':\n    unittest.main()", "import unittest\n\nfrom pegaso.core.strategies.entry.loader import cargar_estrategias\nfrom pegaso.core.strategies.exit.loader_salidas import cargar_estrategias_salida\n\nclass TestStrategyLoaders(unittest.TestCase):\n    def test_cargar_estrategias(self):\n        estrategias = cargar_estrategias()\n        self.assertIsInstance(estrategias, dict)\n        self.assertTrue(estrategias, \"No se cargaron estrategias de entrada\")\n        for nombre, func in estrategias.items():\n            self.assertTrue(callable(func), f\"{nombre} no es callable\")\n\n    def test_cargar_estrategias_salida(self):\n        estrategias = cargar_estrategias_salida()\n        self.assertIsInstance(estrategias, list)\n        self.assertTrue(estrategias, \"No se cargaron estrategias de salida\")\n        for func in estrategias:\n            self.assertTrue(callable(func), f\"{func} no es callable\")\n\nif __name__ == '__main__':\n    unittest.main()"]]], 1750727262.4368165]], ["ChangeSet", ["Writing file <test/test_order_manager.py>", [["ChangeContents", ["test/test_order_manager.py", "import pytest\nfrom unittest.mock import Mock\n\nfrom core.orders.order_manager import OrderManager\n\n\ndef test_open_close_paper():\n    om = OrderManager(modo_real=False)\n    om.abrir(\"BTC/EUR\", 100, 90, 120, {\"s1\": 1}, \"bullish\")\n    assert \"BTC/EUR\" in om.ordenes\n\n    om.cerrar(\"BTC/EUR\", 110, \"take\")\n    assert \"BTC/EUR\" not in om.ordenes\n\n\ndef test_open_close_real(monkeypatch):\n    mock_exec = Mock()\n    mock_registrar = Mock()\n    mock_eliminar = Mock()\n    monkeypatch.setattr(\"core.ordenes_reales.ejecutar_orden_market\", mock_exec)\n    monkeypatch.setattr(\"core.ordenes_reales.registrar_orden\", mock_registrar)\n    monkeypatch.setattr(\"core.ordenes_reales.eliminar_orden\", mock_eliminar)\n\n    risk = Mock()\n    om = OrderManager(modo_real=True, risk=risk)\n    om.abrir(\"BTC/EUR\", 100, 90, 120, {\"s1\": 1}, \"bullish\", cantidad=1)\n\n    mock_exec.assert_called_once()\n    mock_registrar.assert_called_once()\n    assert \"BTC/EUR\" in om.ordenes\n\n    om.cerrar(\"BTC/EUR\", 90, \"stop\")\n    mock_eliminar.assert_called_once_with(\"BTC/EUR\")\n    assert risk.registrar_perdida.called\n    assert \"BTC/EUR\" not in om.ordenes", "import pytest\nfrom unittest.mock import Mock\n\nfrom pegaso.core.orders.order_manager import OrderManager\n\n\ndef test_open_close_paper():\n    om = OrderManager(modo_real=False)\n    om.abrir(\"BTC/EUR\", 100, 90, 120, {\"s1\": 1}, \"bullish\")\n    assert \"BTC/EUR\" in om.ordenes\n\n    om.cerrar(\"BTC/EUR\", 110, \"take\")\n    assert \"BTC/EUR\" not in om.ordenes\n\n\ndef test_open_close_real(monkeypatch):\n    mock_exec = Mock()\n    mock_registrar = Mock()\n    mock_eliminar = Mock()\n    monkeypatch.setattr(\"core.ordenes_reales.ejecutar_orden_market\", mock_exec)\n    monkeypatch.setattr(\"core.ordenes_reales.registrar_orden\", mock_registrar)\n    monkeypatch.setattr(\"core.ordenes_reales.eliminar_orden\", mock_eliminar)\n\n    risk = Mock()\n    om = OrderManager(modo_real=True, risk=risk)\n    om.abrir(\"BTC/EUR\", 100, 90, 120, {\"s1\": 1}, \"bullish\", cantidad=1)\n\n    mock_exec.assert_called_once()\n    mock_registrar.assert_called_once()\n    assert \"BTC/EUR\" in om.ordenes\n\n    om.cerrar(\"BTC/EUR\", 90, \"stop\")\n    mock_eliminar.assert_called_once_with(\"BTC/EUR\")\n    assert risk.registrar_perdida.called\n    assert \"BTC/EUR\" not in om.ordenes"]]], 1750727262.4423032]], ["ChangeSet", ["Writing file <test/test_risk_manager.py>", [["ChangeContents", ["test/test_risk_manager.py", "import pytest\nfrom unittest.mock import Mock\n\nfrom core.risk.risk_manager import RiskManager\n\n\ndef test_riesgo_superado(monkeypatch):\n    called = {}\n\n    def fake_check(umbral, capital):\n        called['args'] = (umbral, capital)\n        return True\n\n    monkeypatch.setattr(\"core.risk_manager._riesgo_superado\", fake_check)\n    rm = RiskManager(0.2)\n    assert rm.riesgo_superado(1000) is True\n    assert called['args'] == (0.2, 1000)\n\n\ndef test_registrar_perdida(monkeypatch):\n    mock_update = Mock()\n    monkeypatch.setattr(\"core.risk_manager.actualizar_perdida\", mock_update)\n    rm = RiskManager(0.3)\n    rm.registrar_perdida(\"BTC/EUR\", -0.1)\n    mock_update.assert_called_once_with(\"BTC/EUR\", -0.1)", "import pytest\nfrom unittest.mock import Mock\n\nfrom pegaso.core.risk.risk_manager import RiskManager\n\n\ndef test_riesgo_superado(monkeypatch):\n    called = {}\n\n    def fake_check(umbral, capital):\n        called['args'] = (umbral, capital)\n        return True\n\n    monkeypatch.setattr(\"core.risk_manager._riesgo_superado\", fake_check)\n    rm = RiskManager(0.2)\n    assert rm.riesgo_superado(1000) is True\n    assert called['args'] == (0.2, 1000)\n\n\ndef test_registrar_perdida(monkeypatch):\n    mock_update = Mock()\n    monkeypatch.setattr(\"core.risk_manager.actualizar_perdida\", mock_update)\n    rm = RiskManager(0.3)\n    rm.registrar_perdida(\"BTC/EUR\", -0.1)\n    mock_update.assert_called_once_with(\"BTC/EUR\", -0.1)"]]], 1750727262.4477334]], ["ChangeSet", ["Writing file <test/test_strategy_utils.py>", [["ChangeContents", ["test/test_strategy_utils.py", "import pandas as pd\nimport numpy as np\nfrom core.score_tecnico import calcular_score_tecnico\nfrom core.strategies.entry.validaciones_tecnicas import hay_contradicciones\nfrom core.evaluacion_tecnica import evaluar_estrategias\n\n\ndef test_calcular_score_tecnico():\n    df = pd.DataFrame({'close': np.linspace(1, 10, 10)})\n    score = calcular_score_tecnico(df, rsi=60, momentum=0.01, slope=0.02, tendencia='alcista')\n    assert score == 3\n\n\ndef test_hay_contradicciones():\n    estrategias = {'rsi_alcista': True, 'rsi_bajista': True}\n    assert hay_contradicciones(estrategias)\n    estrategias = {'rsi_alcista': True, 'rsi_bajista': False}\n    assert not hay_contradicciones(estrategias)\n\n\ndef test_evaluar_estrategias(monkeypatch):\n    resultado = {\n        'estrategias_activas': {'e1': True},\n        'puntaje_total': 2.0,\n        'diversidad': 1,\n        'sinergia': 0.1,\n    }\n\n    def fake_eval(symbol, df, tendencia):\n        return resultado\n\n    monkeypatch.setattr('estrategias_entrada.gestor_entradas.evaluar_estrategias', fake_eval)\n    df = pd.DataFrame({'close': [1], 'high': [1], 'low': [1], 'volume': [1]})\n    res = evaluar_estrategias('BTC/EUR', df, 'alcista')\n    assert res == resultado", "import pandas as pd\nimport numpy as np\nfrom core.score_tecnico import calcular_score_tecnico\nfrom pegaso.core.strategies.entry.validaciones_tecnicas import hay_contradicciones\nfrom core.evaluacion_tecnica import evaluar_estrategias\n\n\ndef test_calcular_score_tecnico():\n    df = pd.DataFrame({'close': np.linspace(1, 10, 10)})\n    score = calcular_score_tecnico(df, rsi=60, momentum=0.01, slope=0.02, tendencia='alcista')\n    assert score == 3\n\n\ndef test_hay_contradicciones():\n    estrategias = {'rsi_alcista': True, 'rsi_bajista': True}\n    assert hay_contradicciones(estrategias)\n    estrategias = {'rsi_alcista': True, 'rsi_bajista': False}\n    assert not hay_contradicciones(estrategias)\n\n\ndef test_evaluar_estrategias(monkeypatch):\n    resultado = {\n        'estrategias_activas': {'e1': True},\n        'puntaje_total': 2.0,\n        'diversidad': 1,\n        'sinergia': 0.1,\n    }\n\n    def fake_eval(symbol, df, tendencia):\n        return resultado\n\n    monkeypatch.setattr('estrategias_entrada.gestor_entradas.evaluar_estrategias', fake_eval)\n    df = pd.DataFrame({'close': [1], 'high': [1], 'low': [1], 'volume': [1]})\n    res = evaluar_estrategias('BTC/EUR', df, 'alcista')\n    assert res == resultado"]]], 1750727262.4534287]], ["ChangeSet", ["Writing file <test/test_trader.py>", [["ChangeContents", ["test/test_trader.py", "from config.config_manager import Config\nfrom core.trader_modular import Trader\n\n\nclass DummyClient:\n    def fetch_balance(self):\n        return {\"total\": {\"EUR\": 100}}\n\n\ndef test_calcular_cantidad(monkeypatch):\n    monkeypatch.setattr(\"binance_api.cliente.crear_cliente\", lambda config=None: DummyClient())\n    monkeypatch.setattr(\"core.trader_modular.crear_cliente\", lambda config=None: DummyClient())\n    monkeypatch.setattr(\"core.trader_modular.calcular_fraccion_kelly\", lambda: 1.0)\n    monkeypatch.setattr(\"core.trader_modular.cargar_pesos_estrategias\", lambda: {})\n    monkeypatch.setattr(\"core.ordenes_reales.obtener_todas_las_ordenes\", lambda: {})\n\n    cfg = Config(\n        api_key=\"k\",\n        api_secret=\"s\",\n        modo_real=False,\n        intervalo_velas=\"1m\",\n        symbols=[\"BTC/EUR\"],\n        umbral_riesgo_diario=0.1,\n        min_order_eur=10,\n    )\n\n    trader = Trader(cfg)\n    qty = trader._calcular_cantidad(\"BTC/EUR\", 10)\n    assert qty == 10.0", "from pegaso.config.config_manager import Config\nfrom core.trader_modular import Trader\n\n\nclass DummyClient:\n    def fetch_balance(self):\n        return {\"total\": {\"EUR\": 100}}\n\n\ndef test_calcular_cantidad(monkeypatch):\n    monkeypatch.setattr(\"binance_api.cliente.crear_cliente\", lambda config=None: DummyClient())\n    monkeypatch.setattr(\"core.trader_modular.crear_cliente\", lambda config=None: DummyClient())\n    monkeypatch.setattr(\"core.trader_modular.calcular_fraccion_kelly\", lambda: 1.0)\n    monkeypatch.setattr(\"core.trader_modular.cargar_pesos_estrategias\", lambda: {})\n    monkeypatch.setattr(\"core.ordenes_reales.obtener_todas_las_ordenes\", lambda: {})\n\n    cfg = Config(\n        api_key=\"k\",\n        api_secret=\"s\",\n        modo_real=False,\n        intervalo_velas=\"1m\",\n        symbols=[\"BTC/EUR\"],\n        umbral_riesgo_diario=0.1,\n        min_order_eur=10,\n    )\n\n    trader = Trader(cfg)\n    qty = trader._calcular_cantidad(\"BTC/EUR\", 10)\n    assert qty == 10.0"]]], 1750727262.458633]]], []]